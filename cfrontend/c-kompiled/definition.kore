[topCellInitializer{}(LblinitGeneratedTopCell{}()), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/./c.k)")]

module BASIC-K
  sort SortK{} []
  sort SortKItem{} []
endmodule []

module KSEQ
  import BASIC-K []

  // TODO: Provide constructor and functional axioms for `kseq` and `dotk`.
  symbol kseq{}(SortKItem{}, SortK{}) : SortK{} [constructor{}(),functional{}()]
  symbol dotk{}() : SortK{} [constructor{}(),functional{}()]

  symbol append{}(SortK{}, SortK{}) : SortK{} [function{}()]

  axiom{R}
    \equals{SortK{},R}(
      append{}(dotk{}(),K2:SortK{}),
      K2:SortK{})
  []

  axiom{R}
    \equals{SortK{},R}(
      append{}(kseq{}(K1:SortKItem{},K2:SortK{}),K3:SortK{}),
      kseq{}(K1:SortKItem{},append{}(K2:SortK{},K3:SortK{})))
  []

endmodule []

module INJ
  symbol inj{From,To}(From) : To [sortInjection{}()]

  axiom{S1,S2,S3,R}
    \equals{S3,R}(
      inj{S2,S3}(inj{S1,S2}(T:S1)),
      inj{S1,S3}(T:S1))
  []

endmodule []

module K
  import KSEQ []
  import INJ []

  // Defnitions for reachability aliases
  // Until we will have `mu` we resort to dummy definitions
  alias weakExistsFinally{A}(A) : A
  where weakExistsFinally{A}(@X:A) := @X:A []

  alias weakAlwaysFinally{A}(A) : A
  where weakAlwaysFinally{A}(@X:A) := @X:A []

  // Definitions for CTL aliases
  // Until we will have `mu` we resort to dummy definitions
  alias allPathGlobally{A}(A) : A
  where allPathGlobally{A}(@X:A) := @X:A []

endmodule []

module C

// imports
  import K []

// sorts
  sort SortIds{} []
  sort SortTCellFragment{} []
  sort SortDeclarator{} []
  sort SortShiftExpression{} []
  sort SortUnaryOperator{} []
  sort SortParameterList{} []
  sort SortExpressionStatement{} []
  sort SortAbstractDeclarator{} []
  sort SortEnumOfspecifier{} []
  sort SortListTypeQualifier{} []
  sort SortKCellOpt{} []
  sort SortTypeQualifier{} []
  sort SortEnumerator{} []
  sort SortDeclaration{} []
  sort SortMultiplicativeExpression{} []
  sort SortConditionalExpression{} []
  sort SortCastExpression{} []
  sort SortAssignmentExpression{} []
  sort SortListDeclarationSpecifier{} []
  sort SortLogicalOfandExpression{} []
  sort SortEnumeratorList{} []
  sort SortIOInt{} []
  sort SortParameterDeclaration{} []
  sort SortCompoundStatement{} []
  sort SortStatement{} []
  sort SortEnumerationConstant{} []
  sort SortExpression{} []
  sort SortGeneratedTopCellFragment{} []
  sort SortUnaryExpression{} []
  sort SortIOFile{} []
  hooked-sort SortList{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), element{}(LblListItem{}()), concat{}(Lbl'Unds'List'Unds'{}()), unit{}(Lbl'Stop'List{}()), hook{}("LIST.List"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(631,3,631,31)")]
  sort SortExclusiveOforExpression{} []
  sort SortConstantExpression{} []
  sort SortInclusiveOforExpression{} []
  sort SortInitializerList{} []
  sort SortListExternalDeclaration{} []
  sort SortLabeledStatement{} []
  sort SortKCell{} []
  sort SortTypeName{} []
  sort SortFunctionDefinition{} []
  sort SortGeneratedTopCell{} []
  sort SortOslCellOpt{} []
  sort SortGeneratedCounterCell{} []
  sort SortPointer{} []
  sort SortAndExpression{} []
  sort SortInitializer{} []
  sort SortIterationStatement{} []
  hooked-sort SortFloat{} [org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1160,3,1160,34)"), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), hook{}("FLOAT.Float"), hasDomainValues{}()]
  sort SortStructDeclarator{} []
  sort SortAssignmentOperator{} []
  sort SortTCellOpt{} []
  sort SortParameterTypeList{} []
  hooked-sort SortMap{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), element{}(Lbl'UndsPipe'-'-GT-Unds'{}()), concat{}(Lbl'Unds'Map'Unds'{}()), unit{}(Lbl'Stop'Map{}()), hook{}("MAP.Map"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(227,3,227,28)")]
  hooked-sort SortString{} [hook{}("STRING.String"), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1370,3,1370,37)"), hasDomainValues{}()]
  sort SortIOString{} []
  sort SortId{} [org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1975,3,1975,19)"), token{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), hasDomainValues{}()]
  sort SortDeclarationSpecifier{} []
  sort SortGeneratedCounterCellOpt{} []
  sort SortOslCell{} []
  sort SortTranslationUnit{} []
  sort SortStructDeclaration{} []
  sort SortListDeclaration{} []
  sort SortKConfigVar{} [org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(40,3,40,27)"), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/kast.md)"), token{}(), hasDomainValues{}()]
  sort SortSelectionStatement{} []
  sort SortListInitDeclarator{} []
  sort SortInitdeclarator{} []
  sort SortStructDeclaratorList{} []
  sort SortEqualityExpression{} []
  hooked-sort SortInt{} [hook{}("INT.Int"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(888,3,888,28)"), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), hasDomainValues{}()]
  sort SortIOError{} []
  sort SortRelationalExpression{} []
  sort SortSpecifierQualifier{} []
  hooked-sort SortSet{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), element{}(LblSetItem{}()), concat{}(Lbl'Unds'Set'Unds'{}()), unit{}(Lbl'Stop'Set{}()), hook{}("SET.Set"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(506,3,506,28)")]
  sort SortExternalDeclaration{} []
  sort SortAdditiveExpression{} []
  sort SortStructOrFunionSpecifier{} []
  sort SortStorageClassSpecifier{} []
  sort SortLogicalOforExpression{} []
  sort SortJumpStatement{} []
  sort SortStructOrUnion{} []
  sort SortTypedefOfname{} []
  sort SortListSpecifierQualifier{} []
  sort SortStream{} []
  sort SortDirectDeclarator{} []
  sort SortTCell{} []
  sort SortListStatement{} []
  sort SortPostfixExpression{} []
  sort SortDirectAbstractDeclarator{} []
  hooked-sort SortBool{} [hook{}("BOOL.Bool"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(786,3,786,31)"), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), hasDomainValues{}()]
  sort SortListStructDeclaration{} []
  sort SortConstant{} []
  sort SortListAssignmentExpression{} []
  sort SortPrimaryExpression{} []
  sort SortTypeSpecifier{} []

// symbols
  symbol Lbl'BangUnds'C-SYNTAX'Unds'UnaryOperator{}() : SortUnaryOperator{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(185,22,185,24)"), left{}(), format{}("%c!%r"), injective{}()]
  symbol Lbl'Hash'E2BIG{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#E2BIG"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2143,22,2143,54)"), left{}(), format{}("%c#E2BIG%r"), injective{}()]
  symbol Lbl'Hash'EACCES{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#EACCES"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2144,22,2144,56)"), left{}(), format{}("%c#EACCES%r"), injective{}()]
  symbol Lbl'Hash'EADDRINUSE{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#EADDRINUSE"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2193,22,2193,64)"), left{}(), format{}("%c#EADDRINUSE%r"), injective{}()]
  symbol Lbl'Hash'EADDRNOTAVAIL{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#EADDRNOTAVAIL"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2194,22,2194,70)"), left{}(), format{}("%c#EADDRNOTAVAIL%r"), injective{}()]
  symbol Lbl'Hash'EAFNOSUPPORT{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#EAFNOSUPPORT"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2192,22,2192,68)"), left{}(), format{}("%c#EAFNOSUPPORT%r"), injective{}()]
  symbol Lbl'Hash'EAGAIN{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#EAGAIN"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2145,22,2145,56)"), left{}(), format{}("%c#EAGAIN%r"), injective{}()]
  symbol Lbl'Hash'EALREADY{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#EALREADY"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2182,22,2182,60)"), left{}(), format{}("%c#EALREADY%r"), injective{}()]
  symbol Lbl'Hash'EBADF{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#EBADF"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2146,22,2146,54)"), left{}(), format{}("%c#EBADF%r"), injective{}()]
  symbol Lbl'Hash'EBUSY{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#EBUSY"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2147,22,2147,54)"), left{}(), format{}("%c#EBUSY%r"), injective{}()]
  symbol Lbl'Hash'ECHILD{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#ECHILD"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2148,22,2148,56)"), left{}(), format{}("%c#ECHILD%r"), injective{}()]
  symbol Lbl'Hash'ECONNABORTED{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#ECONNABORTED"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2198,22,2198,68)"), left{}(), format{}("%c#ECONNABORTED%r"), injective{}()]
  symbol Lbl'Hash'ECONNREFUSED{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#ECONNREFUSED"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2206,22,2206,68)"), left{}(), format{}("%c#ECONNREFUSED%r"), injective{}()]
  symbol Lbl'Hash'ECONNRESET{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#ECONNRESET"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2199,22,2199,64)"), left{}(), format{}("%c#ECONNRESET%r"), injective{}()]
  symbol Lbl'Hash'EDEADLK{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#EDEADLK"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2149,22,2149,58)"), left{}(), format{}("%c#EDEADLK%r"), injective{}()]
  symbol Lbl'Hash'EDESTADDRREQ{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#EDESTADDRREQ"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2184,22,2184,68)"), left{}(), format{}("%c#EDESTADDRREQ%r"), injective{}()]
  symbol Lbl'Hash'EDOM{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#EDOM"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2150,22,2150,52)"), left{}(), format{}("%c#EDOM%r"), injective{}()]
  symbol Lbl'Hash'EEXIST{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#EEXIST"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2151,22,2151,56)"), left{}(), format{}("%c#EEXIST%r"), injective{}()]
  symbol Lbl'Hash'EFAULT{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#EFAULT"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2152,22,2152,56)"), left{}(), format{}("%c#EFAULT%r"), injective{}()]
  symbol Lbl'Hash'EFBIG{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#EFBIG"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2153,22,2153,54)"), left{}(), format{}("%c#EFBIG%r"), injective{}()]
  symbol Lbl'Hash'EHOSTDOWN{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#EHOSTDOWN"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2207,22,2207,62)"), left{}(), format{}("%c#EHOSTDOWN%r"), injective{}()]
  symbol Lbl'Hash'EHOSTUNREACH{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#EHOSTUNREACH"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2208,22,2208,68)"), left{}(), format{}("%c#EHOSTUNREACH%r"), injective{}()]
  symbol Lbl'Hash'EINPROGRESS{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#EINPROGRESS"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2181,22,2181,66)"), left{}(), format{}("%c#EINPROGRESS%r"), injective{}()]
  symbol Lbl'Hash'EINTR{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#EINTR"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2154,22,2154,54)"), left{}(), format{}("%c#EINTR%r"), injective{}()]
  symbol Lbl'Hash'EINVAL{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#EINVAL"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2155,22,2155,56)"), left{}(), format{}("%c#EINVAL%r"), injective{}()]
  symbol Lbl'Hash'EIO{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#EIO"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2156,22,2156,50)"), left{}(), format{}("%c#EIO%r"), injective{}()]
  symbol Lbl'Hash'EISCONN{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#EISCONN"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2201,22,2201,58)"), left{}(), format{}("%c#EISCONN%r"), injective{}()]
  symbol Lbl'Hash'EISDIR{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#EISDIR"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2157,22,2157,56)"), left{}(), format{}("%c#EISDIR%r"), injective{}()]
  symbol Lbl'Hash'ELOOP{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#ELOOP"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2209,22,2209,54)"), left{}(), format{}("%c#ELOOP%r"), injective{}()]
  symbol Lbl'Hash'EMFILE{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#EMFILE"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2158,22,2158,56)"), left{}(), format{}("%c#EMFILE%r"), injective{}()]
  symbol Lbl'Hash'EMLINK{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#EMLINK"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2159,22,2159,56)"), left{}(), format{}("%c#EMLINK%r"), injective{}()]
  symbol Lbl'Hash'EMSGSIZE{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#EMSGSIZE"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2185,22,2185,60)"), left{}(), format{}("%c#EMSGSIZE%r"), injective{}()]
  symbol Lbl'Hash'ENAMETOOLONG{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#ENAMETOOLONG"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2160,22,2160,68)"), left{}(), format{}("%c#ENAMETOOLONG%r"), injective{}()]
  symbol Lbl'Hash'ENETDOWN{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#ENETDOWN"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2195,22,2195,60)"), left{}(), format{}("%c#ENETDOWN%r"), injective{}()]
  symbol Lbl'Hash'ENETRESET{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#ENETRESET"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2197,22,2197,62)"), left{}(), format{}("%c#ENETRESET%r"), injective{}()]
  symbol Lbl'Hash'ENETUNREACH{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#ENETUNREACH"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2196,22,2196,66)"), left{}(), format{}("%c#ENETUNREACH%r"), injective{}()]
  symbol Lbl'Hash'ENFILE{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#ENFILE"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2161,22,2161,56)"), left{}(), format{}("%c#ENFILE%r"), injective{}()]
  symbol Lbl'Hash'ENOBUFS{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#ENOBUFS"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2200,22,2200,58)"), left{}(), format{}("%c#ENOBUFS%r"), injective{}()]
  symbol Lbl'Hash'ENODEV{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#ENODEV"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2162,22,2162,56)"), left{}(), format{}("%c#ENODEV%r"), injective{}()]
  symbol Lbl'Hash'ENOENT{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#ENOENT"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2163,22,2163,56)"), left{}(), format{}("%c#ENOENT%r"), injective{}()]
  symbol Lbl'Hash'ENOEXEC{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#ENOEXEC"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2164,22,2164,58)"), left{}(), format{}("%c#ENOEXEC%r"), injective{}()]
  symbol Lbl'Hash'ENOLCK{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#ENOLCK"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2165,22,2165,56)"), left{}(), format{}("%c#ENOLCK%r"), injective{}()]
  symbol Lbl'Hash'ENOMEM{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#ENOMEM"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2166,22,2166,56)"), left{}(), format{}("%c#ENOMEM%r"), injective{}()]
  symbol Lbl'Hash'ENOPROTOOPT{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#ENOPROTOOPT"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2187,22,2187,66)"), left{}(), format{}("%c#ENOPROTOOPT%r"), injective{}()]
  symbol Lbl'Hash'ENOSPC{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#ENOSPC"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2167,22,2167,56)"), left{}(), format{}("%c#ENOSPC%r"), injective{}()]
  symbol Lbl'Hash'ENOSYS{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#ENOSYS"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2168,22,2168,56)"), left{}(), format{}("%c#ENOSYS%r"), injective{}()]
  symbol Lbl'Hash'ENOTCONN{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#ENOTCONN"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2202,22,2202,60)"), left{}(), format{}("%c#ENOTCONN%r"), injective{}()]
  symbol Lbl'Hash'ENOTDIR{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#ENOTDIR"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2169,22,2169,58)"), left{}(), format{}("%c#ENOTDIR%r"), injective{}()]
  symbol Lbl'Hash'ENOTEMPTY{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#ENOTEMPTY"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2170,22,2170,62)"), left{}(), format{}("%c#ENOTEMPTY%r"), injective{}()]
  symbol Lbl'Hash'ENOTSOCK{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#ENOTSOCK"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2183,22,2183,60)"), left{}(), format{}("%c#ENOTSOCK%r"), injective{}()]
  symbol Lbl'Hash'ENOTTY{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#ENOTTY"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2171,22,2171,56)"), left{}(), format{}("%c#ENOTTY%r"), injective{}()]
  symbol Lbl'Hash'ENXIO{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#ENXIO"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2172,22,2172,54)"), left{}(), format{}("%c#ENXIO%r"), injective{}()]
  symbol Lbl'Hash'EOF{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#EOF"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2142,22,2142,50)"), left{}(), format{}("%c#EOF%r"), injective{}()]
  symbol Lbl'Hash'EOPNOTSUPP{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#EOPNOTSUPP"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2190,22,2190,64)"), left{}(), format{}("%c#EOPNOTSUPP%r"), injective{}()]
  symbol Lbl'Hash'EOVERFLOW{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#EOVERFLOW"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2210,22,2210,62)"), left{}(), format{}("%c#EOVERFLOW%r"), injective{}()]
  symbol Lbl'Hash'EPERM{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#EPERM"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2173,22,2173,54)"), left{}(), format{}("%c#EPERM%r"), injective{}()]
  symbol Lbl'Hash'EPFNOSUPPORT{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#EPFNOSUPPORT"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2191,22,2191,68)"), left{}(), format{}("%c#EPFNOSUPPORT%r"), injective{}()]
  symbol Lbl'Hash'EPIPE{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#EPIPE"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2174,22,2174,54)"), left{}(), format{}("%c#EPIPE%r"), injective{}()]
  symbol Lbl'Hash'EPROTONOSUPPORT{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#EPROTONOSUPPORT"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2188,22,2188,74)"), left{}(), format{}("%c#EPROTONOSUPPORT%r"), injective{}()]
  symbol Lbl'Hash'EPROTOTYPE{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#EPROTOTYPE"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2186,22,2186,64)"), left{}(), format{}("%c#EPROTOTYPE%r"), injective{}()]
  symbol Lbl'Hash'ERANGE{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#ERANGE"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2175,22,2175,56)"), left{}(), format{}("%c#ERANGE%r"), injective{}()]
  symbol Lbl'Hash'EROFS{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#EROFS"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2176,22,2176,54)"), left{}(), format{}("%c#EROFS%r"), injective{}()]
  symbol Lbl'Hash'ESHUTDOWN{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#ESHUTDOWN"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2203,22,2203,62)"), left{}(), format{}("%c#ESHUTDOWN%r"), injective{}()]
  symbol Lbl'Hash'ESOCKTNOSUPPORT{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#ESOCKTNOSUPPORT"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2189,22,2189,74)"), left{}(), format{}("%c#ESOCKTNOSUPPORT%r"), injective{}()]
  symbol Lbl'Hash'ESPIPE{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#ESPIPE"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2177,22,2177,56)"), left{}(), format{}("%c#ESPIPE%r"), injective{}()]
  symbol Lbl'Hash'ESRCH{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#ESRCH"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2178,22,2178,54)"), left{}(), format{}("%c#ESRCH%r"), injective{}()]
  symbol Lbl'Hash'ETIMEDOUT{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#ETIMEDOUT"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2205,22,2205,62)"), left{}(), format{}("%c#ETIMEDOUT%r"), injective{}()]
  symbol Lbl'Hash'ETOOMANYREFS{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#ETOOMANYREFS"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2204,22,2204,68)"), left{}(), format{}("%c#ETOOMANYREFS%r"), injective{}()]
  symbol Lbl'Hash'EWOULDBLOCK{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#EWOULDBLOCK"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2180,22,2180,66)"), left{}(), format{}("%c#EWOULDBLOCK%r"), injective{}()]
  symbol Lbl'Hash'EXDEV{}() : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}("#EXDEV"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2179,22,2179,54)"), left{}(), format{}("%c#EXDEV%r"), injective{}()]
  hooked-symbol Lbl'Hash'accept'LParUndsRParUnds'K-IO'Unds'IOInt'Unds'Int{}(SortInt{}) : SortIOInt{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("1101"), impure{}(), hook{}("IO.accept"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2308,20,2308,80)"), left{}(), format{}("%c#accept%r %c(%r %1 %c)%r"), function{}()]
  symbol Lbl'Hash'buffer'LParUndsRParUnds'K-IO'Unds'Stream'Unds'K{}(SortK{}) : SortStream{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("1101"), klabel{}("#buffer"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2391,21,2391,30)"), left{}(), format{}("%c#buffer%r %c(%r %1 %c)%r"), injective{}()]
  hooked-symbol Lbl'Hash'close'LParUndsRParUnds'K-IO'Unds'K'Unds'Int{}(SortInt{}) : SortK{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("1101"), impure{}(), hook{}("IO.close"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2282,16,2282,74)"), left{}(), format{}("%c#close%r %c(%r %1 %c)%r"), function{}()]
  hooked-symbol Lbl'Hash'getc'LParUndsRParUnds'K-IO'Unds'IOInt'Unds'Int{}(SortInt{}) : SortIOInt{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("1101"), impure{}(), hook{}("IO.getc"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2263,20,2263,88)"), left{}(), format{}("%c#getc%r %c(%r %1 %c)%r"), function{}()]
  hooked-symbol Lbl'Hash'if'UndsHash'then'UndsHash'else'UndsHash'fi'Unds'K-EQUAL-SYNTAX'Unds'Sort'Unds'Bool'Unds'Sort'Unds'Sort{SortSort}(SortBool{}, SortSort, SortSort) : SortSort [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), smt-hook{}("ite"), right{}(), terminals{}("1010101"), hook{}("KEQUAL.ite"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2026,26,2026,125)"), left{}(), format{}("%c#if%r %1 %c#then%r %2 %c#else%r %3 %c#fi%r"), function{}()]
  hooked-symbol Lbl'Hash'lock'LParUndsCommUndsRParUnds'K-IO'Unds'K'Unds'Int'Unds'Int{}(SortInt{}, SortInt{}) : SortK{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("110101"), impure{}(), hook{}("IO.lock"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2294,16,2294,90)"), left{}(), format{}("%c#lock%r %c(%r %1 %c,%r %2 %c)%r"), function{}()]
  hooked-symbol Lbl'Hash'logToFile{}(SortString{}, SortString{}) : SortK{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), returnsUnit{}(), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("110101"), impure{}(), klabel{}("#logToFile"), hook{}("IO.log"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2379,16,2379,120)"), left{}(), format{}("%c#logToFile%r %c(%r %1 %c,%r %2 %c)%r"), function{}()]
  hooked-symbol Lbl'Hash'mkstemp'LParUndsRParUnds'K-IO'Unds'IOFile'Unds'String{}(SortString{}) : SortIOFile{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("1101"), impure{}(), klabel{}("#mkstemp"), hook{}("IO.mkstemp"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2356,21,2356,83)"), left{}(), format{}("%c#mkstemp%r %c(%r %1 %c)%r"), function{}()]
  symbol Lbl'Hash'open'LParUndsRParUnds'K-IO'Unds'IOInt'Unds'String{}(SortString{}) : SortIOInt{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("1101"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2233,20,2233,58)"), left{}(), format{}("%c#open%r %c(%r %1 %c)%r"), function{}()]
  hooked-symbol Lbl'Hash'open'LParUndsCommUndsRParUnds'K-IO'Unds'IOInt'Unds'String'Unds'String{}(SortString{}, SortString{}) : SortIOInt{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("110101"), impure{}(), hook{}("IO.open"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2234,18,2234,96)"), left{}(), format{}("%c#open%r %c(%r %1 %c,%r %2 %c)%r"), function{}()]
  hooked-symbol Lbl'Hash'putc'LParUndsCommUndsRParUnds'K-IO'Unds'K'Unds'Int'Unds'Int{}(SortInt{}, SortInt{}) : SortK{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("110101"), impure{}(), hook{}("IO.putc"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2273,16,2273,92)"), left{}(), format{}("%c#putc%r %c(%r %1 %c,%r %2 %c)%r"), function{}()]
  hooked-symbol Lbl'Hash'read'LParUndsCommUndsRParUnds'K-IO'Unds'IOString'Unds'Int'Unds'Int{}(SortInt{}, SortInt{}) : SortIOString{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("110101"), impure{}(), hook{}("IO.read"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2264,23,2264,98)"), left{}(), format{}("%c#read%r %c(%r %1 %c,%r %2 %c)%r"), function{}()]
  hooked-symbol Lbl'Hash'remove'LParUndsRParUnds'K-IO'Unds'K'Unds'String{}(SortString{}) : SortK{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("1101"), impure{}(), klabel{}("#remove"), hook{}("IO.remove"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2367,16,2367,84)"), left{}(), format{}("%c#remove%r %c(%r %1 %c)%r"), function{}()]
  hooked-symbol Lbl'Hash'seek'LParUndsCommUndsRParUnds'K-IO'Unds'K'Unds'Int'Unds'Int{}(SortInt{}, SortInt{}) : SortK{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("110101"), impure{}(), hook{}("IO.seek"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2249,16,2249,87)"), left{}(), format{}("%c#seek%r %c(%r %1 %c,%r %2 %c)%r"), function{}()]
  hooked-symbol Lbl'Hash'seekEnd'LParUndsCommUndsRParUnds'K-IO'Unds'K'Unds'Int'Unds'Int{}(SortInt{}, SortInt{}) : SortK{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("110101"), impure{}(), hook{}("IO.seekEnd"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2250,16,2250,95)"), left{}(), format{}("%c#seekEnd%r %c(%r %1 %c,%r %2 %c)%r"), function{}()]
  hooked-symbol Lbl'Hash'shutdownWrite'LParUndsRParUnds'K-IO'Unds'K'Unds'Int{}(SortInt{}) : SortK{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("1101"), impure{}(), hook{}("IO.shutdownWrite"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2309,16,2309,90)"), left{}(), format{}("%c#shutdownWrite%r %c(%r %1 %c)%r"), function{}()]
  symbol Lbl'Hash'stderr'Unds'K-IO'Unds'Int{}() : SortInt{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("1"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2329,19,2329,50)"), left{}(), format{}("%c#stderr%r"), function{}()]
  symbol Lbl'Hash'stdin'Unds'K-IO'Unds'Int{}() : SortInt{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("1"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2327,18,2327,50)"), left{}(), format{}("%c#stdin%r"), function{}()]
  symbol Lbl'Hash'stdout'Unds'K-IO'Unds'Int{}() : SortInt{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("1"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2328,19,2328,50)"), left{}(), format{}("%c#stdout%r"), function{}()]
  hooked-symbol Lbl'Hash'system'LParUndsRParUnds'K-IO'Unds'KItem'Unds'String{}(SortString{}) : SortKItem{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("1101"), impure{}(), klabel{}("#system"), hook{}("IO.system"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2345,20,2345,73)"), left{}(), format{}("%c#system%r %c(%r %1 %c)%r"), function{}()]
  symbol Lbl'Hash'systemResult{}(SortInt{}, SortString{}, SortString{}) : SortKItem{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("11010101"), klabel{}("#systemResult"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2346,20,2346,142)"), left{}(), format{}("%c#systemResult%r %c(%r %1 %c,%r %2 %c,%r %3 %c)%r"), injective{}()]
  hooked-symbol Lbl'Hash'tell'LParUndsRParUnds'K-IO'Unds'IOInt'Unds'Int{}(SortInt{}) : SortIOInt{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("1101"), impure{}(), hook{}("IO.tell"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2248,20,2248,76)"), left{}(), format{}("%c#tell%r %c(%r %1 %c)%r"), function{}()]
  symbol Lbl'Hash'tempFile{}(SortString{}, SortInt{}) : SortIOFile{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("110101"), klabel{}("#tempFile"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2358,21,2358,92)"), left{}(), format{}("%c#tempFile%r %c(%r %1 %c,%r %2 %c)%r"), injective{}()]
  hooked-symbol Lbl'Hash'time'LParRParUnds'K-IO'Unds'Int{}() : SortInt{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("111"), impure{}(), hook{}("IO.time"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2318,18,2318,66)"), left{}(), format{}("%c#time%r %c(%r %c)%r"), function{}()]
  symbol Lbl'Hash'unknownIOError{}(SortInt{}) : SortIOError{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1101"), klabel{}("#unknownIOError"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2142,54,2142,89)"), left{}(), format{}("%c#unknownIOError%r %c(%r %1 %c)%r"), injective{}()]
  hooked-symbol Lbl'Hash'unlock'LParUndsCommUndsRParUnds'K-IO'Unds'K'Unds'Int'Unds'Int{}(SortInt{}, SortInt{}) : SortK{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("110101"), impure{}(), hook{}("IO.unlock"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2295,16,2295,94)"), left{}(), format{}("%c#unlock%r %c(%r %1 %c,%r %2 %c)%r"), function{}()]
  hooked-symbol Lbl'Hash'write'LParUndsCommUndsRParUnds'K-IO'Unds'K'Unds'Int'Unds'String{}(SortInt{}, SortString{}) : SortK{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("110101"), impure{}(), hook{}("IO.write"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2274,16,2274,92)"), left{}(), format{}("%c#write%r %c(%r %1 %c,%r %2 %c)%r"), function{}()]
  symbol Lbl'PercEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}() : SortAssignmentOperator{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(171,27,171,30)"), left{}(), format{}("%c%%=%r"), injective{}()]
  symbol Lbl'And-EqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}() : SortAssignmentOperator{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(176,27,176,30)"), left{}(), format{}("%c&=%r"), injective{}()]
  symbol Lbl'And-Unds'C-SYNTAX'Unds'UnaryOperator{}() : SortUnaryOperator{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(180,26,180,28)"), left{}(), format{}("%c&%r"), injective{}()]
  symbol Lbl'LParRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator{}() : SortDirectAbstractDeclarator{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("11"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(216,34,216,40)"), left{}(), format{}("%c(%r %c)%r"), injective{}()]
  symbol Lbl'LParUndsRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'AbstractDeclarator{}(SortAbstractDeclarator{}) : SortDirectAbstractDeclarator{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("101"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(208,38,208,63)"), left{}(), format{}("%c(%r %1 %c)%r"), injective{}()]
  symbol Lbl'LParUndsRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'ParameterTypeList{}(SortParameterTypeList{}) : SortDirectAbstractDeclarator{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("101"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(215,34,215,58)"), left{}(), format{}("%c(%r %1 %c)%r"), injective{}()]
  symbol Lbl'LParUndsRParUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'Declarator{}(SortDeclarator{}) : SortDirectDeclarator{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("101"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(80,25,80,42)"), left{}(), format{}("%c(%r %1 %c)%r"), injective{}()]
  symbol Lbl'LParUndsRParUnds'C-SYNTAX'Unds'PrimaryExpression'Unds'Expression{}(SortExpression{}) : SortPrimaryExpression{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("101"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(154,27,154,44)"), left{}(), format{}("%c(%r %1 %c)%r"), injective{}()]
  symbol Lbl'LParUndsRParUndsUnds'C-SYNTAX'Unds'CastExpression'Unds'TypeName'Unds'CastExpression{}(SortTypeName{}, SortCastExpression{}) : SortCastExpression{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1010"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(132,23,132,53)"), left{}(), format{}("%c(%r %1 %c)%r %2"), injective{}()]
  symbol Lbl'StarEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}() : SortAssignmentOperator{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(169,27,169,30)"), left{}(), format{}("%c*=%r"), injective{}()]
  symbol Lbl'StarUnds'C-SYNTAX'Unds'UnaryOperator{}() : SortUnaryOperator{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(181,22,181,24)"), left{}(), format{}("%c*%r"), injective{}()]
  symbol Lbl'StarUndsUnds'C-SYNTAX'Unds'Pointer'Unds'ListTypeQualifier{}(SortListTypeQualifier{}) : SortPointer{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("10"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(71,19,71,39)"), left{}(), format{}("%c*%r %1"), injective{}()]
  symbol Lbl'StarUndsUndsUnds'C-SYNTAX'Unds'Pointer'Unds'ListTypeQualifier'Unds'Pointer{}(SortListTypeQualifier{}, SortPointer{}) : SortPointer{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("100"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(70,20,70,48)"), left{}(), format{}("%c*%r %1 %2"), injective{}()]
  symbol Lbl'PlusPlusUndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'UnaryExpression{}(SortUnaryExpression{}) : SortUnaryExpression{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("10"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(135,24,135,43)"), left{}(), format{}("%c++%r %1"), injective{}()]
  symbol Lbl'PlusEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}() : SortAssignmentOperator{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(172,27,172,30)"), left{}(), format{}("%c+=%r"), injective{}()]
  symbol Lbl'PlusUnds'C-SYNTAX'Unds'UnaryOperator{}() : SortUnaryOperator{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(182,22,182,24)"), left{}(), format{}("%c+%r"), injective{}()]
  symbol Lbl--'UndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'UnaryExpression{}(SortUnaryExpression{}) : SortUnaryExpression{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("10"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(136,24,136,43)"), left{}(), format{}("%c--%r %1"), injective{}()]
  symbol Lbl-'Unds'C-SYNTAX'Unds'UnaryOperator{}() : SortUnaryOperator{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(183,22,183,24)"), left{}(), format{}("%c-%r"), injective{}()]
  hooked-symbol Lbl'Stop'List{}() : SortList{} [latex{}("\\dotCt{List}"), functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), smtlib{}("smt_seq_nil"), terminals{}("1"), klabel{}(".List"), hook{}("LIST.unit"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(655,19,655,146)"), left{}(), format{}("%c.List%r"), function{}()]
  symbol Lbl'Stop'List'LBraQuotUndsCommUndsUnds'C-SYNTAX'Unds'EnumeratorList'Unds'Enumerator'Unds'EnumeratorList'QuotRBraUnds'EnumeratorList{}() : SortEnumeratorList{} [functional{}(), constructor{}(), userList{}("*"), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1"), klabel{}(".List{\"_,__C-SYNTAX\"}"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(225,27,225,47)"), left{}(), format{}("%c.EnumeratorList%r"), injective{}()]
  symbol Lbl'Stop'List'LBraQuotUndsCommUndsUnds'C-SYNTAX'Unds'ListAssignmentExpression'Unds'AssignmentExpression'Unds'ListAssignmentExpression'QuotRBraUnds'ListAssignmentExpression{}() : SortListAssignmentExpression{} [functional{}(), constructor{}(), userList{}("*"), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1"), klabel{}(".List{\"_,__C-SYNTAX\"}"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(149,37,149,66)"), left{}(), format{}("%c.ListAssignmentExpression%r"), injective{}()]
  symbol Lbl'Stop'List'LBraQuotUndsCommUndsUnds'C-SYNTAX'Unds'ListInitDeclarator'Unds'Initdeclarator'Unds'ListInitDeclarator'QuotRBraUnds'ListInitDeclarator{}() : SortListInitDeclarator{} [functional{}(), constructor{}(), userList{}("*"), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1"), klabel{}(".List{\"_,__C-SYNTAX\"}"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(234,31,234,54)"), left{}(), format{}("%c.ListInitDeclarator%r"), injective{}()]
  symbol Lbl'Stop'List'LBraQuotUndsSClnUndsUnds'C-SYNTAX'Unds'ListStructDeclaration'Unds'StructDeclaration'Unds'ListStructDeclaration'QuotRBraUnds'ListStructDeclaration{}() : SortListStructDeclaration{} [functional{}(), constructor{}(), userList{}("*"), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1"), klabel{}(".List{\"_;__C-SYNTAX\"}"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(47,34,47,60)"), left{}(), format{}("%c.ListStructDeclaration%r"), injective{}()]
  symbol Lbl'Stop'List'LBraQuotUndsUndsUnds'C-SYNTAX'Unds'Ids'Unds'Id'Unds'Ids'QuotRBraUnds'Ids{}() : SortIds{} [functional{}(), constructor{}(), userList{}("*"), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1"), klabel{}(".List{\"___C-SYNTAX\"}"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(86,16,86,26)"), left{}(), format{}("%c.Ids%r"), injective{}()]
  symbol Lbl'Stop'List'LBraQuotUndsUndsUnds'C-SYNTAX'Unds'ListDeclarationSpecifier'Unds'DeclarationSpecifier'Unds'ListDeclarationSpecifier'QuotRBraUnds'ListDeclarationSpecifier{}() : SortListDeclarationSpecifier{} [functional{}(), constructor{}(), userList{}("+"), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1"), klabel{}(".List{\"___C-SYNTAX\"}"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(202,37,202,67)"), left{}(), format{}("%c.ListDeclarationSpecifier%r"), injective{}()]
  symbol Lbl'Stop'List'LBraQuotUndsUndsUnds'C-SYNTAX'Unds'ListDeclaration'Unds'Declaration'Unds'ListDeclaration'QuotRBraUnds'ListDeclaration{}() : SortListDeclaration{} [functional{}(), constructor{}(), userList{}("*"), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1"), klabel{}(".List{\"___C-SYNTAX\"}"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(16,28,16,47)"), left{}(), format{}("%c.ListDeclaration%r"), injective{}()]
  symbol Lbl'Stop'List'LBraQuotUndsUndsUnds'C-SYNTAX'Unds'ListExternalDeclaration'Unds'ExternalDeclaration'Unds'ListExternalDeclaration'QuotRBraUnds'ListExternalDeclaration{}() : SortListExternalDeclaration{} [functional{}(), constructor{}(), userList{}("*"), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1"), klabel{}(".List{\"___C-SYNTAX\"}"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(9,36,9,63)"), left{}(), format{}("%c.ListExternalDeclaration%r"), injective{}()]
  symbol Lbl'Stop'List'LBraQuotUndsUndsUnds'C-SYNTAX'Unds'ListSpecifierQualifier'Unds'SpecifierQualifier'Unds'ListSpecifierQualifier'QuotRBraUnds'ListSpecifierQualifier{}() : SortListSpecifierQualifier{} [functional{}(), constructor{}(), userList{}("*"), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1"), klabel{}(".List{\"___C-SYNTAX\"}"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(54,35,54,61)"), left{}(), format{}("%c.ListSpecifierQualifier%r"), injective{}()]
  symbol Lbl'Stop'List'LBraQuotUndsUndsUnds'C-SYNTAX'Unds'ListStatement'Unds'Statement'Unds'ListStatement'QuotRBraUnds'ListStatement{}() : SortListStatement{} [functional{}(), constructor{}(), userList{}("*"), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1"), klabel{}(".List{\"___C-SYNTAX\"}"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(248,26,248,43)"), left{}(), format{}("%c.ListStatement%r"), injective{}()]
  symbol Lbl'Stop'List'LBraQuotUndsUndsUnds'C-SYNTAX'Unds'ListTypeQualifier'Unds'TypeQualifier'Unds'ListTypeQualifier'QuotRBraUnds'ListTypeQualifier{}() : SortListTypeQualifier{} [functional{}(), constructor{}(), userList{}("*"), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1"), klabel{}(".List{\"___C-SYNTAX\"}"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(73,30,73,51)"), left{}(), format{}("%c.ListTypeQualifier%r"), injective{}()]
  hooked-symbol Lbl'Stop'Map{}() : SortMap{} [latex{}("\\dotCt{Map}"), functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}(".Map"), hook{}("MAP.unit"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(257,18,257,128)"), left{}(), format{}("%c.Map%r"), function{}()]
  hooked-symbol Lbl'Stop'Set{}() : SortSet{} [latex{}("\\dotCt{Set}"), functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1"), klabel{}(".Set"), hook{}("SET.unit"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(535,18,535,122)"), left{}(), format{}("%c.Set%r"), function{}()]
  symbol Lbl'SlshEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}() : SortAssignmentOperator{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(170,27,170,30)"), left{}(), format{}("%c/=%r"), injective{}()]
  symbol Lbl'ColnUndsUnds'C-SYNTAX'Unds'StructDeclarator'Unds'ConstantExpression{}(SortConstantExpression{}) : SortStructDeclarator{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("10"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(65,25,65,46)"), left{}(), format{}("%c:%r %1"), injective{}()]
  symbol Lbl'SClnUnds'C-SYNTAX'Unds'ExpressionStatement{}() : SortExpressionStatement{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(262,35,262,37)"), left{}(), format{}("%c;%r"), injective{}()]
  symbol Lbl'-LT-'T'-GT-'{}(SortKCell{}, SortOslCell{}) : SortTCell{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/./c.k)"), color{}("yellow"), cellName{}("T"), priorities{}(), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), right{}(), terminals{}("1001"), contentStartLine{}("9"), contentStartColumn{}("9"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(9,9,12,13)"), left{}(), format{}("%c<T>%r%i%n%1%n%2%d%n%c</T>%r"), colors{}("yellow,yellow"), injective{}(), cell{}(), topcell{}()]
  symbol Lbl'-LT-'T'-GT-'-fragment{}(SortKCellOpt{}, SortOslCellOpt{}) : SortTCellFragment{} [functional{}(), constructor{}(), cellFragment{}("TCell"), priorities{}(), right{}(), terminals{}("1001"), left{}(), format{}("%c<T>-fragment%r %1 %2 %c</T>-fragment%r"), injective{}()]
  symbol Lbl'-LT-'generatedCounter'-GT-'{}(SortInt{}) : SortGeneratedCounterCell{} [functional{}(), constructor{}(), cellName{}("generatedCounter"), priorities{}(), right{}(), terminals{}("101"), left{}(), format{}("%c<generatedCounter>%r%i%n%1%d%n%c</generatedCounter>%r"), injective{}(), cell{}()]
  symbol Lbl'-LT-'generatedTop'-GT-'{}(SortTCell{}, SortGeneratedCounterCell{}) : SortGeneratedTopCell{} [functional{}(), constructor{}(), cellName{}("generatedTop"), priorities{}(), right{}(), terminals{}("1001"), left{}(), format{}("%1"), injective{}(), cell{}(), topcell{}()]
  symbol Lbl'-LT-'generatedTop'-GT-'-fragment{}(SortTCellOpt{}, SortGeneratedCounterCellOpt{}) : SortGeneratedTopCellFragment{} [functional{}(), constructor{}(), cellFragment{}("GeneratedTopCell"), priorities{}(), right{}(), terminals{}("1001"), left{}(), format{}("%c<generatedTop>-fragment%r %1 %2 %c</generatedTop>-fragment%r"), injective{}()]
  symbol Lbl'-LT-'k'-GT-'{}(SortK{}) : SortKCell{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/./c.k)"), color{}("green"), cellName{}("k"), maincell{}(), priorities{}(), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), right{}(), terminals{}("101"), contentStartLine{}("9"), contentStartColumn{}("9"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(9,9,12,13)"), left{}(), format{}("%c<k>%r%i%n%1%d%n%c</k>%r"), colors{}("green,green"), injective{}(), cell{}()]
  symbol Lbl'-LT-'osl'-GT-'{}(SortK{}) : SortOslCell{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/./c.k)"), color{}("red"), cellName{}("osl"), priorities{}(), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), right{}(), terminals{}("101"), contentStartLine{}("9"), contentStartColumn{}("9"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(9,9,12,13)"), left{}(), format{}("%c<osl>%r%i%n%1%d%n%c</osl>%r"), colors{}("red,red"), injective{}(), cell{}()]
  symbol Lbl'EqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}() : SortAssignmentOperator{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(168,31,168,33)"), left{}(), format{}("%c=%r"), injective{}()]
  hooked-symbol LblBase2String'LParUndsCommUndsRParUnds'STRING-COMMON'Unds'String'Unds'Int'Unds'Int{}(SortInt{}, SortInt{}) : SortString{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("110101"), klabel{}("Base2String"), hook{}("STRING.base2string"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1498,21,1498,98)"), left{}(), format{}("%cBase2String%r %c(%r %1 %c,%r %2 %c)%r"), function{}()]
  symbol LblBool2String'LParUndsRParUnds'STRING-COMMON'Unds'String'Unds'Bool{}(SortBool{}) : SortString{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("1101"), klabel{}("Bool2String"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1448,21,1448,60)"), left{}(), format{}("%cBool2String%r %c(%r %1 %c)%r"), function{}()]
  hooked-symbol LblFloat2String'LParUndsRParUnds'STRING-COMMON'Unds'String'Unds'Float{}(SortFloat{}) : SortString{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("1101"), klabel{}("Float2String"), hook{}("STRING.float2string"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1475,21,1475,105)"), left{}(), format{}("%cFloat2String%r %c(%r %1 %c)%r"), function{}()]
  hooked-symbol LblFloat2String'LParUndsCommUndsRParUnds'STRING-COMMON'Unds'String'Unds'Float'Unds'String{}(SortFloat{}, SortString{}) : SortString{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("110101"), klabel{}("FloatFormat"), hook{}("STRING.floatFormat"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1476,21,1476,121)"), left{}(), format{}("%cFloat2String%r %c(%r %1 %c,%r %2 %c)%r"), function{}()]
  hooked-symbol LblId2String'LParUndsRParUnds'ID-COMMON'Unds'String'Unds'Id{}(SortId{}) : SortString{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("1101"), klabel{}("Id2String"), hook{}("STRING.token2string"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1982,21,1982,89)"), left{}(), format{}("%cId2String%r %c(%r %1 %c)%r"), function{}()]
  hooked-symbol LblInt2String'LParUndsRParUnds'STRING-COMMON'Unds'String'Unds'Int{}(SortInt{}) : SortString{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("1101"), klabel{}("Int2String"), hook{}("STRING.int2string"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1497,21,1497,103)"), left{}(), format{}("%cInt2String%r %c(%r %1 %c)%r"), function{}()]
  hooked-symbol LblList'Coln'get{}(SortList{}, SortInt{}) : SortKItem{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("0101"), klabel{}("List:get"), hook{}("LIST.get"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(674,20,674,98)"), left{}(), format{}("%1 %c[%r %2 %c]%r"), function{}()]
  hooked-symbol LblList'Coln'range{}(SortList{}, SortInt{}, SortInt{}) : SortList{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("11010101"), klabel{}("List:range"), hook{}("LIST.range"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(721,19,721,119)"), left{}(), format{}("%crange%r %c(%r %1 %c,%r %2 %c,%r %3 %c)%r"), function{}()]
  hooked-symbol LblListItem{}(SortKItem{}) : SortList{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), smtlib{}("smt_seq_elem"), terminals{}("1101"), klabel{}("ListItem"), hook{}("LIST.element"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(663,19,663,136)"), left{}(), format{}("%cListItem%r %c(%r %1 %c)%r"), function{}()]
  hooked-symbol LblMap'Coln'lookup{}(SortMap{}, SortKItem{}) : SortKItem{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("0101"), klabel{}("Map:lookup"), hook{}("MAP.lookup"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(280,20,280,112)"), left{}(), format{}("%1 %c[%r %2 %c]%r"), function{}()]
  hooked-symbol LblMap'Coln'update{}(SortMap{}, SortKItem{}, SortKItem{}) : SortMap{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), prefer{}(), right{}(), terminals{}("010101"), klabel{}("Map:update"), hook{}("MAP.update"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(299,18,299,144)"), left{}(), format{}("%1 %c[%r %2 %c<-%r %3 %c]%r"), function{}()]
  symbol LblOf'EqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}() : SortAssignmentOperator{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(173,27,173,31)"), left{}(), format{}("%cOf=%r"), injective{}()]
  hooked-symbol LblSet'Coln'difference{}(SortSet{}, SortSet{}) : SortSet{} [latex{}("{#1}-_{\\it Set}{#2}"), functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("010"), klabel{}("Set:difference"), hook{}("SET.difference"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(575,18,575,146)"), left{}(), format{}("%1 %c-Set%r %2"), function{}()]
  hooked-symbol LblSet'Coln'in{}(SortKItem{}, SortSet{}) : SortBool{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("010"), klabel{}("Set:in"), hook{}("SET.in"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(583,19,583,106)"), left{}(), format{}("%1 %cin%r %2"), function{}()]
  hooked-symbol LblSetItem{}(SortKItem{}) : SortSet{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1101"), klabel{}("SetItem"), hook{}("SET.element"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(543,18,543,112)"), left{}(), format{}("%cSetItem%r %c(%r %1 %c)%r"), function{}()]
  hooked-symbol LblString2Base'LParUndsCommUndsRParUnds'STRING-COMMON'Unds'Int'Unds'String'Unds'Int{}(SortString{}, SortInt{}) : SortInt{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("110101"), klabel{}("String2Base"), hook{}("STRING.string2base"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1499,21,1499,98)"), left{}(), format{}("%cString2Base%r %c(%r %1 %c,%r %2 %c)%r"), function{}()]
  symbol LblString2Bool'LParUndsRParUnds'STRING-COMMON'Unds'Bool'Unds'String{}(SortString{}) : SortBool{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("1101"), klabel{}("String2Bool"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1454,19,1454,48)"), left{}(), format{}("%cString2Bool%r %c(%r %1 %c)%r"), function{}()]
  hooked-symbol LblString2Float'LParUndsRParUnds'STRING-COMMON'Unds'Float'Unds'String{}(SortString{}) : SortFloat{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("1101"), klabel{}("String2Float"), hook{}("STRING.string2float"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1477,21,1477,93)"), left{}(), format{}("%cString2Float%r %c(%r %1 %c)%r"), function{}()]
  hooked-symbol LblString2Id'LParUndsRParUnds'ID-COMMON'Unds'Id'Unds'String{}(SortString{}) : SortId{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("1101"), klabel{}("String2Id"), hook{}("STRING.string2token"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1983,17,1983,84)"), left{}(), format{}("%cString2Id%r %c(%r %1 %c)%r"), function{}()]
  hooked-symbol LblString2Int'LParUndsRParUnds'STRING-COMMON'Unds'Int'Unds'String{}(SortString{}) : SortInt{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("1101"), klabel{}("String2Int"), hook{}("STRING.string2int"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1496,21,1496,91)"), left{}(), format{}("%cString2Int%r %c(%r %1 %c)%r"), function{}()]
  symbol Lbl'LSqBRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator{}() : SortDirectAbstractDeclarator{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("11"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(212,34,212,40)"), left{}(), format{}("%c[%r %c]%r"), injective{}()]
  symbol Lbl'LSqBUndsRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'ConstantExpression{}(SortConstantExpression{}) : SortDirectAbstractDeclarator{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("101"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(211,34,211,59)"), left{}(), format{}("%c[%r %1 %c]%r"), injective{}()]
  symbol Lbl'Xor-EqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}() : SortAssignmentOperator{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(177,27,177,30)"), left{}(), format{}("%c^=%r"), injective{}()]
  symbol Lbl'UndsBangEqlsUndsUnds'C-SYNTAX'Unds'EqualityExpression'Unds'EqualityExpression'Unds'RelationalExpression{}(SortEqualityExpression{}, SortRelationalExpression{}) : SortEqualityExpression{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("010"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(110,27,110,70)"), left{}(), format{}("%1 %c!=%r %2"), injective{}()]
  hooked-symbol Lbl'UndsPerc'Int'Unds'{}(SortInt{}, SortInt{}) : SortInt{} [latex{}("{#1}\\mathrel{\\%_{\\scriptstyle\\it Int}}{#2}"), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(Lbl'UndsPlus'Int'Unds'{}(),Lbl'Unds-GT--GT-'Int'Unds'{}(),Lbl'Unds'xorInt'Unds'{}(),Lbl'UndsAnd-'Int'Unds'{}(),Lbl'Unds-LT--LT-'Int'Unds'{}(),Lbl'UndsPipe'Int'Unds'{}(),Lbl'Unds'-Int'Unds'{}()), smt-hook{}("mod"), right{}(), terminals{}("010"), klabel{}("_%Int_"), hook{}("INT.tmod"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(936,18,936,170)"), left{}(Lbl'UndsStar'Int'Unds'{}(),Lbl'Unds'divInt'Unds'{}(),Lbl'UndsPerc'Int'Unds'{}(),Lbl'UndsSlsh'Int'Unds'{}(),Lbl'Unds'modInt'Unds'{}()), format{}("%1 %c%%Int%r %2"), function{}()]
  symbol Lbl'UndsPercUndsUnds'C-SYNTAX'Unds'MultiplicativeExpression'Unds'MultiplicativeExpression'Unds'CastExpression{}(SortMultiplicativeExpression{}, SortCastExpression{}) : SortMultiplicativeExpression{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("010"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(129,33,129,75)"), left{}(), format{}("%1 %c%%%r %2"), injective{}()]
  symbol Lbl'UndsAnd-And-UndsUnds'C-SYNTAX'Unds'LogicalOfandExpression'Unds'LogicalOfandExpression'Unds'InclusiveOforExpression{}(SortLogicalOfandExpression{}, SortInclusiveOforExpression{}) : SortLogicalOfandExpression{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("010"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(97,30,97,80)"), left{}(), format{}("%1 %c&&%r %2"), injective{}()]
  hooked-symbol Lbl'UndsAnd-'Int'Unds'{}(SortInt{}, SortInt{}) : SortInt{} [latex{}("{#1}\\mathrel{\\&_{\\scriptstyle\\it Int}}{#2}"), functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(Lbl'Unds'xorInt'Unds'{}(),Lbl'UndsPipe'Int'Unds'{}()), right{}(), smtlib{}("andInt"), terminals{}("010"), klabel{}("_&Int_"), hook{}("INT.and"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(947,18,947,182)"), left{}(Lbl'UndsAnd-'Int'Unds'{}()), format{}("%1 %c&Int%r %2"), function{}()]
  symbol Lbl'UndsAnd-UndsUnds'C-SYNTAX'Unds'AndExpression'Unds'AndExpression'Unds'EqualityExpression{}(SortAndExpression{}, SortEqualityExpression{}) : SortAndExpression{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("010"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(106,22,106,57)"), left{}(), format{}("%1 %c&%r %2"), injective{}()]
  symbol Lbl'UndsLParRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator{}(SortDirectAbstractDeclarator{}) : SortDirectAbstractDeclarator{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("011"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(214,34,214,65)"), left{}(), format{}("%1 %c(%r %c)%r"), injective{}()]
  symbol Lbl'UndsLParUndsRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator'Unds'ParameterTypeList{}(SortDirectAbstractDeclarator{}, SortParameterTypeList{}) : SortDirectAbstractDeclarator{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("0101"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(213,34,213,83)"), left{}(), format{}("%1 %c(%r %2 %c)%r"), injective{}()]
  symbol Lbl'UndsLParUndsRParUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'DirectDeclarator'Unds'Ids{}(SortDirectDeclarator{}, SortIds{}) : SortDirectDeclarator{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("0101"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(84,25,84,52)"), left{}(), format{}("%1 %c(%r %2 %c)%r"), injective{}()]
  symbol Lbl'UndsLParUndsRParUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'DirectDeclarator'Unds'ParameterTypeList{}(SortDirectDeclarator{}, SortParameterTypeList{}) : SortDirectDeclarator{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("0101"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(83,25,83,66)"), left{}(), format{}("%1 %c(%r %2 %c)%r"), injective{}()]
  symbol Lbl'UndsLParUndsRParUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression'Unds'ListAssignmentExpression{}(SortPostfixExpression{}, SortListAssignmentExpression{}) : SortPostfixExpression{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("0101"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(143,26,143,75)"), left{}(), format{}("%1 %c(%r %2 %c)%r"), injective{}()]
  hooked-symbol Lbl'UndsStar'Int'Unds'{}(SortInt{}, SortInt{}) : SortInt{} [latex{}("{#1}\\mathrel{\\ast_{\\scriptstyle\\it Int}}{#2}"), functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(Lbl'UndsPlus'Int'Unds'{}(),Lbl'Unds-GT--GT-'Int'Unds'{}(),Lbl'Unds'xorInt'Unds'{}(),Lbl'UndsAnd-'Int'Unds'{}(),Lbl'Unds-LT--LT-'Int'Unds'{}(),Lbl'UndsPipe'Int'Unds'{}(),Lbl'Unds'-Int'Unds'{}()), smt-hook{}("*"), right{}(), terminals{}("010"), klabel{}("_*Int_"), hook{}("INT.mul"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(932,18,932,181)"), left{}(Lbl'Unds'modInt'Unds'{}(),Lbl'UndsPerc'Int'Unds'{}(),Lbl'UndsSlsh'Int'Unds'{}(),Lbl'Unds'divInt'Unds'{}(),Lbl'UndsStar'Int'Unds'{}()), format{}("%1 %c*Int%r %2"), function{}()]
  symbol Lbl'UndsStarUndsUnds'C-SYNTAX'Unds'MultiplicativeExpression'Unds'MultiplicativeExpression'Unds'CastExpression{}(SortMultiplicativeExpression{}, SortCastExpression{}) : SortMultiplicativeExpression{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("010"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(127,33,127,75)"), left{}(), format{}("%1 %c*%r %2"), injective{}()]
  symbol Lbl'UndsPlusPlusUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression{}(SortPostfixExpression{}) : SortPostfixExpression{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("01"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(146,26,146,47)"), left{}(), format{}("%1 %c++%r"), injective{}()]
  hooked-symbol Lbl'UndsPlus'Int'Unds'{}(SortInt{}, SortInt{}) : SortInt{} [latex{}("{#1}\\mathrel{+_{\\scriptstyle\\it Int}}{#2}"), functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(Lbl'Unds-GT--GT-'Int'Unds'{}(),Lbl'Unds'xorInt'Unds'{}(),Lbl'UndsAnd-'Int'Unds'{}(),Lbl'Unds-LT--LT-'Int'Unds'{}(),Lbl'UndsPipe'Int'Unds'{}()), smt-hook{}("+"), right{}(), terminals{}("010"), klabel{}("_+Int_"), hook{}("INT.add"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(941,18,941,178)"), left{}(Lbl'UndsPlus'Int'Unds'{}(),Lbl'Unds'-Int'Unds'{}()), format{}("%1 %c+Int%r %2"), function{}()]
  hooked-symbol Lbl'UndsPlus'String'UndsUnds'STRING-COMMON'Unds'String'Unds'String'Unds'String{}(SortString{}, SortString{}) : SortString{} [latex{}("{#1}+_{\\scriptstyle\\it String}{#2}"), functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("010"), hook{}("STRING.concat"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1387,21,1387,139)"), left{}(Lbl'UndsPlus'String'UndsUnds'STRING-COMMON'Unds'String'Unds'String'Unds'String{}()), format{}("%1 %c+String%r %2"), function{}()]
  symbol Lbl'UndsPlusUndsUnds'C-SYNTAX'Unds'AdditiveExpression'Unds'AdditiveExpression'Unds'MultiplicativeExpression{}(SortAdditiveExpression{}, SortMultiplicativeExpression{}) : SortAdditiveExpression{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("010"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(123,27,123,73)"), left{}(), format{}("%1 %c+%r %2"), injective{}()]
  symbol Lbl'UndsCommStopStopStopUnds'C-SYNTAX'Unds'ParameterTypeList'Unds'ParameterList{}(SortParameterList{}) : SortParameterTypeList{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("011"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(193,27,193,49)"), left{}(), format{}("%1 %c,%r %c...%r"), injective{}()]
  symbol Lbl'UndsCommUndsUnds'C-SYNTAX'Unds'EnumeratorList'Unds'Enumerator'Unds'EnumeratorList{}(SortEnumerator{}, SortEnumeratorList{}) : SortEnumeratorList{} [functional{}(), constructor{}(), userList{}("*"), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("010"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(225,27,225,47)"), left{}(), format{}("%1 %c,%r %2"), injective{}()]
  symbol Lbl'UndsCommUndsUnds'C-SYNTAX'Unds'Expression'Unds'Expression'Unds'AssignmentExpression{}(SortExpression{}, SortAssignmentExpression{}) : SortExpression{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("010"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(163,18,163,52)"), left{}(), format{}("%1 %c,%r %2"), injective{}()]
  symbol Lbl'UndsCommUndsUnds'C-SYNTAX'Unds'InitializerList'Unds'InitializerList'Unds'Initializer{}(SortInitializerList{}, SortInitializer{}) : SortInitializerList{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("010"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(244,24,244,54)"), left{}(), format{}("%1 %c,%r %2"), injective{}()]
  symbol Lbl'UndsCommUndsUnds'C-SYNTAX'Unds'ListAssignmentExpression'Unds'AssignmentExpression'Unds'ListAssignmentExpression{}(SortAssignmentExpression{}, SortListAssignmentExpression{}) : SortListAssignmentExpression{} [functional{}(), constructor{}(), userList{}("*"), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("010"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(149,37,149,66)"), left{}(), format{}("%1 %c,%r %2"), injective{}()]
  symbol Lbl'UndsCommUndsUnds'C-SYNTAX'Unds'ListInitDeclarator'Unds'Initdeclarator'Unds'ListInitDeclarator{}(SortInitdeclarator{}, SortListInitDeclarator{}) : SortListInitDeclarator{} [functional{}(), constructor{}(), userList{}("*"), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("010"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(234,31,234,54)"), left{}(), format{}("%1 %c,%r %2"), injective{}()]
  symbol Lbl'UndsCommUndsUnds'C-SYNTAX'Unds'ParameterList'Unds'ParameterList'Unds'ParameterDeclaration{}(SortParameterList{}, SortParameterDeclaration{}) : SortParameterList{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("010"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(196,22,196,59)"), left{}(), format{}("%1 %c,%r %2"), injective{}()]
  symbol Lbl'UndsCommUndsUnds'C-SYNTAX'Unds'StructDeclaratorList'Unds'StructDeclaratorList'Unds'StructDeclarator{}(SortStructDeclaratorList{}, SortStructDeclarator{}) : SortStructDeclaratorList{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("010"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(61,30,61,70)"), left{}(), format{}("%1 %c,%r %2"), injective{}()]
  symbol Lbl'Unds'--'Unds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression{}(SortPostfixExpression{}) : SortPostfixExpression{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("01"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(147,26,147,47)"), left{}(), format{}("%1 %c--%r"), injective{}()]
  symbol Lbl'Unds'-'-GT-UndsUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression'Unds'Id{}(SortPostfixExpression{}, SortId{}) : SortPostfixExpression{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("010"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(145,26,145,50)"), left{}(), format{}("%1 %c->%r %2"), injective{}()]
  hooked-symbol Lbl'Unds'-Int'Unds'{}(SortInt{}, SortInt{}) : SortInt{} [latex{}("{#1}\\mathrel{-_{\\scriptstyle\\it Int}}{#2}"), functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(Lbl'Unds-GT--GT-'Int'Unds'{}(),Lbl'Unds'xorInt'Unds'{}(),Lbl'UndsAnd-'Int'Unds'{}(),Lbl'Unds-LT--LT-'Int'Unds'{}(),Lbl'UndsPipe'Int'Unds'{}()), smt-hook{}("-"), right{}(), terminals{}("010"), klabel{}("_-Int_"), hook{}("INT.sub"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(942,18,942,178)"), left{}(Lbl'UndsPlus'Int'Unds'{}(),Lbl'Unds'-Int'Unds'{}()), format{}("%1 %c-Int%r %2"), function{}()]
  hooked-symbol Lbl'Unds'-Map'UndsUnds'MAP'Unds'Map'Unds'Map'Unds'Map{}(SortMap{}, SortMap{}) : SortMap{} [latex{}("{#1}-_{\\it Map}{#2}"), functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("010"), hook{}("MAP.difference"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(320,18,320,120)"), left{}(), format{}("%1 %c-Map%r %2"), function{}()]
  symbol Lbl'Unds'-'UndsUnds'C-SYNTAX'Unds'AdditiveExpression'Unds'AdditiveExpression'Unds'MultiplicativeExpression{}(SortAdditiveExpression{}, SortMultiplicativeExpression{}) : SortAdditiveExpression{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("010"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(124,27,124,73)"), left{}(), format{}("%1 %c-%r %2"), injective{}()]
  symbol Lbl'UndsStopUndsUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression'Unds'Id{}(SortPostfixExpression{}, SortId{}) : SortPostfixExpression{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("010"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(144,26,144,49)"), left{}(), format{}("%1 %c.%r %2"), injective{}()]
  hooked-symbol Lbl'UndsSlsh'Int'Unds'{}(SortInt{}, SortInt{}) : SortInt{} [latex{}("{#1}\\mathrel{\\div_{\\scriptstyle\\it Int}}{#2}"), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(Lbl'UndsPlus'Int'Unds'{}(),Lbl'Unds-GT--GT-'Int'Unds'{}(),Lbl'Unds'xorInt'Unds'{}(),Lbl'UndsAnd-'Int'Unds'{}(),Lbl'Unds-LT--LT-'Int'Unds'{}(),Lbl'UndsPipe'Int'Unds'{}(),Lbl'Unds'-Int'Unds'{}()), smt-hook{}("div"), right{}(), terminals{}("010"), klabel{}("_/Int_"), hook{}("INT.tdiv"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(935,18,935,172)"), left{}(Lbl'UndsSlsh'Int'Unds'{}(),Lbl'Unds'modInt'Unds'{}(),Lbl'Unds'divInt'Unds'{}(),Lbl'UndsPerc'Int'Unds'{}(),Lbl'UndsStar'Int'Unds'{}()), format{}("%1 %c/Int%r %2"), function{}()]
  symbol Lbl'UndsSlshUndsUnds'C-SYNTAX'Unds'MultiplicativeExpression'Unds'MultiplicativeExpression'Unds'CastExpression{}(SortMultiplicativeExpression{}, SortCastExpression{}) : SortMultiplicativeExpression{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("010"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(128,33,128,75)"), left{}(), format{}("%1 %c/%r %2"), injective{}()]
  symbol Lbl'UndsColnUndsUnds'C-SYNTAX'Unds'LabeledStatement'Unds'Id'Unds'Statement{}(SortId{}, SortStatement{}) : SortLabeledStatement{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("010"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(257,29,257,44)"), left{}(), format{}("%1 %c:%r %2"), injective{}()]
  symbol Lbl'UndsColnUndsUnds'C-SYNTAX'Unds'StructDeclarator'Unds'Declarator'Unds'ConstantExpression{}(SortDeclarator{}, SortConstantExpression{}) : SortStructDeclarator{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("010"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(64,25,64,57)"), left{}(), format{}("%1 %c:%r %2"), injective{}()]
  symbol Lbl'UndsSClnUnds'C-SYNTAX'Unds'ExpressionStatement'Unds'Expression{}(SortExpression{}) : SortExpressionStatement{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("01"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(261,32,261,45)"), left{}(), format{}("%1 %c;%r"), injective{}()]
  symbol Lbl'UndsSClnUndsUnds'C-SYNTAX'Unds'ListStructDeclaration'Unds'StructDeclaration'Unds'ListStructDeclaration{}(SortStructDeclaration{}, SortListStructDeclaration{}) : SortListStructDeclaration{} [functional{}(), constructor{}(), userList{}("*"), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("010"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(47,34,47,60)"), left{}(), format{}("%1 %c;%r %2"), injective{}()]
  hooked-symbol Lbl'Unds-LT--LT-'Int'Unds'{}(SortInt{}, SortInt{}) : SortInt{} [latex{}("{#1}\\mathrel{\\ll_{\\scriptstyle\\it Int}}{#2}"), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(Lbl'Unds'xorInt'Unds'{}(),Lbl'UndsAnd-'Int'Unds'{}(),Lbl'UndsPipe'Int'Unds'{}()), right{}(), smtlib{}("shlInt"), terminals{}("010"), klabel{}("_<<Int_"), hook{}("INT.shl"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(945,18,945,172)"), left{}(Lbl'Unds-GT--GT-'Int'Unds'{}(),Lbl'Unds-LT--LT-'Int'Unds'{}()), format{}("%1 %c<<Int%r %2"), function{}()]
  symbol Lbl'Unds-LT--LT-UndsUnds'C-SYNTAX'Unds'ShiftExpression'Unds'ShiftExpression'Unds'AdditiveExpression{}(SortShiftExpression{}, SortAdditiveExpression{}) : SortShiftExpression{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("010"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(120,24,120,63)"), left{}(), format{}("%1 %c<<%r %2"), injective{}()]
  hooked-symbol Lbl'Unds-LT-Eqls'Int'Unds'{}(SortInt{}, SortInt{}) : SortBool{} [latex{}("{#1}\\mathrel{\\leq_{\\scriptstyle\\it Int}}{#2}"), functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), smt-hook{}("<="), right{}(), terminals{}("010"), klabel{}("_<=Int_"), hook{}("INT.le"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1003,19,1003,176)"), left{}(Lbl'Unds-LT-Eqls'Int'Unds'{}()), format{}("%1 %c<=Int%r %2"), function{}()]
  hooked-symbol Lbl'Unds-LT-Eqls'Map'UndsUnds'MAP'Unds'Bool'Unds'Map'Unds'Map{}(SortMap{}, SortMap{}) : SortBool{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("010"), hook{}("MAP.inclusion"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(392,19,392,91)"), left{}(), format{}("%1 %c<=Map%r %2"), function{}()]
  hooked-symbol Lbl'Unds-LT-Eqls'Set'UndsUnds'SET'Unds'Bool'Unds'Set'Unds'Set{}(SortSet{}, SortSet{}) : SortBool{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("010"), hook{}("SET.inclusion"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(592,19,592,85)"), left{}(), format{}("%1 %c<=Set%r %2"), function{}()]
  hooked-symbol Lbl'Unds-LT-Eqls'String'UndsUnds'STRING-COMMON'Unds'Bool'Unds'String'Unds'String{}(SortString{}, SortString{}) : SortBool{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("010"), hook{}("STRING.le"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1532,19,1532,82)"), left{}(), format{}("%1 %c<=String%r %2"), function{}()]
  symbol Lbl'Unds-LT-EqlsUndsUnds'C-SYNTAX'Unds'RelationalExpression'Unds'RelationalExpression'Unds'ShiftExpression{}(SortRelationalExpression{}, SortShiftExpression{}) : SortRelationalExpression{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("010"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(115,29,115,69)"), left{}(), format{}("%1 %c<=%r %2"), injective{}()]
  hooked-symbol Lbl'Unds-LT-'Int'Unds'{}(SortInt{}, SortInt{}) : SortBool{} [latex{}("{#1}\\mathrel{<_{\\scriptstyle\\it Int}}{#2}"), functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), smt-hook{}("<"), right{}(), terminals{}("010"), klabel{}("_<Int_"), hook{}("INT.lt"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1004,19,1004,171)"), left{}(Lbl'Unds-LT-'Int'Unds'{}()), format{}("%1 %c<Int%r %2"), function{}()]
  hooked-symbol Lbl'Unds-LT-'String'UndsUnds'STRING-COMMON'Unds'Bool'Unds'String'Unds'String{}(SortString{}, SortString{}) : SortBool{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("010"), hook{}("STRING.lt"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1531,19,1531,82)"), left{}(), format{}("%1 %c<String%r %2"), function{}()]
  symbol Lbl'Unds-LT-UndsUnds'C-SYNTAX'Unds'RelationalExpression'Unds'RelationalExpression'Unds'ShiftExpression{}(SortRelationalExpression{}, SortShiftExpression{}) : SortRelationalExpression{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("010"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(113,29,113,69)"), left{}(), format{}("%1 %c<%r %2"), injective{}()]
  hooked-symbol Lbl'UndsEqlsSlshEqls'Bool'Unds'{}(SortBool{}, SortBool{}) : SortBool{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), smt-hook{}("distinct"), right{}(), terminals{}("010"), klabel{}("_=/=Bool_"), hook{}("BOOL.ne"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(827,19,827,132)"), left{}(Lbl'UndsEqlsEqls'Bool'Unds'{}(),Lbl'UndsEqlsSlshEqls'Bool'Unds'{}()), format{}("%1 %c=/=Bool%r %2"), function{}()]
  hooked-symbol Lbl'UndsEqlsSlshEqls'Int'Unds'{}(SortInt{}, SortInt{}) : SortBool{} [latex{}("{#1}\\mathrel{{=}{/}{=}_{\\scriptstyle\\it Int}}{#2}"), functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), smt-hook{}("distinct"), right{}(), terminals{}("010"), klabel{}("_=/=Int_"), hook{}("INT.ne"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1008,19,1008,188)"), left{}(Lbl'UndsEqlsSlshEqls'Int'Unds'{}()), format{}("%1 %c=/=Int%r %2"), function{}()]
  hooked-symbol Lbl'UndsEqlsSlshEqls'K'Unds'{}(SortK{}, SortK{}) : SortBool{} [latex{}("{#1}\\mathrel{\\neq_K}{#2}"), functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), notEqualEqualK{}(), priorities{}(Lbl'Unds'orElseBool'Unds'{}(),Lbl'Unds'orBool'Unds'{}(),Lbl'UndsEqlsSlshEqls'Bool'Unds'{}(),Lbl'Unds'andThenBool'Unds'{}(),Lbl'Unds'impliesBool'Unds'{}(),Lbl'UndsEqlsEqls'Bool'Unds'{}(),Lbl'Unds'andBool'Unds'{}(),LblnotBool'Unds'{}(),Lbl'Unds'xorBool'Unds'{}()), smt-hook{}("distinct"), right{}(), terminals{}("010"), klabel{}("_=/=K_"), hook{}("KEQUAL.ne"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2022,19,2022,170)"), left{}(Lbl'UndsEqlsEqls'K'Unds'{}(),Lbl'UndsEqlsSlshEqls'K'Unds'{}()), format{}("%1 %c=/=K%r %2"), function{}()]
  hooked-symbol Lbl'UndsEqlsSlshEqls'String'UndsUnds'STRING-COMMON'Unds'Bool'Unds'String'Unds'String{}(SortString{}, SortString{}) : SortBool{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("010"), hook{}("STRING.ne"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1528,19,1528,94)"), left{}(Lbl'UndsEqlsSlshEqls'String'UndsUnds'STRING-COMMON'Unds'Bool'Unds'String'Unds'String{}()), format{}("%1 %c=/=String%r %2"), function{}()]
  hooked-symbol Lbl'UndsEqlsEqls'Bool'Unds'{}(SortBool{}, SortBool{}) : SortBool{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), smt-hook{}("="), right{}(), terminals{}("010"), klabel{}("_==Bool_"), hook{}("BOOL.eq"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(826,19,826,124)"), left{}(Lbl'UndsEqlsSlshEqls'Bool'Unds'{}(),Lbl'UndsEqlsEqls'Bool'Unds'{}()), format{}("%1 %c==Bool%r %2"), function{}()]
  hooked-symbol Lbl'UndsEqlsEqls'Int'Unds'{}(SortInt{}, SortInt{}) : SortBool{} [latex{}("{#1}\\mathrel{{=}{=}_{\\scriptstyle\\it Int}}{#2}"), functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), smt-hook{}("="), right{}(), terminals{}("010"), klabel{}("_==Int_"), hook{}("INT.eq"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1007,19,1007,177)"), left{}(Lbl'UndsEqlsEqls'Int'Unds'{}()), format{}("%1 %c==Int%r %2"), function{}()]
  hooked-symbol Lbl'UndsEqlsEqls'K'Unds'{}(SortK{}, SortK{}) : SortBool{} [latex{}("{#1}\\mathrel{=_K}{#2}"), functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(Lbl'Unds'orElseBool'Unds'{}(),Lbl'Unds'orBool'Unds'{}(),Lbl'UndsEqlsSlshEqls'Bool'Unds'{}(),Lbl'Unds'andThenBool'Unds'{}(),Lbl'Unds'impliesBool'Unds'{}(),Lbl'UndsEqlsEqls'Bool'Unds'{}(),Lbl'Unds'andBool'Unds'{}(),LblnotBool'Unds'{}(),Lbl'Unds'xorBool'Unds'{}()), smt-hook{}("="), right{}(), terminals{}("010"), equalEqualK{}(), klabel{}("_==K_"), hook{}("KEQUAL.eq"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2021,19,2021,156)"), left{}(Lbl'UndsEqlsSlshEqls'K'Unds'{}(),Lbl'UndsEqlsEqls'K'Unds'{}()), format{}("%1 %c==K%r %2"), function{}()]
  hooked-symbol Lbl'UndsEqlsEqls'String'UndsUnds'STRING-COMMON'Unds'Bool'Unds'String'Unds'String{}(SortString{}, SortString{}) : SortBool{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("010"), hook{}("STRING.eq"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1527,19,1527,88)"), left{}(Lbl'UndsEqlsEqls'String'UndsUnds'STRING-COMMON'Unds'Bool'Unds'String'Unds'String{}()), format{}("%1 %c==String%r %2"), function{}()]
  symbol Lbl'UndsEqlsEqlsUndsUnds'C-SYNTAX'Unds'EqualityExpression'Unds'EqualityExpression'Unds'RelationalExpression{}(SortEqualityExpression{}, SortRelationalExpression{}) : SortEqualityExpression{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("010"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(109,27,109,70)"), left{}(), format{}("%1 %c==%r %2"), injective{}()]
  symbol Lbl'UndsEqlsUndsUnds'C-SYNTAX'Unds'Enumerator'Unds'Id'Unds'Int{}(SortId{}, SortInt{}) : SortEnumerator{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("010"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(228,24,228,33)"), left{}(), format{}("%1 %c=%r %2"), injective{}()]
  symbol Lbl'UndsEqlsUndsUnds'C-SYNTAX'Unds'Initdeclarator'Unds'Declarator'Unds'Initializer{}(SortDeclarator{}, SortInitializer{}) : SortInitdeclarator{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("010"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(237,23,237,48)"), left{}(), format{}("%1 %c=%r %2"), injective{}()]
  hooked-symbol Lbl'Unds-GT-Eqls'Int'Unds'{}(SortInt{}, SortInt{}) : SortBool{} [latex{}("{#1}\\mathrel{\\geq_{\\scriptstyle\\it Int}}{#2}"), functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), smt-hook{}(">="), right{}(), terminals{}("010"), klabel{}("_>=Int_"), hook{}("INT.ge"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1005,19,1005,176)"), left{}(Lbl'Unds-GT-Eqls'Int'Unds'{}()), format{}("%1 %c>=Int%r %2"), function{}()]
  hooked-symbol Lbl'Unds-GT-Eqls'String'UndsUnds'STRING-COMMON'Unds'Bool'Unds'String'Unds'String{}(SortString{}, SortString{}) : SortBool{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("010"), hook{}("STRING.ge"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1534,19,1534,82)"), left{}(), format{}("%1 %c>=String%r %2"), function{}()]
  symbol Lbl'Unds-GT-EqlsUndsUnds'C-SYNTAX'Unds'RelationalExpression'Unds'RelationalExpression'Unds'ShiftExpression{}(SortRelationalExpression{}, SortShiftExpression{}) : SortRelationalExpression{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("010"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(116,29,116,69)"), left{}(), format{}("%1 %c>=%r %2"), injective{}()]
  hooked-symbol Lbl'Unds-GT--GT-'Int'Unds'{}(SortInt{}, SortInt{}) : SortInt{} [latex{}("{#1}\\mathrel{\\gg_{\\scriptstyle\\it Int}}{#2}"), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(Lbl'Unds'xorInt'Unds'{}(),Lbl'UndsAnd-'Int'Unds'{}(),Lbl'UndsPipe'Int'Unds'{}()), right{}(), smtlib{}("shrInt"), terminals{}("010"), klabel{}("_>>Int_"), hook{}("INT.shr"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(944,18,944,172)"), left{}(Lbl'Unds-LT--LT-'Int'Unds'{}(),Lbl'Unds-GT--GT-'Int'Unds'{}()), format{}("%1 %c>>Int%r %2"), function{}()]
  symbol Lbl'Unds-GT--GT-UndsUnds'C-SYNTAX'Unds'ShiftExpression'Unds'ShiftExpression'Unds'AdditiveExpression{}(SortShiftExpression{}, SortAdditiveExpression{}) : SortShiftExpression{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("010"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(119,24,119,62)"), left{}(), format{}("%1 %c>>%r %2"), injective{}()]
  hooked-symbol Lbl'Unds-GT-'Int'Unds'{}(SortInt{}, SortInt{}) : SortBool{} [latex{}("{#1}\\mathrel{>_{\\scriptstyle\\it Int}}{#2}"), functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), smt-hook{}(">"), right{}(), terminals{}("010"), klabel{}("_>Int_"), hook{}("INT.gt"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1006,19,1006,171)"), left{}(Lbl'Unds-GT-'Int'Unds'{}()), format{}("%1 %c>Int%r %2"), function{}()]
  hooked-symbol Lbl'Unds-GT-'String'UndsUnds'STRING-COMMON'Unds'Bool'Unds'String'Unds'String{}(SortString{}, SortString{}) : SortBool{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("010"), hook{}("STRING.gt"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1533,19,1533,82)"), left{}(), format{}("%1 %c>String%r %2"), function{}()]
  symbol Lbl'Unds-GT-UndsUnds'C-SYNTAX'Unds'RelationalExpression'Unds'RelationalExpression'Unds'ShiftExpression{}(SortRelationalExpression{}, SortShiftExpression{}) : SortRelationalExpression{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("010"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(114,29,114,69)"), left{}(), format{}("%1 %c>%r %2"), injective{}()]
  symbol Lbl'UndsQuesUndsColnUndsUnds'C-SYNTAX'Unds'ConditionalExpression'Unds'LogicalOforExpression'Unds'Expression'Unds'ConditionalExpression{}(SortLogicalOforExpression{}, SortExpression{}, SortConditionalExpression{}) : SortConditionalExpression{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("01010"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(91,30,91,91)"), left{}(), format{}("%1 %c?%r %2 %c:%r %3"), injective{}()]
  hooked-symbol Lbl'Unds'List'Unds'{}(SortList{}, SortList{}) : SortList{} [unit{}(Lbl'Stop'List{}()), functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), element{}(LblListItem{}()), symbol'Kywd'{}(), priorities{}(), right{}(), assoc{}(), smtlib{}("smt_seq_concat"), terminals{}("00"), klabel{}("_List_"), hook{}("LIST.concat"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(647,19,647,192)"), left{}(Lbl'Unds'List'Unds'{}()), format{}("%1%n%2"), function{}()]
  hooked-symbol Lbl'Unds'Map'Unds'{}(SortMap{}, SortMap{}) : SortMap{} [unit{}(Lbl'Stop'Map{}()), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), element{}(Lbl'UndsPipe'-'-GT-Unds'{}()), symbol'Kywd'{}(), comm{}(), priorities{}(), right{}(), assoc{}(), terminals{}("00"), index{}("0"), klabel{}("_Map_"), hook{}("MAP.concat"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(249,18,249,172)"), left{}(Lbl'Unds'Map'Unds'{}()), format{}("%1%n%2"), function{}()]
  hooked-symbol Lbl'Unds'Set'Unds'{}(SortSet{}, SortSet{}) : SortSet{} [unit{}(Lbl'Stop'Set{}()), functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), element{}(LblSetItem{}()), symbol'Kywd'{}(), idem{}(), comm{}(), priorities{}(), right{}(), assoc{}(), terminals{}("00"), klabel{}("_Set_"), hook{}("SET.concat"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(527,18,527,176)"), left{}(Lbl'Unds'Set'Unds'{}()), format{}("%1%n%2"), function{}()]
  symbol Lbl'UndsLSqBRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator{}(SortDirectAbstractDeclarator{}) : SortDirectAbstractDeclarator{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("011"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(210,34,210,65)"), left{}(), format{}("%1 %c[%r %c]%r"), injective{}()]
  symbol Lbl'UndsLSqBRSqBUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'DirectDeclarator{}(SortDirectDeclarator{}) : SortDirectDeclarator{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("011"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(82,25,82,48)"), left{}(), format{}("%1 %c[%r %c]%r"), injective{}()]
  hooked-symbol Lbl'UndsLSqBUnds-LT-'-'UndsRSqBUnds'LIST'Unds'List'Unds'List'Unds'Int'Unds'KItem{}(SortList{}, SortInt{}, SortKItem{}) : SortList{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("010101"), klabel{}("List:set"), hook{}("LIST.update"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(683,19,683,107)"), left{}(), format{}("%1 %c[%r %2 %c<-%r %3 %c]%r"), function{}()]
  hooked-symbol Lbl'UndsLSqBUnds-LT-'-undef'RSqB'{}(SortMap{}, SortKItem{}) : SortMap{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("010111"), klabel{}("_[_<-undef]"), hook{}("MAP.remove"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(308,18,308,121)"), left{}(), format{}("%1 %c[%r %2 %c<-%r %cundef%r %c]%r"), function{}()]
  symbol Lbl'UndsLSqBUndsRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator'Unds'ConstantExpression{}(SortDirectAbstractDeclarator{}, SortConstantExpression{}) : SortDirectAbstractDeclarator{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("0101"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(209,34,209,84)"), left{}(), format{}("%1 %c[%r %2 %c]%r"), injective{}()]
  symbol Lbl'UndsLSqBUndsRSqBUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'DirectDeclarator'Unds'ConstantExpression{}(SortDirectDeclarator{}, SortConstantExpression{}) : SortDirectDeclarator{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("0101"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(81,25,81,67)"), left{}(), format{}("%1 %c[%r %2 %c]%r"), injective{}()]
  symbol Lbl'UndsLSqBUndsRSqBUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression'Unds'Expression{}(SortPostfixExpression{}, SortExpression{}) : SortPostfixExpression{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("0101"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(142,26,142,61)"), left{}(), format{}("%1 %c[%r %2 %c]%r"), injective{}()]
  hooked-symbol Lbl'UndsLSqBUndsRSqB'orDefault'UndsUnds'MAP'Unds'KItem'Unds'Map'Unds'KItem'Unds'KItem{}(SortMap{}, SortKItem{}, SortKItem{}) : SortKItem{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("010110"), klabel{}("Map:lookupOrDefault"), hook{}("MAP.lookupOrDefault"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(290,20,290,138)"), left{}(), format{}("%1 %c[%r %2 %c]%r %corDefault%r %3"), function{}()]
  hooked-symbol Lbl'UndsXor-Perc'Int'UndsUnds'{}(SortInt{}, SortInt{}, SortInt{}) : SortInt{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(Lbl'UndsPlus'Int'Unds'{}(),Lbl'Unds'divInt'Unds'{}(),Lbl'UndsPerc'Int'Unds'{}(),Lbl'Unds-GT--GT-'Int'Unds'{}(),Lbl'Unds'xorInt'Unds'{}(),Lbl'UndsSlsh'Int'Unds'{}(),Lbl'UndsAnd-'Int'Unds'{}(),Lbl'Unds-LT--LT-'Int'Unds'{}(),Lbl'UndsStar'Int'Unds'{}(),Lbl'UndsPipe'Int'Unds'{}(),Lbl'Unds'modInt'Unds'{}(),Lbl'Unds'-Int'Unds'{}()), smt-hook{}("(mod (^ #1 #2) #3)"), right{}(), terminals{}("0100"), klabel{}("_^%Int__"), hook{}("INT.powmod"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(930,18,930,138)"), left{}(Lbl'UndsXor-Perc'Int'UndsUnds'{}(),Lbl'UndsXor-'Int'Unds'{}()), format{}("%1 %c^%%Int%r %2 %3"), function{}()]
  hooked-symbol Lbl'UndsXor-'Int'Unds'{}(SortInt{}, SortInt{}) : SortInt{} [latex{}("{#1}\\mathrel{{\\char`\\^}_{\\!\\scriptstyle\\it Int}}{#2}"), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(Lbl'UndsPlus'Int'Unds'{}(),Lbl'Unds'divInt'Unds'{}(),Lbl'UndsPerc'Int'Unds'{}(),Lbl'Unds-GT--GT-'Int'Unds'{}(),Lbl'Unds'xorInt'Unds'{}(),Lbl'UndsSlsh'Int'Unds'{}(),Lbl'UndsAnd-'Int'Unds'{}(),Lbl'Unds-LT--LT-'Int'Unds'{}(),Lbl'UndsStar'Int'Unds'{}(),Lbl'UndsPipe'Int'Unds'{}(),Lbl'Unds'modInt'Unds'{}(),Lbl'Unds'-Int'Unds'{}()), smt-hook{}("^"), right{}(), terminals{}("010"), klabel{}("_^Int_"), hook{}("INT.pow"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(929,18,929,177)"), left{}(Lbl'UndsXor-'Int'Unds'{}(),Lbl'UndsXor-Perc'Int'UndsUnds'{}()), format{}("%1 %c^Int%r %2"), function{}()]
  symbol Lbl'UndsXor-UndsUnds'C-SYNTAX'Unds'ExclusiveOforExpression'Unds'ExclusiveOforExpression'Unds'AndExpression{}(SortExclusiveOforExpression{}, SortAndExpression{}) : SortExclusiveOforExpression{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("010"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(103,31,103,71)"), left{}(), format{}("%1 %c^%r %2"), injective{}()]
  symbol Lbl'UndsUndsSClnUnds'C-SYNTAX'Unds'Declaration'Unds'ListDeclarationSpecifier'Unds'ListInitDeclarator{}(SortListDeclarationSpecifier{}, SortListInitDeclarator{}) : SortDeclaration{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("001"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(232,24,232,70)"), left{}(), format{}("%1 %2 %c;%r"), injective{}()]
  symbol Lbl'UndsUndsUnds'C-SYNTAX'Unds'AbstractDeclarator'Unds'Pointer'Unds'DirectAbstractDeclarator{}(SortPointer{}, SortDirectAbstractDeclarator{}) : SortAbstractDeclarator{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("00"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(205,27,205,58)"), left{}(), format{}("%1 %2"), injective{}()]
  symbol Lbl'UndsUndsUnds'C-SYNTAX'Unds'Declarator'Unds'Pointer'Unds'DirectDeclarator{}(SortPointer{}, SortDirectDeclarator{}) : SortDeclarator{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("00"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(68,23,68,46)"), left{}(), format{}("%1 %2"), injective{}()]
  symbol Lbl'UndsUndsUnds'C-SYNTAX'Unds'Ids'Unds'Id'Unds'Ids{}(SortId{}, SortIds{}) : SortIds{} [functional{}(), constructor{}(), userList{}("*"), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("010"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(86,16,86,26)"), left{}(), format{}("%1 %c%r %2"), injective{}()]
  symbol Lbl'UndsUndsUnds'C-SYNTAX'Unds'ListDeclarationSpecifier'Unds'DeclarationSpecifier'Unds'ListDeclarationSpecifier{}(SortDeclarationSpecifier{}, SortListDeclarationSpecifier{}) : SortListDeclarationSpecifier{} [functional{}(), constructor{}(), userList{}("+"), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("010"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(202,37,202,67)"), left{}(), format{}("%1 %c%r %2"), injective{}()]
  symbol Lbl'UndsUndsUnds'C-SYNTAX'Unds'ListDeclaration'Unds'Declaration'Unds'ListDeclaration{}(SortDeclaration{}, SortListDeclaration{}) : SortListDeclaration{} [functional{}(), constructor{}(), userList{}("*"), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("010"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(16,28,16,47)"), left{}(), format{}("%1 %c%r %2"), injective{}()]
  symbol Lbl'UndsUndsUnds'C-SYNTAX'Unds'ListExternalDeclaration'Unds'ExternalDeclaration'Unds'ListExternalDeclaration{}(SortExternalDeclaration{}, SortListExternalDeclaration{}) : SortListExternalDeclaration{} [functional{}(), constructor{}(), userList{}("*"), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("010"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(9,36,9,63)"), left{}(), format{}("%1 %c%r %2"), injective{}()]
  symbol Lbl'UndsUndsUnds'C-SYNTAX'Unds'ListSpecifierQualifier'Unds'SpecifierQualifier'Unds'ListSpecifierQualifier{}(SortSpecifierQualifier{}, SortListSpecifierQualifier{}) : SortListSpecifierQualifier{} [functional{}(), constructor{}(), userList{}("*"), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("010"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(54,35,54,61)"), left{}(), format{}("%1 %c%r %2"), injective{}()]
  symbol Lbl'UndsUndsUnds'C-SYNTAX'Unds'ListStatement'Unds'Statement'Unds'ListStatement{}(SortStatement{}, SortListStatement{}) : SortListStatement{} [functional{}(), constructor{}(), userList{}("*"), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("010"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(248,26,248,43)"), left{}(), format{}("%1 %c%r %2"), injective{}()]
  symbol Lbl'UndsUndsUnds'C-SYNTAX'Unds'ListTypeQualifier'Unds'TypeQualifier'Unds'ListTypeQualifier{}(SortTypeQualifier{}, SortListTypeQualifier{}) : SortListTypeQualifier{} [functional{}(), constructor{}(), userList{}("*"), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("010"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(73,30,73,51)"), left{}(), format{}("%1 %c%r %2"), injective{}()]
  symbol Lbl'UndsUndsUnds'C-SYNTAX'Unds'ParameterDeclaration'Unds'ListDeclarationSpecifier'Unds'AbstractDeclarator{}(SortListDeclarationSpecifier{}, SortAbstractDeclarator{}) : SortParameterDeclaration{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("00"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(199,29,199,71)"), left{}(), format{}("%1 %2"), injective{}()]
  symbol Lbl'UndsUndsUnds'C-SYNTAX'Unds'ParameterDeclaration'Unds'ListDeclarationSpecifier'Unds'Declarator{}(SortListDeclarationSpecifier{}, SortDeclarator{}) : SortParameterDeclaration{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("00"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(198,33,198,67)"), left{}(), format{}("%1 %2"), injective{}()]
  symbol Lbl'UndsUndsUnds'C-SYNTAX'Unds'StructDeclaration'Unds'ListSpecifierQualifier'Unds'StructDeclaratorList{}(SortListSpecifierQualifier{}, SortStructDeclaratorList{}) : SortStructDeclaration{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("00"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(52,30,52,72)"), left{}(), format{}("%1 %2"), injective{}()]
  symbol Lbl'UndsUndsUnds'C-SYNTAX'Unds'StructOrFunionSpecifier'Unds'StructOrUnion'Unds'Id{}(SortStructOrUnion{}, SortId{}) : SortStructOrFunionSpecifier{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(Lbl'UndsUndsLBraRBraUnds'C-SYNTAX'Unds'StructOrFunionSpecifier'Unds'StructOrUnion'Unds'Id{}()), right{}(), terminals{}("00"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(44,33,44,48)"), left{}(), format{}("%1 %2"), injective{}()]
  symbol Lbl'UndsUndsUnds'C-SYNTAX'Unds'TypeName'Unds'ListSpecifierQualifier'Unds'AbstractDeclarator{}(SortListSpecifierQualifier{}, SortAbstractDeclarator{}) : SortTypeName{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("00"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(187,21,187,61)"), left{}(), format{}("%1 %2"), injective{}()]
  symbol Lbl'UndsUndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'UnaryOperator'Unds'CastExpression{}(SortUnaryOperator{}, SortCastExpression{}) : SortUnaryExpression{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("00"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(137,24,137,51)"), left{}(), format{}("%1 %2"), injective{}()]
  symbol Lbl'UndsUndsUndsUnds'C-SYNTAX'Unds'AssignmentExpression'Unds'UnaryExpression'Unds'AssignmentOperator'Unds'AssignmentExpression{}(SortUnaryExpression{}, SortAssignmentOperator{}, SortAssignmentExpression{}) : SortAssignmentExpression{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("000"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(166,29,166,83)"), left{}(), format{}("%1 %2 %3"), injective{}()]
  symbol Lbl'UndsUndsUndsUndsUnds'C-SYNTAX'Unds'FunctionDefinition'Unds'ListDeclarationSpecifier'Unds'Declarator'Unds'ListDeclaration'Unds'CompoundStatement{}(SortListDeclarationSpecifier{}, SortDeclarator{}, SortListDeclaration{}, SortCompoundStatement{}) : SortFunctionDefinition{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("0000"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(14,31,14,99)"), left{}(), format{}("%1 %2 %3 %4"), injective{}()]
  symbol Lbl'UndsUndsLBraUndsSClnRBraUnds'C-SYNTAX'Unds'StructOrFunionSpecifier'Unds'StructOrUnion'Unds'Id'Unds'ListStructDeclaration{}(SortStructOrUnion{}, SortId{}, SortListStructDeclaration{}) : SortStructOrFunionSpecifier{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(Lbl'UndsUndsUnds'C-SYNTAX'Unds'StructOrFunionSpecifier'Unds'StructOrUnion'Unds'Id{}(),Lbl'UndsUndsLBraRBraUnds'C-SYNTAX'Unds'StructOrFunionSpecifier'Unds'StructOrUnion'Unds'Id{}()), right{}(), terminals{}("001011"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(42,36,42,85)"), left{}(), format{}("%1 %2 %c{%r %3 %c;%r %c}%r"), injective{}()]
  symbol Lbl'UndsUndsLBraRBraUnds'C-SYNTAX'Unds'StructOrFunionSpecifier'Unds'StructOrUnion'Unds'Id{}(SortStructOrUnion{}, SortId{}) : SortStructOrFunionSpecifier{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("0011"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(45,33,45,56)"), left{}(), format{}("%1 %2 %c{%r %c}%r"), injective{}()]
  hooked-symbol Lbl'Unds'andBool'Unds'{}(SortBool{}, SortBool{}) : SortBool{} [latex{}("{#1}\\wedge_{\\scriptstyle\\it Bool}{#2}"), functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(Lbl'UndsEqlsSlshEqls'Bool'Unds'{}(),Lbl'UndsEqlsEqls'Bool'Unds'{}()), smt-hook{}("and"), boolOperation{}(), right{}(), terminals{}("010"), klabel{}("_andBool_"), hook{}("BOOL.and"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(819,19,819,189)"), left{}(Lbl'Unds'andBool'Unds'{}()), format{}("%1 %candBool%r %2"), function{}()]
  hooked-symbol Lbl'Unds'andThenBool'Unds'{}(SortBool{}, SortBool{}) : SortBool{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(Lbl'UndsEqlsSlshEqls'Bool'Unds'{}(),Lbl'UndsEqlsEqls'Bool'Unds'{}()), smt-hook{}("and"), boolOperation{}(), right{}(), terminals{}("010"), klabel{}("_andThenBool_"), hook{}("BOOL.andThen"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(820,19,820,151)"), left{}(Lbl'Unds'andThenBool'Unds'{}()), format{}("%1 %candThenBool%r %2"), function{}()]
  hooked-symbol Lbl'Unds'divInt'Unds'{}(SortInt{}, SortInt{}) : SortInt{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(Lbl'UndsPlus'Int'Unds'{}(),Lbl'Unds-GT--GT-'Int'Unds'{}(),Lbl'Unds'xorInt'Unds'{}(),Lbl'UndsAnd-'Int'Unds'{}(),Lbl'Unds-LT--LT-'Int'Unds'{}(),Lbl'UndsPipe'Int'Unds'{}(),Lbl'Unds'-Int'Unds'{}()), smt-hook{}("div"), right{}(), terminals{}("010"), klabel{}("_divInt_"), hook{}("INT.ediv"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(938,18,938,121)"), left{}(Lbl'UndsSlsh'Int'Unds'{}(),Lbl'Unds'modInt'Unds'{}(),Lbl'UndsStar'Int'Unds'{}(),Lbl'UndsPerc'Int'Unds'{}(),Lbl'Unds'divInt'Unds'{}()), format{}("%1 %cdivInt%r %2"), function{}()]
  symbol Lbl'Unds'dividesInt'UndsUnds'INT-COMMON'Unds'Bool'Unds'Int'Unds'Int{}(SortInt{}, SortInt{}) : SortBool{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("010"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1017,19,1017,52)"), left{}(), format{}("%1 %cdividesInt%r %2"), function{}()]
  hooked-symbol Lbl'Unds'impliesBool'Unds'{}(SortBool{}, SortBool{}) : SortBool{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(Lbl'UndsEqlsSlshEqls'Bool'Unds'{}(),Lbl'UndsEqlsEqls'Bool'Unds'{}()), smt-hook{}("=>"), boolOperation{}(), right{}(), terminals{}("010"), klabel{}("_impliesBool_"), hook{}("BOOL.implies"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(824,19,824,150)"), left{}(Lbl'Unds'impliesBool'Unds'{}()), format{}("%1 %cimpliesBool%r %2"), function{}()]
  hooked-symbol Lbl'Unds'in'UndsUnds'LIST'Unds'Bool'Unds'KItem'Unds'List{}(SortKItem{}, SortList{}) : SortBool{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("010"), klabel{}("_inList_"), hook{}("LIST.in"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(730,19,730,101)"), left{}(), format{}("%1 %cin%r %2"), function{}()]
  hooked-symbol Lbl'Unds'in'Unds'keys'LParUndsRParUnds'MAP'Unds'Bool'Unds'KItem'Unds'Map{}(SortKItem{}, SortMap{}) : SortBool{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("01101"), hook{}("MAP.in_keys"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(366,19,366,93)"), left{}(), format{}("%1 %cin_keys%r %c(%r %2 %c)%r"), function{}()]
  hooked-symbol Lbl'Unds'modInt'Unds'{}(SortInt{}, SortInt{}) : SortInt{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(Lbl'UndsPlus'Int'Unds'{}(),Lbl'Unds-GT--GT-'Int'Unds'{}(),Lbl'Unds'xorInt'Unds'{}(),Lbl'UndsAnd-'Int'Unds'{}(),Lbl'Unds-LT--LT-'Int'Unds'{}(),Lbl'UndsPipe'Int'Unds'{}(),Lbl'Unds'-Int'Unds'{}()), smt-hook{}("mod"), right{}(), terminals{}("010"), klabel{}("_modInt_"), hook{}("INT.emod"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(939,18,939,121)"), left{}(Lbl'UndsStar'Int'Unds'{}(),Lbl'UndsPerc'Int'Unds'{}(),Lbl'Unds'divInt'Unds'{}(),Lbl'UndsSlsh'Int'Unds'{}(),Lbl'Unds'modInt'Unds'{}()), format{}("%1 %cmodInt%r %2"), function{}()]
  hooked-symbol Lbl'Unds'orBool'Unds'{}(SortBool{}, SortBool{}) : SortBool{} [latex{}("{#1}\\vee_{\\scriptstyle\\it Bool}{#2}"), functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(Lbl'UndsEqlsSlshEqls'Bool'Unds'{}(),Lbl'UndsEqlsEqls'Bool'Unds'{}()), smt-hook{}("or"), boolOperation{}(), right{}(), terminals{}("010"), klabel{}("_orBool_"), hook{}("BOOL.or"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(822,19,822,184)"), left{}(Lbl'Unds'orBool'Unds'{}()), format{}("%1 %corBool%r %2"), function{}()]
  hooked-symbol Lbl'Unds'orElseBool'Unds'{}(SortBool{}, SortBool{}) : SortBool{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(Lbl'UndsEqlsSlshEqls'Bool'Unds'{}(),Lbl'UndsEqlsEqls'Bool'Unds'{}()), smt-hook{}("or"), boolOperation{}(), right{}(), terminals{}("010"), klabel{}("_orElseBool_"), hook{}("BOOL.orElse"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(823,19,823,148)"), left{}(Lbl'Unds'orElseBool'Unds'{}()), format{}("%1 %corElseBool%r %2"), function{}()]
  hooked-symbol Lbl'Unds'xorBool'Unds'{}(SortBool{}, SortBool{}) : SortBool{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(Lbl'UndsEqlsSlshEqls'Bool'Unds'{}(),Lbl'UndsEqlsEqls'Bool'Unds'{}()), smt-hook{}("xor"), boolOperation{}(), right{}(), terminals{}("010"), klabel{}("_xorBool_"), hook{}("BOOL.xor"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(821,19,821,143)"), left{}(Lbl'Unds'xorBool'Unds'{}()), format{}("%1 %cxorBool%r %2"), function{}()]
  hooked-symbol Lbl'Unds'xorInt'Unds'{}(SortInt{}, SortInt{}) : SortInt{} [latex{}("{#1}\\mathrel{\\oplus_{\\scriptstyle\\it Int}}{#2}"), functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(Lbl'UndsPipe'Int'Unds'{}()), right{}(), smtlib{}("xorInt"), terminals{}("010"), klabel{}("_xorInt_"), hook{}("INT.xor"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(949,18,949,188)"), left{}(Lbl'Unds'xorInt'Unds'{}()), format{}("%1 %cxorInt%r %2"), function{}()]
  symbol Lbl'UndsLBraUndsSClnRBraUnds'C-SYNTAX'Unds'StructOrFunionSpecifier'Unds'StructOrUnion'Unds'ListStructDeclaration{}(SortStructOrUnion{}, SortListStructDeclaration{}) : SortStructOrFunionSpecifier{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(Lbl'UndsUndsUnds'C-SYNTAX'Unds'StructOrFunionSpecifier'Unds'StructOrUnion'Unds'Id{}(),Lbl'UndsUndsLBraRBraUnds'C-SYNTAX'Unds'StructOrFunionSpecifier'Unds'StructOrUnion'Unds'Id{}()), right{}(), terminals{}("01011"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(43,33,43,79)"), left{}(), format{}("%1 %c{%r %2 %c;%r %c}%r"), injective{}()]
  hooked-symbol Lbl'UndsPipe'-'-GT-Unds'{}(SortKItem{}, SortKItem{}) : SortMap{} [latex{}("{#1}\\mapsto{#2}"), functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(Lbl'Stop'Map{}(),Lbl'Unds'Map'Unds'{}()), right{}(Lbl'UndsPipe'-'-GT-Unds'{}()), terminals{}("010"), klabel{}("_|->_"), hook{}("MAP.element"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(266,18,266,144)"), left{}(Lbl'UndsPipe'-'-GT-Unds'{}()), format{}("%1 %c|->%r %2"), function{}()]
  hooked-symbol Lbl'UndsPipe'Int'Unds'{}(SortInt{}, SortInt{}) : SortInt{} [latex{}("{#1}\\mathrel{|_{\\scriptstyle\\it Int}}{#2}"), functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(), right{}(), smtlib{}("orInt"), terminals{}("010"), klabel{}("_|Int_"), hook{}("INT.or"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(951,18,951,179)"), left{}(Lbl'UndsPipe'Int'Unds'{}()), format{}("%1 %c|Int%r %2"), function{}()]
  hooked-symbol Lbl'UndsPipe'Set'UndsUnds'SET'Unds'Set'Unds'Set'Unds'Set{}(SortSet{}, SortSet{}) : SortSet{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("010"), hook{}("SET.union"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(554,18,554,88)"), left{}(Lbl'UndsPipe'Set'UndsUnds'SET'Unds'Set'Unds'Set'Unds'Set{}()), format{}("%1 %c|Set%r %2"), function{}()]
  symbol Lbl'UndsPipeUndsUnds'C-SYNTAX'Unds'InclusiveOforExpression'Unds'InclusiveOforExpression'Unds'ExclusiveOforExpression{}(SortInclusiveOforExpression{}, SortExclusiveOforExpression{}) : SortInclusiveOforExpression{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("010"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(100,31,100,81)"), left{}(), format{}("%1 %c|%r %2"), injective{}()]
  symbol Lbl'UndsPipePipeUndsUnds'C-SYNTAX'Unds'LogicalOforExpression'Unds'LogicalOforExpression'Unds'LogicalOfandExpression{}(SortLogicalOforExpression{}, SortLogicalOfandExpression{}) : SortLogicalOforExpression{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("010"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(94,29,94,77)"), left{}(), format{}("%1 %c||%r %2"), injective{}()]
  hooked-symbol LblabsInt'LParUndsRParUnds'INT-COMMON'Unds'Int'Unds'Int{}(SortInt{}) : SortInt{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), smt-hook{}("(ite (< #1 0) (- 0 #1) #1)"), right{}(), terminals{}("1101"), klabel{}("absInt"), hook{}("INT.abs"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(968,18,968,123)"), left{}(), format{}("%cabsInt%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblauto'Unds'C-SYNTAX'Unds'StorageClassSpecifier{}() : SortStorageClassSpecifier{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(23,34,23,39)"), left{}(), format{}("%cauto%r"), injective{}()]
  hooked-symbol LblbitRangeInt'LParUndsCommUndsCommUndsRParUnds'INT-COMMON'Unds'Int'Unds'Int'Unds'Int'Unds'Int{}(SortInt{}, SortInt{}, SortInt{}) : SortInt{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("11010101"), klabel{}("bitRangeInt"), hook{}("INT.bitRange"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(993,18,993,102)"), left{}(), format{}("%cbitRangeInt%r %c(%r %1 %c,%r %2 %c,%r %3 %c)%r"), function{}()]
  symbol Lblbreak'SClnUnds'C-SYNTAX'Unds'JumpStatement{}() : SortJumpStatement{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("11"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(274,22,274,32)"), left{}(), format{}("%cbreak%r %c;%r"), injective{}()]
  symbol Lblcase'UndsColnUndsUnds'C-SYNTAX'Unds'LabeledStatement'Unds'ConstantExpression'Unds'Statement{}(SortConstantExpression{}, SortStatement{}) : SortLabeledStatement{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1010"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(258,25,258,63)"), left{}(), format{}("%ccase%r %1 %c:%r %2"), injective{}()]
  hooked-symbol LblcategoryChar'LParUndsRParUnds'STRING-COMMON'Unds'String'Unds'String{}(SortString{}) : SortString{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("1101"), klabel{}("categoryChar"), hook{}("STRING.category"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1544,21,1544,80)"), left{}(), format{}("%ccategoryChar%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblchar'Unds'C-SYNTAX'Unds'TypeSpecifier{}() : SortTypeSpecifier{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(30,22,30,27)"), left{}(), format{}("%cchar%r"), injective{}()]
  hooked-symbol Lblchoice'LParUndsRParUnds'MAP'Unds'KItem'Unds'Map{}(SortMap{}) : SortKItem{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("1101"), klabel{}("Map:choice"), hook{}("MAP.choice"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(402,20,402,100)"), left{}(), format{}("%cchoice%r %c(%r %1 %c)%r"), function{}()]
  hooked-symbol Lblchoice'LParUndsRParUnds'SET'Unds'KItem'Unds'Set{}(SortSet{}) : SortKItem{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("1101"), klabel{}("Set:choice"), hook{}("SET.choice"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(610,20,610,94)"), left{}(), format{}("%cchoice%r %c(%r %1 %c)%r"), function{}()]
  hooked-symbol LblchrChar'LParUndsRParUnds'STRING-COMMON'Unds'String'Unds'Int{}(SortInt{}) : SortString{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("1101"), klabel{}("chrChar"), hook{}("STRING.chr"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1404,21,1404,69)"), left{}(), format{}("%cchrChar%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblconst'Unds'C-SYNTAX'Unds'TypeQualifier{}() : SortTypeQualifier{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(76,26,76,32)"), left{}(), format{}("%cconst%r"), injective{}()]
  symbol Lblcontinue'SClnUnds'C-SYNTAX'Unds'JumpStatement{}() : SortJumpStatement{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("11"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(273,22,273,35)"), left{}(), format{}("%ccontinue%r %c;%r"), injective{}()]
  hooked-symbol LblcountAllOccurrences'LParUndsCommUndsRParUnds'STRING-COMMON'Unds'Int'Unds'String'Unds'String{}(SortString{}, SortString{}) : SortInt{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("110101"), hook{}("STRING.countAllOccurrences"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1517,18,1517,150)"), left{}(), format{}("%ccountAllOccurrences%r %c(%r %1 %c,%r %2 %c)%r"), function{}()]
  symbol Lbldefault'ColnUndsUnds'C-SYNTAX'Unds'LabeledStatement'Unds'Statement{}(SortStatement{}) : SortLabeledStatement{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("110"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(259,25,259,47)"), left{}(), format{}("%cdefault%r %c:%r %1"), injective{}()]
  hooked-symbol LbldirectionalityChar'LParUndsRParUnds'STRING-COMMON'Unds'String'Unds'String{}(SortString{}) : SortString{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("1101"), klabel{}("directionalityChar"), hook{}("STRING.directionality"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1545,21,1545,86)"), left{}(), format{}("%cdirectionalityChar%r %c(%r %1 %c)%r"), function{}()]
  symbol Lbldo'Unds'while'LParUndsRParSClnUnds'C-SYNTAX'Unds'IterationStatement'Unds'Statement'Unds'Expression{}(SortStatement{}, SortExpression{}) : SortIterationStatement{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1011011"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(269,27,269,71)"), left{}(), format{}("%cdo%r %1 %cwhile%r %c(%r %2 %c)%r %c;%r"), injective{}()]
  symbol Lbldouble'Unds'C-SYNTAX'Unds'TypeSpecifier{}() : SortTypeSpecifier{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(35,22,35,29)"), left{}(), format{}("%cdouble%r"), injective{}()]
  symbol Lblenum'UndsUnds'C-SYNTAX'Unds'EnumOfspecifier'Unds'Id{}(SortId{}) : SortEnumOfspecifier{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("10"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(220,22,220,30)"), left{}(), format{}("%cenum%r %1"), injective{}()]
  symbol Lblenum'UndsLBraUndsRBraUnds'C-SYNTAX'Unds'EnumOfspecifier'Unds'Id'Unds'EnumeratorList{}(SortId{}, SortEnumeratorList{}) : SortEnumOfspecifier{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("10101"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(218,28,218,59)"), left{}(), format{}("%cenum%r %1 %c{%r %2 %c}%r"), injective{}()]
  symbol Lblenum'LBraUndsRBraUnds'C-SYNTAX'Unds'EnumOfspecifier'Unds'EnumeratorList{}(SortEnumeratorList{}) : SortEnumOfspecifier{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1101"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(219,22,219,50)"), left{}(), format{}("%cenum%r %c{%r %1 %c}%r"), injective{}()]
  symbol Lblextern'Unds'C-SYNTAX'Unds'StorageClassSpecifier{}() : SortStorageClassSpecifier{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(26,31,26,38)"), left{}(), format{}("%cextern%r"), injective{}()]
  hooked-symbol LblfillList'LParUndsCommUndsCommUndsCommUndsRParUnds'LIST'Unds'List'Unds'List'Unds'Int'Unds'Int'Unds'KItem{}(SortList{}, SortInt{}, SortInt{}, SortKItem{}) : SortList{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("1101010101"), klabel{}("fillList"), hook{}("LIST.fill"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(711,19,711,99)"), left{}(), format{}("%cfillList%r %c(%r %1 %c,%r %2 %c,%r %3 %c,%r %4 %c)%r"), function{}()]
  hooked-symbol LblfindChar'LParUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'Int'Unds'String'Unds'String'Unds'Int{}(SortString{}, SortString{}, SortInt{}) : SortInt{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("11010101"), klabel{}("findChar"), hook{}("STRING.findChar"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1441,18,1441,115)"), left{}(), format{}("%cfindChar%r %c(%r %1 %c,%r %2 %c,%r %3 %c)%r"), function{}()]
  hooked-symbol LblfindString'LParUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'Int'Unds'String'Unds'String'Unds'Int{}(SortString{}, SortString{}, SortInt{}) : SortInt{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("11010101"), klabel{}("findString"), hook{}("STRING.find"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1430,18,1430,110)"), left{}(), format{}("%cfindString%r %c(%r %1 %c,%r %2 %c,%r %3 %c)%r"), function{}()]
  symbol Lblfloat'Unds'C-SYNTAX'Unds'TypeSpecifier{}() : SortTypeSpecifier{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(34,22,34,28)"), left{}(), format{}("%cfloat%r"), injective{}()]
  symbol Lblfor'LParUndsSClnUndsSClnUndsRParUndsUnds'C-SYNTAX'Unds'IterationStatement'Unds'Expression'Unds'Expression'Unds'Expression'Unds'Statement{}(SortExpression{}, SortExpression{}, SortExpression{}, SortStatement{}) : SortIterationStatement{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("110101010"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(270,27,270,90)"), left{}(), format{}("%cfor%r %c(%r %1 %c;%r %2 %c;%r %3 %c)%r %4"), injective{}()]
  symbol LblfreshId'LParUndsRParUnds'ID-COMMON'Unds'Id'Unds'Int{}(SortInt{}) : SortId{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("1101"), freshGenerator{}(), klabel{}("freshId"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1984,17,1984,70)"), left{}(), format{}("%cfreshId%r %c(%r %1 %c)%r"), function{}()]
  symbol LblfreshInt'LParUndsRParUnds'INT'Unds'Int'Unds'Int{}(SortInt{}) : SortInt{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("1101"), freshGenerator{}(), klabel{}("freshInt"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1119,18,1119,72)"), left{}(), format{}("%cfreshInt%r %c(%r %1 %c)%r"), function{}()]
  symbol LblgetGeneratedCounterCell{}(SortGeneratedTopCell{}) : SortGeneratedCounterCell{} [priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cgetGeneratedCounterCell%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblgoto'UndsSClnUnds'C-SYNTAX'Unds'JumpStatement'Unds'Id{}(SortId{}) : SortJumpStatement{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("101"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(272,26,272,38)"), left{}(), format{}("%cgoto%r %1 %c;%r"), injective{}()]
  symbol Lblif'LParUndsRParUndsUnds'C-SYNTAX'Unds'SelectionStatement'Unds'Expression'Unds'Statement{}(SortExpression{}, SortStatement{}) : SortSelectionStatement{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("11010"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(264,31,264,63)"), left{}(), format{}("%cif%r %c(%r %1 %c)%r %2"), injective{}()]
  symbol Lblif'LParUndsRParUnds'else'UndsUnds'C-SYNTAX'Unds'SelectionStatement'Unds'Expression'Unds'Statement'Unds'Statement{}(SortExpression{}, SortStatement{}, SortStatement{}) : SortSelectionStatement{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1101010"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(265,27,265,76)"), left{}(), format{}("%cif%r %c(%r %1 %c)%r %2 %celse%r %3"), injective{}()]
  symbol LblinitGeneratedCounterCell{}() : SortGeneratedCounterCell{} [noThread{}(), priorities{}(), right{}(), terminals{}("1"), left{}(), initializer{}(), format{}("%cinitGeneratedCounterCell%r"), function{}()]
  symbol LblinitGeneratedTopCell{}(SortMap{}) : SortGeneratedTopCell{} [noThread{}(), priorities{}(), right{}(), terminals{}("1101"), left{}(), initializer{}(), format{}("%cinitGeneratedTopCell%r %c(%r %1 %c)%r"), function{}()]
  symbol LblinitKCell{}(SortMap{}) : SortKCell{} [noThread{}(), priorities{}(), right{}(), terminals{}("1101"), left{}(), initializer{}(), format{}("%cinitKCell%r %c(%r %1 %c)%r"), function{}()]
  symbol LblinitOslCell{}() : SortOslCell{} [noThread{}(), priorities{}(), right{}(), terminals{}("1"), left{}(), initializer{}(), format{}("%cinitOslCell%r"), function{}()]
  symbol LblinitTCell{}(SortMap{}) : SortTCell{} [noThread{}(), priorities{}(), right{}(), terminals{}("1101"), left{}(), initializer{}(), format{}("%cinitTCell%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblint'Unds'C-SYNTAX'Unds'TypeSpecifier{}() : SortTypeSpecifier{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(32,22,32,26)"), left{}(), format{}("%cint%r"), injective{}()]
  hooked-symbol LblintersectSet'LParUndsCommUndsRParUnds'SET'Unds'Set'Unds'Set'Unds'Set{}(SortSet{}, SortSet{}) : SortSet{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("110101"), klabel{}("intersectSet"), hook{}("SET.intersection"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(565,18,565,88)"), left{}(), format{}("%cintersectSet%r %c(%r %1 %c,%r %2 %c)%r"), function{}()]
  symbol LblisAbstractDeclarator{}(SortK{}) : SortBool{} [predicate{}("AbstractDeclarator"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisAbstractDeclarator%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisAdditiveExpression{}(SortK{}) : SortBool{} [predicate{}("AdditiveExpression"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisAdditiveExpression%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisAndExpression{}(SortK{}) : SortBool{} [predicate{}("AndExpression"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisAndExpression%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisAssignmentExpression{}(SortK{}) : SortBool{} [predicate{}("AssignmentExpression"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisAssignmentExpression%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisAssignmentOperator{}(SortK{}) : SortBool{} [predicate{}("AssignmentOperator"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisAssignmentOperator%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisBool{}(SortK{}) : SortBool{} [predicate{}("Bool"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisBool%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisCastExpression{}(SortK{}) : SortBool{} [predicate{}("CastExpression"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisCastExpression%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisCompoundStatement{}(SortK{}) : SortBool{} [predicate{}("CompoundStatement"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisCompoundStatement%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisConditionalExpression{}(SortK{}) : SortBool{} [predicate{}("ConditionalExpression"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisConditionalExpression%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisConstant{}(SortK{}) : SortBool{} [predicate{}("Constant"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisConstant%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisConstantExpression{}(SortK{}) : SortBool{} [predicate{}("ConstantExpression"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisConstantExpression%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisDeclaration{}(SortK{}) : SortBool{} [predicate{}("Declaration"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisDeclaration%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisDeclarationSpecifier{}(SortK{}) : SortBool{} [predicate{}("DeclarationSpecifier"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisDeclarationSpecifier%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisDeclarator{}(SortK{}) : SortBool{} [predicate{}("Declarator"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisDeclarator%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisDirectAbstractDeclarator{}(SortK{}) : SortBool{} [predicate{}("DirectAbstractDeclarator"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisDirectAbstractDeclarator%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisDirectDeclarator{}(SortK{}) : SortBool{} [predicate{}("DirectDeclarator"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisDirectDeclarator%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisEnumOfspecifier{}(SortK{}) : SortBool{} [predicate{}("EnumOfspecifier"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisEnumOfspecifier%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisEnumerationConstant{}(SortK{}) : SortBool{} [predicate{}("EnumerationConstant"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisEnumerationConstant%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisEnumerator{}(SortK{}) : SortBool{} [predicate{}("Enumerator"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisEnumerator%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisEnumeratorList{}(SortK{}) : SortBool{} [predicate{}("EnumeratorList"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisEnumeratorList%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisEqualityExpression{}(SortK{}) : SortBool{} [predicate{}("EqualityExpression"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisEqualityExpression%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisExclusiveOforExpression{}(SortK{}) : SortBool{} [predicate{}("ExclusiveOforExpression"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisExclusiveOforExpression%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisExpression{}(SortK{}) : SortBool{} [predicate{}("Expression"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisExpression%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisExpressionStatement{}(SortK{}) : SortBool{} [predicate{}("ExpressionStatement"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisExpressionStatement%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisExternalDeclaration{}(SortK{}) : SortBool{} [predicate{}("ExternalDeclaration"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisExternalDeclaration%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisFloat{}(SortK{}) : SortBool{} [predicate{}("Float"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisFloat%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisFunctionDefinition{}(SortK{}) : SortBool{} [predicate{}("FunctionDefinition"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisFunctionDefinition%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisGeneratedCounterCell{}(SortK{}) : SortBool{} [predicate{}("GeneratedCounterCell"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisGeneratedCounterCell%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisGeneratedCounterCellOpt{}(SortK{}) : SortBool{} [predicate{}("GeneratedCounterCellOpt"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisGeneratedCounterCellOpt%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisGeneratedTopCell{}(SortK{}) : SortBool{} [predicate{}("GeneratedTopCell"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisGeneratedTopCell%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisGeneratedTopCellFragment{}(SortK{}) : SortBool{} [predicate{}("GeneratedTopCellFragment"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisGeneratedTopCellFragment%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisIOError{}(SortK{}) : SortBool{} [predicate{}("IOError"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisIOError%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisIOFile{}(SortK{}) : SortBool{} [predicate{}("IOFile"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisIOFile%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisIOInt{}(SortK{}) : SortBool{} [predicate{}("IOInt"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisIOInt%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisIOString{}(SortK{}) : SortBool{} [predicate{}("IOString"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisIOString%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisId{}(SortK{}) : SortBool{} [predicate{}("Id"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisId%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisIds{}(SortK{}) : SortBool{} [predicate{}("Ids"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisIds%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisInclusiveOforExpression{}(SortK{}) : SortBool{} [predicate{}("InclusiveOforExpression"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisInclusiveOforExpression%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisInitdeclarator{}(SortK{}) : SortBool{} [predicate{}("Initdeclarator"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisInitdeclarator%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisInitializer{}(SortK{}) : SortBool{} [predicate{}("Initializer"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisInitializer%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisInitializerList{}(SortK{}) : SortBool{} [predicate{}("InitializerList"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisInitializerList%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisInt{}(SortK{}) : SortBool{} [predicate{}("Int"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisInt%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisIterationStatement{}(SortK{}) : SortBool{} [predicate{}("IterationStatement"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisIterationStatement%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisJumpStatement{}(SortK{}) : SortBool{} [predicate{}("JumpStatement"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisJumpStatement%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisK{}(SortK{}) : SortBool{} [predicate{}("K"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisK%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisKCell{}(SortK{}) : SortBool{} [predicate{}("KCell"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisKCell%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisKCellOpt{}(SortK{}) : SortBool{} [predicate{}("KCellOpt"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisKCellOpt%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisKConfigVar{}(SortK{}) : SortBool{} [predicate{}("KConfigVar"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisKConfigVar%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisKItem{}(SortK{}) : SortBool{} [predicate{}("KItem"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisKItem%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisKResult{}(SortK{}) : SortBool{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), symbol'Kywd'{}(), priorities{}(), right{}(), terminals{}("1101"), klabel{}("isKResult"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(5,17,5,47)"), left{}(), format{}("%cisKResult%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisLabeledStatement{}(SortK{}) : SortBool{} [predicate{}("LabeledStatement"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisLabeledStatement%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisList{}(SortK{}) : SortBool{} [predicate{}("List"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisList%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisListAssignmentExpression{}(SortK{}) : SortBool{} [predicate{}("ListAssignmentExpression"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisListAssignmentExpression%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisListDeclaration{}(SortK{}) : SortBool{} [predicate{}("ListDeclaration"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisListDeclaration%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisListDeclarationSpecifier{}(SortK{}) : SortBool{} [predicate{}("ListDeclarationSpecifier"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisListDeclarationSpecifier%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisListExternalDeclaration{}(SortK{}) : SortBool{} [predicate{}("ListExternalDeclaration"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisListExternalDeclaration%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisListInitDeclarator{}(SortK{}) : SortBool{} [predicate{}("ListInitDeclarator"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisListInitDeclarator%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisListSpecifierQualifier{}(SortK{}) : SortBool{} [predicate{}("ListSpecifierQualifier"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisListSpecifierQualifier%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisListStatement{}(SortK{}) : SortBool{} [predicate{}("ListStatement"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisListStatement%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisListStructDeclaration{}(SortK{}) : SortBool{} [predicate{}("ListStructDeclaration"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisListStructDeclaration%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisListTypeQualifier{}(SortK{}) : SortBool{} [predicate{}("ListTypeQualifier"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisListTypeQualifier%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisLogicalOfandExpression{}(SortK{}) : SortBool{} [predicate{}("LogicalOfandExpression"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisLogicalOfandExpression%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisLogicalOforExpression{}(SortK{}) : SortBool{} [predicate{}("LogicalOforExpression"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisLogicalOforExpression%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisMap{}(SortK{}) : SortBool{} [predicate{}("Map"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisMap%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisMultiplicativeExpression{}(SortK{}) : SortBool{} [predicate{}("MultiplicativeExpression"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisMultiplicativeExpression%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisOslCell{}(SortK{}) : SortBool{} [predicate{}("OslCell"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisOslCell%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisOslCellOpt{}(SortK{}) : SortBool{} [predicate{}("OslCellOpt"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisOslCellOpt%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisParameterDeclaration{}(SortK{}) : SortBool{} [predicate{}("ParameterDeclaration"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisParameterDeclaration%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisParameterList{}(SortK{}) : SortBool{} [predicate{}("ParameterList"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisParameterList%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisParameterTypeList{}(SortK{}) : SortBool{} [predicate{}("ParameterTypeList"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisParameterTypeList%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisPointer{}(SortK{}) : SortBool{} [predicate{}("Pointer"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisPointer%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisPostfixExpression{}(SortK{}) : SortBool{} [predicate{}("PostfixExpression"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisPostfixExpression%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisPrimaryExpression{}(SortK{}) : SortBool{} [predicate{}("PrimaryExpression"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisPrimaryExpression%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisRelationalExpression{}(SortK{}) : SortBool{} [predicate{}("RelationalExpression"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisRelationalExpression%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisSelectionStatement{}(SortK{}) : SortBool{} [predicate{}("SelectionStatement"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisSelectionStatement%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisSet{}(SortK{}) : SortBool{} [predicate{}("Set"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisSet%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisShiftExpression{}(SortK{}) : SortBool{} [predicate{}("ShiftExpression"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisShiftExpression%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisSpecifierQualifier{}(SortK{}) : SortBool{} [predicate{}("SpecifierQualifier"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisSpecifierQualifier%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisStatement{}(SortK{}) : SortBool{} [predicate{}("Statement"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisStatement%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisStorageClassSpecifier{}(SortK{}) : SortBool{} [predicate{}("StorageClassSpecifier"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisStorageClassSpecifier%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisStream{}(SortK{}) : SortBool{} [predicate{}("Stream"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisStream%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisString{}(SortK{}) : SortBool{} [predicate{}("String"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisString%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisStructDeclaration{}(SortK{}) : SortBool{} [predicate{}("StructDeclaration"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisStructDeclaration%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisStructDeclarator{}(SortK{}) : SortBool{} [predicate{}("StructDeclarator"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisStructDeclarator%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisStructDeclaratorList{}(SortK{}) : SortBool{} [predicate{}("StructDeclaratorList"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisStructDeclaratorList%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisStructOrFunionSpecifier{}(SortK{}) : SortBool{} [predicate{}("StructOrFunionSpecifier"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisStructOrFunionSpecifier%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisStructOrUnion{}(SortK{}) : SortBool{} [predicate{}("StructOrUnion"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisStructOrUnion%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisTCell{}(SortK{}) : SortBool{} [predicate{}("TCell"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisTCell%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisTCellFragment{}(SortK{}) : SortBool{} [predicate{}("TCellFragment"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisTCellFragment%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisTCellOpt{}(SortK{}) : SortBool{} [predicate{}("TCellOpt"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisTCellOpt%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisTranslationUnit{}(SortK{}) : SortBool{} [predicate{}("TranslationUnit"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisTranslationUnit%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisTypeName{}(SortK{}) : SortBool{} [predicate{}("TypeName"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisTypeName%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisTypeQualifier{}(SortK{}) : SortBool{} [predicate{}("TypeQualifier"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisTypeQualifier%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisTypeSpecifier{}(SortK{}) : SortBool{} [predicate{}("TypeSpecifier"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisTypeSpecifier%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisTypedefOfname{}(SortK{}) : SortBool{} [predicate{}("TypedefOfname"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisTypedefOfname%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisUnaryExpression{}(SortK{}) : SortBool{} [predicate{}("UnaryExpression"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisUnaryExpression%r %c(%r %1 %c)%r"), function{}()]
  symbol LblisUnaryOperator{}(SortK{}) : SortBool{} [predicate{}("UnaryOperator"), priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cisUnaryOperator%r %c(%r %1 %c)%r"), function{}()]
  hooked-symbol Lblkeys'LParUndsRParUnds'MAP'Unds'Set'Unds'Map{}(SortMap{}) : SortSet{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("1101"), klabel{}("keys"), hook{}("MAP.keys"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(350,18,350,86)"), left{}(), format{}("%ckeys%r %c(%r %1 %c)%r"), function{}()]
  hooked-symbol Lblkeys'Unds'list'LParUndsRParUnds'MAP'Unds'List'Unds'Map{}(SortMap{}) : SortList{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("1101"), hook{}("MAP.keys_list"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(358,19,358,79)"), left{}(), format{}("%ckeys_list%r %c(%r %1 %c)%r"), function{}()]
  hooked-symbol LbllengthString'LParUndsRParUnds'STRING-COMMON'Unds'Int'Unds'String{}(SortString{}) : SortInt{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("1101"), klabel{}("lengthString"), hook{}("STRING.length"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1395,18,1395,84)"), left{}(), format{}("%clengthString%r %c(%r %1 %c)%r"), function{}()]
  hooked-symbol Lbllog2Int'LParUndsRParUnds'INT-COMMON'Unds'Int'Unds'Int{}(SortInt{}) : SortInt{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("1101"), klabel{}("log2Int"), hook{}("INT.log2"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(979,18,979,74)"), left{}(), format{}("%clog2Int%r %c(%r %1 %c)%r"), function{}()]
  symbol Lbllong'Unds'C-SYNTAX'Unds'TypeSpecifier{}() : SortTypeSpecifier{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(33,22,33,27)"), left{}(), format{}("%clong%r"), injective{}()]
  hooked-symbol LblmakeList'LParUndsCommUndsRParUnds'LIST'Unds'List'Unds'Int'Unds'KItem{}(SortInt{}, SortKItem{}) : SortList{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("110101"), klabel{}("makeList"), hook{}("LIST.make"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(692,19,692,81)"), left{}(), format{}("%cmakeList%r %c(%r %1 %c,%r %2 %c)%r"), function{}()]
  hooked-symbol LblmaxInt'LParUndsCommUndsRParUnds'INT-COMMON'Unds'Int'Unds'Int'Unds'Int{}(SortInt{}, SortInt{}) : SortInt{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), smt-hook{}("(ite (< #1 #2) #2 #1)"), right{}(), terminals{}("110101"), hook{}("INT.max"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(960,18,960,118)"), left{}(), format{}("%cmaxInt%r %c(%r %1 %c,%r %2 %c)%r"), function{}()]
  hooked-symbol LblminInt'LParUndsCommUndsRParUnds'INT-COMMON'Unds'Int'Unds'Int'Unds'Int{}(SortInt{}, SortInt{}) : SortInt{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), smt-hook{}("(ite (< #1 #2) #1 #2)"), right{}(), terminals{}("110101"), hook{}("INT.min"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(959,18,959,118)"), left{}(), format{}("%cminInt%r %c(%r %1 %c,%r %2 %c)%r"), function{}()]
  hooked-symbol LblnewUUID'Unds'STRING-COMMON'Unds'String{}() : SortString{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("1"), impure{}(), hook{}("STRING.uuid"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1547,21,1547,67)"), left{}(), format{}("%cnewUUID%r"), function{}()]
  symbol LblnoGeneratedCounterCell{}() : SortGeneratedCounterCellOpt{} [functional{}(), constructor{}(), cellOptAbsent{}("GeneratedCounterCell"), priorities{}(), right{}(), terminals{}("1"), left{}(), format{}("%cnoGeneratedCounterCell%r"), injective{}()]
  symbol LblnoKCell{}() : SortKCellOpt{} [functional{}(), constructor{}(), cellOptAbsent{}("KCell"), priorities{}(), right{}(), terminals{}("1"), left{}(), format{}("%cnoKCell%r"), injective{}()]
  symbol LblnoOslCell{}() : SortOslCellOpt{} [functional{}(), constructor{}(), cellOptAbsent{}("OslCell"), priorities{}(), right{}(), terminals{}("1"), left{}(), format{}("%cnoOslCell%r"), injective{}()]
  symbol LblnoTCell{}() : SortTCellOpt{} [functional{}(), constructor{}(), cellOptAbsent{}("TCell"), priorities{}(), right{}(), terminals{}("1"), left{}(), format{}("%cnoTCell%r"), injective{}()]
  hooked-symbol LblnotBool'Unds'{}(SortBool{}) : SortBool{} [latex{}("\\neg_{\\scriptstyle\\it Bool}{#1}"), functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(Lbl'Unds'orElseBool'Unds'{}(),Lbl'Unds'orBool'Unds'{}(),Lbl'UndsEqlsSlshEqls'Bool'Unds'{}(),Lbl'Unds'andThenBool'Unds'{}(),Lbl'Unds'impliesBool'Unds'{}(),Lbl'UndsEqlsEqls'Bool'Unds'{}(),Lbl'Unds'andBool'Unds'{}(),Lbl'Unds'xorBool'Unds'{}()), smt-hook{}("not"), boolOperation{}(), right{}(), terminals{}("10"), klabel{}("notBool_"), hook{}("BOOL.not"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(818,19,818,176)"), left{}(), format{}("%cnotBool%r %1"), function{}()]
  hooked-symbol LblordChar'LParUndsRParUnds'STRING-COMMON'Unds'Int'Unds'String{}(SortString{}) : SortInt{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("1101"), klabel{}("ordChar"), hook{}("STRING.ord"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1405,18,1405,69)"), left{}(), format{}("%cordChar%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'ColnHash'tempFile'Coln'fd{}(SortIOFile{}) : SortInt{} [priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cfd%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'ColnHash'tempFile'Coln'path{}(SortIOFile{}) : SortString{} [priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cpath%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'ColnHash'unknownIOError'Coln'errno{}(SortIOError{}) : SortInt{} [priorities{}(), right{}(), terminals{}("1101"), left{}(), format{}("%cerrno%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'AbstractDeclarator{}(SortK{}) : SortAbstractDeclarator{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:AbstractDeclarator%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'AdditiveExpression{}(SortK{}) : SortAdditiveExpression{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:AdditiveExpression%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'AndExpression{}(SortK{}) : SortAndExpression{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:AndExpression%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'AssignmentExpression{}(SortK{}) : SortAssignmentExpression{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:AssignmentExpression%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'AssignmentOperator{}(SortK{}) : SortAssignmentOperator{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:AssignmentOperator%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'Bool{}(SortK{}) : SortBool{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:Bool%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'CastExpression{}(SortK{}) : SortCastExpression{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:CastExpression%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'CompoundStatement{}(SortK{}) : SortCompoundStatement{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:CompoundStatement%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'ConditionalExpression{}(SortK{}) : SortConditionalExpression{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:ConditionalExpression%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'Constant{}(SortK{}) : SortConstant{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:Constant%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'ConstantExpression{}(SortK{}) : SortConstantExpression{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:ConstantExpression%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'Declaration{}(SortK{}) : SortDeclaration{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:Declaration%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'DeclarationSpecifier{}(SortK{}) : SortDeclarationSpecifier{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:DeclarationSpecifier%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'Declarator{}(SortK{}) : SortDeclarator{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:Declarator%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'DirectAbstractDeclarator{}(SortK{}) : SortDirectAbstractDeclarator{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:DirectAbstractDeclarator%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'DirectDeclarator{}(SortK{}) : SortDirectDeclarator{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:DirectDeclarator%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'EnumOfspecifier{}(SortK{}) : SortEnumOfspecifier{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:EnumOfspecifier%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'EnumerationConstant{}(SortK{}) : SortEnumerationConstant{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:EnumerationConstant%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'Enumerator{}(SortK{}) : SortEnumerator{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:Enumerator%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'EnumeratorList{}(SortK{}) : SortEnumeratorList{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:EnumeratorList%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'EqualityExpression{}(SortK{}) : SortEqualityExpression{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:EqualityExpression%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'ExclusiveOforExpression{}(SortK{}) : SortExclusiveOforExpression{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:ExclusiveOforExpression%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'Expression{}(SortK{}) : SortExpression{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:Expression%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'ExpressionStatement{}(SortK{}) : SortExpressionStatement{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:ExpressionStatement%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'ExternalDeclaration{}(SortK{}) : SortExternalDeclaration{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:ExternalDeclaration%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'Float{}(SortK{}) : SortFloat{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:Float%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'FunctionDefinition{}(SortK{}) : SortFunctionDefinition{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:FunctionDefinition%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'GeneratedCounterCell{}(SortK{}) : SortGeneratedCounterCell{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:GeneratedCounterCell%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'GeneratedCounterCellOpt{}(SortK{}) : SortGeneratedCounterCellOpt{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:GeneratedCounterCellOpt%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'GeneratedTopCell{}(SortK{}) : SortGeneratedTopCell{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:GeneratedTopCell%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'GeneratedTopCellFragment{}(SortK{}) : SortGeneratedTopCellFragment{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:GeneratedTopCellFragment%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'IOError{}(SortK{}) : SortIOError{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:IOError%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'IOFile{}(SortK{}) : SortIOFile{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:IOFile%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'IOInt{}(SortK{}) : SortIOInt{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:IOInt%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'IOString{}(SortK{}) : SortIOString{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:IOString%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'Id{}(SortK{}) : SortId{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:Id%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'Ids{}(SortK{}) : SortIds{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:Ids%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'InclusiveOforExpression{}(SortK{}) : SortInclusiveOforExpression{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:InclusiveOforExpression%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'Initdeclarator{}(SortK{}) : SortInitdeclarator{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:Initdeclarator%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'Initializer{}(SortK{}) : SortInitializer{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:Initializer%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'InitializerList{}(SortK{}) : SortInitializerList{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:InitializerList%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'Int{}(SortK{}) : SortInt{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:Int%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'IterationStatement{}(SortK{}) : SortIterationStatement{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:IterationStatement%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'JumpStatement{}(SortK{}) : SortJumpStatement{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:JumpStatement%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'K{}(SortK{}) : SortK{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:K%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'KCell{}(SortK{}) : SortKCell{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:KCell%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'KCellOpt{}(SortK{}) : SortKCellOpt{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:KCellOpt%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'KItem{}(SortK{}) : SortKItem{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:KItem%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'LabeledStatement{}(SortK{}) : SortLabeledStatement{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:LabeledStatement%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'List{}(SortK{}) : SortList{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:List%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'ListAssignmentExpression{}(SortK{}) : SortListAssignmentExpression{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:ListAssignmentExpression%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'ListDeclaration{}(SortK{}) : SortListDeclaration{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:ListDeclaration%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'ListDeclarationSpecifier{}(SortK{}) : SortListDeclarationSpecifier{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:ListDeclarationSpecifier%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'ListExternalDeclaration{}(SortK{}) : SortListExternalDeclaration{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:ListExternalDeclaration%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'ListInitDeclarator{}(SortK{}) : SortListInitDeclarator{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:ListInitDeclarator%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'ListSpecifierQualifier{}(SortK{}) : SortListSpecifierQualifier{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:ListSpecifierQualifier%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'ListStatement{}(SortK{}) : SortListStatement{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:ListStatement%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'ListStructDeclaration{}(SortK{}) : SortListStructDeclaration{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:ListStructDeclaration%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'ListTypeQualifier{}(SortK{}) : SortListTypeQualifier{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:ListTypeQualifier%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'LogicalOfandExpression{}(SortK{}) : SortLogicalOfandExpression{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:LogicalOfandExpression%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'LogicalOforExpression{}(SortK{}) : SortLogicalOforExpression{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:LogicalOforExpression%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'Map{}(SortK{}) : SortMap{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:Map%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'MultiplicativeExpression{}(SortK{}) : SortMultiplicativeExpression{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:MultiplicativeExpression%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'OslCell{}(SortK{}) : SortOslCell{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:OslCell%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'OslCellOpt{}(SortK{}) : SortOslCellOpt{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:OslCellOpt%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'ParameterDeclaration{}(SortK{}) : SortParameterDeclaration{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:ParameterDeclaration%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'ParameterList{}(SortK{}) : SortParameterList{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:ParameterList%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'ParameterTypeList{}(SortK{}) : SortParameterTypeList{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:ParameterTypeList%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'Pointer{}(SortK{}) : SortPointer{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:Pointer%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'PostfixExpression{}(SortK{}) : SortPostfixExpression{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:PostfixExpression%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'PrimaryExpression{}(SortK{}) : SortPrimaryExpression{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:PrimaryExpression%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'RelationalExpression{}(SortK{}) : SortRelationalExpression{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:RelationalExpression%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'SelectionStatement{}(SortK{}) : SortSelectionStatement{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:SelectionStatement%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'Set{}(SortK{}) : SortSet{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:Set%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'ShiftExpression{}(SortK{}) : SortShiftExpression{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:ShiftExpression%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'SpecifierQualifier{}(SortK{}) : SortSpecifierQualifier{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:SpecifierQualifier%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'Statement{}(SortK{}) : SortStatement{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:Statement%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'StorageClassSpecifier{}(SortK{}) : SortStorageClassSpecifier{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:StorageClassSpecifier%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'Stream{}(SortK{}) : SortStream{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:Stream%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'String{}(SortK{}) : SortString{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:String%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'StructDeclaration{}(SortK{}) : SortStructDeclaration{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:StructDeclaration%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'StructDeclarator{}(SortK{}) : SortStructDeclarator{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:StructDeclarator%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'StructDeclaratorList{}(SortK{}) : SortStructDeclaratorList{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:StructDeclaratorList%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'StructOrFunionSpecifier{}(SortK{}) : SortStructOrFunionSpecifier{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:StructOrFunionSpecifier%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'StructOrUnion{}(SortK{}) : SortStructOrUnion{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:StructOrUnion%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'TCell{}(SortK{}) : SortTCell{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:TCell%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'TCellFragment{}(SortK{}) : SortTCellFragment{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:TCellFragment%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'TCellOpt{}(SortK{}) : SortTCellOpt{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:TCellOpt%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'TranslationUnit{}(SortK{}) : SortTranslationUnit{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:TranslationUnit%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'TypeName{}(SortK{}) : SortTypeName{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:TypeName%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'TypeQualifier{}(SortK{}) : SortTypeQualifier{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:TypeQualifier%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'TypeSpecifier{}(SortK{}) : SortTypeSpecifier{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:TypeSpecifier%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'TypedefOfname{}(SortK{}) : SortTypedefOfname{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:TypedefOfname%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'UnaryExpression{}(SortK{}) : SortUnaryExpression{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:UnaryExpression%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblproject'Coln'UnaryOperator{}(SortK{}) : SortUnaryOperator{} [priorities{}(), right{}(), terminals{}("1101"), projection{}(), left{}(), format{}("%cproject:UnaryOperator%r %c(%r %1 %c)%r"), function{}()]
  hooked-symbol LblrandInt'LParUndsRParUnds'INT'Unds'Int'Unds'Int{}(SortInt{}) : SortInt{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("1101"), impure{}(), klabel{}("randInt"), hook{}("INT.rand"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1122,18,1122,64)"), left{}(), format{}("%crandInt%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblregister'Unds'C-SYNTAX'Unds'StorageClassSpecifier{}() : SortStorageClassSpecifier{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(24,31,24,40)"), left{}(), format{}("%cregister%r"), injective{}()]
  hooked-symbol LblremoveAll'LParUndsCommUndsRParUnds'MAP'Unds'Map'Unds'Map'Unds'Set{}(SortMap{}, SortSet{}) : SortMap{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("110101"), klabel{}("removeAll"), hook{}("MAP.removeAll"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(342,18,342,91)"), left{}(), format{}("%cremoveAll%r %c(%r %1 %c,%r %2 %c)%r"), function{}()]
  hooked-symbol Lblreplace'LParUndsCommUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'String'Unds'String'Unds'String'Unds'String'Unds'Int{}(SortString{}, SortString{}, SortString{}, SortInt{}) : SortString{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("1101010101"), hook{}("STRING.replace"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1515,21,1515,145)"), left{}(), format{}("%creplace%r %c(%r %1 %c,%r %2 %c,%r %3 %c,%r %4 %c)%r"), function{}()]
  hooked-symbol LblreplaceAll'LParUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'String'Unds'String'Unds'String'Unds'String{}(SortString{}, SortString{}, SortString{}) : SortString{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("11010101"), hook{}("STRING.replaceAll"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1514,21,1514,153)"), left{}(), format{}("%creplaceAll%r %c(%r %1 %c,%r %2 %c,%r %3 %c)%r"), function{}()]
  hooked-symbol LblreplaceFirst'LParUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'String'Unds'String'Unds'String'Unds'String{}(SortString{}, SortString{}, SortString{}) : SortString{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("11010101"), hook{}("STRING.replaceFirst"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1516,21,1516,155)"), left{}(), format{}("%creplaceFirst%r %c(%r %1 %c,%r %2 %c,%r %3 %c)%r"), function{}()]
  symbol Lblreturn'UndsSClnUnds'C-SYNTAX'Unds'JumpStatement'Unds'Expression{}(SortExpression{}) : SortJumpStatement{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("101"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(275,22,275,44)"), left{}(), format{}("%creturn%r %1 %c;%r"), injective{}()]
  hooked-symbol LblrfindChar'LParUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'Int'Unds'String'Unds'String'Unds'Int{}(SortString{}, SortString{}, SortInt{}) : SortInt{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("11010101"), klabel{}("rfindChar"), hook{}("STRING.rfindChar"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1442,18,1442,116)"), left{}(), format{}("%crfindChar%r %c(%r %1 %c,%r %2 %c,%r %3 %c)%r"), function{}()]
  hooked-symbol LblrfindString'LParUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'Int'Unds'String'Unds'String'Unds'Int{}(SortString{}, SortString{}, SortInt{}) : SortInt{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("11010101"), klabel{}("rfindString"), hook{}("STRING.rfind"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1431,18,1431,111)"), left{}(), format{}("%crfindString%r %c(%r %1 %c,%r %2 %c,%r %3 %c)%r"), function{}()]
  symbol Lblshort'Unds'C-SYNTAX'Unds'TypeSpecifier{}() : SortTypeSpecifier{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(31,22,31,28)"), left{}(), format{}("%cshort%r"), injective{}()]
  hooked-symbol LblsignExtendBitRangeInt'LParUndsCommUndsCommUndsRParUnds'INT-COMMON'Unds'Int'Unds'Int'Unds'Int'Unds'Int{}(SortInt{}, SortInt{}, SortInt{}) : SortInt{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("11010101"), klabel{}("signExtendBitRangeInt"), hook{}("INT.signExtendBitRange"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(994,18,994,112)"), left{}(), format{}("%csignExtendBitRangeInt%r %c(%r %1 %c,%r %2 %c,%r %3 %c)%r"), function{}()]
  symbol Lblsigned'Unds'C-SYNTAX'Unds'TypeSpecifier{}() : SortTypeSpecifier{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(36,22,36,29)"), left{}(), format{}("%csigned%r"), injective{}()]
  hooked-symbol Lblsize'LParUndsRParUnds'LIST'Unds'Int'Unds'List{}(SortList{}) : SortInt{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), smtlib{}("smt_seq_len"), terminals{}("1101"), klabel{}("sizeList"), hook{}("LIST.size"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(738,18,738,121)"), left{}(), format{}("%csize%r %c(%r %1 %c)%r"), function{}()]
  hooked-symbol Lblsize'LParUndsRParUnds'MAP'Unds'Int'Unds'Map{}(SortMap{}) : SortInt{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("1101"), klabel{}("sizeMap"), hook{}("MAP.size"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(382,18,382,103)"), left{}(), format{}("%csize%r %c(%r %1 %c)%r"), function{}()]
  hooked-symbol Lblsize'LParUndsRParUnds'SET'Unds'Int'Unds'Set{}(SortSet{}) : SortInt{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("1101"), klabel{}("size"), hook{}("SET.size"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(600,18,600,80)"), left{}(), format{}("%csize%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblsizeof'UndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'TypeName{}(SortTypeName{}) : SortUnaryExpression{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("10"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(139,24,139,40)"), left{}(), format{}("%csizeof%r %1"), injective{}()]
  symbol Lblsizeof'UndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'UnaryExpression{}(SortUnaryExpression{}) : SortUnaryExpression{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("10"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(138,24,138,47)"), left{}(), format{}("%csizeof%r %1"), injective{}()]
  hooked-symbol LblsrandInt'LParUndsRParUnds'INT'Unds'K'Unds'Int{}(SortInt{}) : SortK{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("1101"), impure{}(), klabel{}("srandInt"), hook{}("INT.srand"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1123,16,1123,64)"), left{}(), format{}("%csrandInt%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblstatic'Unds'C-SYNTAX'Unds'StorageClassSpecifier{}() : SortStorageClassSpecifier{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(25,31,25,38)"), left{}(), format{}("%cstatic%r"), injective{}()]
  symbol Lblstruct'Unds'C-SYNTAX'Unds'StructOrUnion{}() : SortStructOrUnion{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(49,26,49,33)"), left{}(), format{}("%cstruct%r"), injective{}()]
  hooked-symbol LblsubstrString'LParUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'String'Unds'String'Unds'Int'Unds'Int{}(SortString{}, SortInt{}, SortInt{}) : SortString{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("11010101"), klabel{}("substrString"), hook{}("STRING.substr"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1420,21,1420,121)"), left{}(), format{}("%csubstrString%r %c(%r %1 %c,%r %2 %c,%r %3 %c)%r"), function{}()]
  symbol Lblswitch'LParUndsRParUndsUnds'C-SYNTAX'Unds'SelectionStatement'Unds'Expression'Unds'Statement{}(SortExpression{}, SortStatement{}) : SortSelectionStatement{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("11010"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(266,27,266,63)"), left{}(), format{}("%cswitch%r %c(%r %1 %c)%r %2"), injective{}()]
  symbol Lbltypedef'Unds'C-SYNTAX'Unds'StorageClassSpecifier{}() : SortStorageClassSpecifier{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(27,31,27,39)"), left{}(), format{}("%ctypedef%r"), injective{}()]
  symbol Lblunion'Unds'C-SYNTAX'Unds'StructOrUnion{}() : SortStructOrUnion{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(50,23,50,29)"), left{}(), format{}("%cunion%r"), injective{}()]
  symbol Lblunsigned'Unds'C-SYNTAX'Unds'TypeSpecifier{}() : SortTypeSpecifier{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(37,22,37,31)"), left{}(), format{}("%cunsigned%r"), injective{}()]
  hooked-symbol LblupdateList'LParUndsCommUndsCommUndsRParUnds'LIST'Unds'List'Unds'List'Unds'Int'Unds'List{}(SortList{}, SortInt{}, SortList{}) : SortList{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("11010101"), klabel{}("updateList"), hook{}("LIST.updateAll"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(702,19,702,96)"), left{}(), format{}("%cupdateList%r %c(%r %1 %c,%r %2 %c,%r %3 %c)%r"), function{}()]
  hooked-symbol LblupdateMap'LParUndsCommUndsRParUnds'MAP'Unds'Map'Unds'Map'Unds'Map{}(SortMap{}, SortMap{}) : SortMap{} [functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("110101"), klabel{}("updateMap"), hook{}("MAP.updateAll"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(333,18,333,91)"), left{}(), format{}("%cupdateMap%r %c(%r %1 %c,%r %2 %c)%r"), function{}()]
  hooked-symbol Lblvalues'LParUndsRParUnds'MAP'Unds'List'Unds'Map{}(SortMap{}) : SortList{} [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), priorities{}(), right{}(), terminals{}("1101"), klabel{}("values"), hook{}("MAP.values"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(374,19,374,76)"), left{}(), format{}("%cvalues%r %c(%r %1 %c)%r"), function{}()]
  symbol Lblvoid'Unds'C-SYNTAX'Unds'TypeSpecifier{}() : SortTypeSpecifier{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(29,26,29,31)"), left{}(), format{}("%cvoid%r"), injective{}()]
  symbol Lblvolatile'Unds'C-SYNTAX'Unds'TypeQualifier{}() : SortTypeQualifier{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(77,22,77,31)"), left{}(), format{}("%cvolatile%r"), injective{}()]
  symbol Lblwhile'LParUndsRParUndsUnds'C-SYNTAX'Unds'IterationStatement'Unds'Expression'Unds'Statement{}(SortExpression{}, SortStatement{}) : SortIterationStatement{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("11010"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(268,31,268,66)"), left{}(), format{}("%cwhile%r %c(%r %1 %c)%r %2"), injective{}()]
  symbol Lbl'LBraUndsCommRBraUnds'C-SYNTAX'Unds'Initializer'Unds'InitializerList{}(SortInitializerList{}) : SortInitializer{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1011"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(241,19,241,45)"), left{}(), format{}("%c{%r %1 %c,%r %c}%r"), injective{}()]
  symbol Lbl'LBraUndsUndsRBraUnds'C-SYNTAX'Unds'CompoundStatement'Unds'ListDeclaration'Unds'ListStatement{}(SortListDeclaration{}, SortListStatement{}) : SortCompoundStatement{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1001"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(246,30,246,66)"), left{}(), format{}("%c{%r %1 %2 %c}%r"), injective{}()]
  symbol Lbl'LBraUndsRBraUnds'C-SYNTAX'Unds'Initializer'Unds'InitializerList{}(SortInitializerList{}) : SortInitializer{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("101"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(240,19,240,41)"), left{}(), format{}("%c{%r %1 %c}%r"), injective{}()]
  symbol Lbl'PipeEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}() : SortAssignmentOperator{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(178,27,178,30)"), left{}(), format{}("%c|=%r"), injective{}()]
  hooked-symbol Lbl'Tild'Int'Unds'{}(SortInt{}) : SortInt{} [latex{}("\\mathop{\\sim_{\\scriptstyle\\it Int}}{#1}"), functional{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), symbol'Kywd'{}(), priorities{}(Lbl'UndsPlus'Int'Unds'{}(),Lbl'Unds'divInt'Unds'{}(),Lbl'UndsPerc'Int'Unds'{}(),Lbl'Unds-GT--GT-'Int'Unds'{}(),Lbl'Unds'xorInt'Unds'{}(),Lbl'UndsSlsh'Int'Unds'{}(),Lbl'UndsAnd-'Int'Unds'{}(),Lbl'UndsXor-'Int'Unds'{}(),Lbl'Unds-LT--LT-'Int'Unds'{}(),Lbl'UndsStar'Int'Unds'{}(),Lbl'UndsPipe'Int'Unds'{}(),Lbl'Unds'modInt'Unds'{}(),Lbl'UndsXor-Perc'Int'UndsUnds'{}(),Lbl'Unds'-Int'Unds'{}()), right{}(), smtlib{}("notInt"), terminals{}("10"), klabel{}("~Int_"), hook{}("INT.not"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(927,18,927,172)"), left{}(), format{}("%c~Int%r %1"), function{}()]
  symbol Lbl'TildUnds'C-SYNTAX'Unds'UnaryOperator{}() : SortUnaryOperator{} [functional{}(), constructor{}(), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/syntax.k)"), priorities{}(), right{}(), terminals{}("1"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(184,22,184,24)"), left{}(), format{}("%c~%r"), injective{}()]

// generated axioms
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortIOString{}, SortKItem{}} (From:SortIOString{}))) [subsort{SortIOString{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortJumpStatement{}, SortKItem{}} (From:SortJumpStatement{}))) [subsort{SortJumpStatement{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortEqualityExpression{}, \equals{SortEqualityExpression{}, R} (Val:SortEqualityExpression{}, inj{SortRelationalExpression{}, SortEqualityExpression{}} (From:SortRelationalExpression{}))) [subsort{SortRelationalExpression{}, SortEqualityExpression{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortString{}, SortKItem{}} (From:SortString{}))) [subsort{SortString{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortPrimaryExpression{}, \equals{SortPrimaryExpression{}, R} (Val:SortPrimaryExpression{}, inj{SortConstant{}, SortPrimaryExpression{}} (From:SortConstant{}))) [subsort{SortConstant{}, SortPrimaryExpression{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortTCell{}, SortKItem{}} (From:SortTCell{}))) [subsort{SortTCell{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortFunctionDefinition{}, SortKItem{}} (From:SortFunctionDefinition{}))) [subsort{SortFunctionDefinition{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortStatement{}, \equals{SortStatement{}, R} (Val:SortStatement{}, inj{SortExpressionStatement{}, SortStatement{}} (From:SortExpressionStatement{}))) [subsort{SortExpressionStatement{}, SortStatement{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortTypeName{}, SortKItem{}} (From:SortTypeName{}))) [subsort{SortTypeName{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortRelationalExpression{}, SortKItem{}} (From:SortRelationalExpression{}))) [subsort{SortRelationalExpression{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortPrimaryExpression{}, \equals{SortPrimaryExpression{}, R} (Val:SortPrimaryExpression{}, inj{SortId{}, SortPrimaryExpression{}} (From:SortId{}))) [subsort{SortId{}, SortPrimaryExpression{}}()] // subsort
  axiom{R} \exists{R} (Val:SortInclusiveOforExpression{}, \equals{SortInclusiveOforExpression{}, R} (Val:SortInclusiveOforExpression{}, inj{SortExclusiveOforExpression{}, SortInclusiveOforExpression{}} (From:SortExclusiveOforExpression{}))) [subsort{SortExclusiveOforExpression{}, SortInclusiveOforExpression{}}()] // subsort
  axiom{R} \exists{R} (Val:SortExclusiveOforExpression{}, \equals{SortExclusiveOforExpression{}, R} (Val:SortExclusiveOforExpression{}, inj{SortAndExpression{}, SortExclusiveOforExpression{}} (From:SortAndExpression{}))) [subsort{SortAndExpression{}, SortExclusiveOforExpression{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortExpression{}, SortKItem{}} (From:SortExpression{}))) [subsort{SortExpression{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortExternalDeclaration{}, \equals{SortExternalDeclaration{}, R} (Val:SortExternalDeclaration{}, inj{SortDeclaration{}, SortExternalDeclaration{}} (From:SortDeclaration{}))) [subsort{SortDeclaration{}, SortExternalDeclaration{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortInitdeclarator{}, SortKItem{}} (From:SortInitdeclarator{}))) [subsort{SortInitdeclarator{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortKCellOpt{}, SortKItem{}} (From:SortKCellOpt{}))) [subsort{SortKCellOpt{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortIds{}, SortKItem{}} (From:SortIds{}))) [subsort{SortIds{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortGeneratedCounterCellOpt{}, SortKItem{}} (From:SortGeneratedCounterCellOpt{}))) [subsort{SortGeneratedCounterCellOpt{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortOslCell{}, SortKItem{}} (From:SortOslCell{}))) [subsort{SortOslCell{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortListDeclaration{}, SortKItem{}} (From:SortListDeclaration{}))) [subsort{SortListDeclaration{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortInitializerList{}, SortKItem{}} (From:SortInitializerList{}))) [subsort{SortInitializerList{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortConstant{}, \equals{SortConstant{}, R} (Val:SortConstant{}, inj{SortEnumerationConstant{}, SortConstant{}} (From:SortEnumerationConstant{}))) [subsort{SortEnumerationConstant{}, SortConstant{}}()] // subsort
  axiom{R} \exists{R} (Val:SortGeneratedCounterCellOpt{}, \equals{SortGeneratedCounterCellOpt{}, R} (Val:SortGeneratedCounterCellOpt{}, inj{SortGeneratedCounterCell{}, SortGeneratedCounterCellOpt{}} (From:SortGeneratedCounterCell{}))) [subsort{SortGeneratedCounterCell{}, SortGeneratedCounterCellOpt{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortListStatement{}, SortKItem{}} (From:SortListStatement{}))) [subsort{SortListStatement{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortKCell{}, SortKItem{}} (From:SortKCell{}))) [subsort{SortKCell{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortTCellOpt{}, SortKItem{}} (From:SortTCellOpt{}))) [subsort{SortTCellOpt{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortExpression{}, \equals{SortExpression{}, R} (Val:SortExpression{}, inj{SortAssignmentExpression{}, SortExpression{}} (From:SortAssignmentExpression{}))) [subsort{SortAssignmentExpression{}, SortExpression{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortAbstractDeclarator{}, SortKItem{}} (From:SortAbstractDeclarator{}))) [subsort{SortAbstractDeclarator{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortIterationStatement{}, SortKItem{}} (From:SortIterationStatement{}))) [subsort{SortIterationStatement{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortPostfixExpression{}, SortKItem{}} (From:SortPostfixExpression{}))) [subsort{SortPostfixExpression{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortListAssignmentExpression{}, SortKItem{}} (From:SortListAssignmentExpression{}))) [subsort{SortListAssignmentExpression{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortUnaryExpression{}, \equals{SortUnaryExpression{}, R} (Val:SortUnaryExpression{}, inj{SortPostfixExpression{}, SortUnaryExpression{}} (From:SortPostfixExpression{}))) [subsort{SortPostfixExpression{}, SortUnaryExpression{}}()] // subsort
  axiom{R} \exists{R} (Val:SortConstantExpression{}, \equals{SortConstantExpression{}, R} (Val:SortConstantExpression{}, inj{SortConditionalExpression{}, SortConstantExpression{}} (From:SortConditionalExpression{}))) [subsort{SortConditionalExpression{}, SortConstantExpression{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortLogicalOfandExpression{}, SortKItem{}} (From:SortLogicalOfandExpression{}))) [subsort{SortLogicalOfandExpression{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortAssignmentExpression{}, SortKItem{}} (From:SortAssignmentExpression{}))) [subsort{SortAssignmentExpression{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortDirectDeclarator{}, SortKItem{}} (From:SortDirectDeclarator{}))) [subsort{SortDirectDeclarator{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortLogicalOfandExpression{}, \equals{SortLogicalOfandExpression{}, R} (Val:SortLogicalOfandExpression{}, inj{SortInclusiveOforExpression{}, SortLogicalOfandExpression{}} (From:SortInclusiveOforExpression{}))) [subsort{SortInclusiveOforExpression{}, SortLogicalOfandExpression{}}()] // subsort
  axiom{R} \exists{R} (Val:SortOslCellOpt{}, \equals{SortOslCellOpt{}, R} (Val:SortOslCellOpt{}, inj{SortOslCell{}, SortOslCellOpt{}} (From:SortOslCell{}))) [subsort{SortOslCell{}, SortOslCellOpt{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortInitializer{}, SortKItem{}} (From:SortInitializer{}))) [subsort{SortInitializer{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortEnumOfspecifier{}, SortKItem{}} (From:SortEnumOfspecifier{}))) [subsort{SortEnumOfspecifier{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortDeclarationSpecifier{}, \equals{SortDeclarationSpecifier{}, R} (Val:SortDeclarationSpecifier{}, inj{SortTypeSpecifier{}, SortDeclarationSpecifier{}} (From:SortTypeSpecifier{}))) [subsort{SortTypeSpecifier{}, SortDeclarationSpecifier{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortConstantExpression{}, SortKItem{}} (From:SortConstantExpression{}))) [subsort{SortConstantExpression{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortStatement{}, \equals{SortStatement{}, R} (Val:SortStatement{}, inj{SortCompoundStatement{}, SortStatement{}} (From:SortCompoundStatement{}))) [subsort{SortCompoundStatement{}, SortStatement{}}()] // subsort
  axiom{R} \exists{R} (Val:SortIOInt{}, \equals{SortIOInt{}, R} (Val:SortIOInt{}, inj{SortIOError{}, SortIOInt{}} (From:SortIOError{}))) [subsort{SortIOError{}, SortIOInt{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortPrimaryExpression{}, SortKItem{}} (From:SortPrimaryExpression{}))) [subsort{SortPrimaryExpression{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKCellOpt{}, \equals{SortKCellOpt{}, R} (Val:SortKCellOpt{}, inj{SortKCell{}, SortKCellOpt{}} (From:SortKCell{}))) [subsort{SortKCell{}, SortKCellOpt{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortUnaryOperator{}, SortKItem{}} (From:SortUnaryOperator{}))) [subsort{SortUnaryOperator{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortExternalDeclaration{}, SortKItem{}} (From:SortExternalDeclaration{}))) [subsort{SortExternalDeclaration{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortDeclarator{}, \equals{SortDeclarator{}, R} (Val:SortDeclarator{}, inj{SortDirectDeclarator{}, SortDeclarator{}} (From:SortDirectDeclarator{}))) [subsort{SortDirectDeclarator{}, SortDeclarator{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortSet{}, SortKItem{}} (From:SortSet{}))) [subsort{SortSet{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortAndExpression{}, \equals{SortAndExpression{}, R} (Val:SortAndExpression{}, inj{SortEqualityExpression{}, SortAndExpression{}} (From:SortEqualityExpression{}))) [subsort{SortEqualityExpression{}, SortAndExpression{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortIOError{}, SortKItem{}} (From:SortIOError{}))) [subsort{SortIOError{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortDeclarator{}, SortKItem{}} (From:SortDeclarator{}))) [subsort{SortDeclarator{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortLogicalOforExpression{}, \equals{SortLogicalOforExpression{}, R} (Val:SortLogicalOforExpression{}, inj{SortLogicalOfandExpression{}, SortLogicalOforExpression{}} (From:SortLogicalOfandExpression{}))) [subsort{SortLogicalOfandExpression{}, SortLogicalOforExpression{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortTypeSpecifier{}, SortKItem{}} (From:SortTypeSpecifier{}))) [subsort{SortTypeSpecifier{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortConstant{}, \equals{SortConstant{}, R} (Val:SortConstant{}, inj{SortInt{}, SortConstant{}} (From:SortInt{}))) [subsort{SortInt{}, SortConstant{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortCompoundStatement{}, SortKItem{}} (From:SortCompoundStatement{}))) [subsort{SortCompoundStatement{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortStructDeclaration{}, SortKItem{}} (From:SortStructDeclaration{}))) [subsort{SortStructDeclaration{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortStorageClassSpecifier{}, SortKItem{}} (From:SortStorageClassSpecifier{}))) [subsort{SortStorageClassSpecifier{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortGeneratedCounterCell{}, SortKItem{}} (From:SortGeneratedCounterCell{}))) [subsort{SortGeneratedCounterCell{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortPointer{}, SortKItem{}} (From:SortPointer{}))) [subsort{SortPointer{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortDirectDeclarator{}, \equals{SortDirectDeclarator{}, R} (Val:SortDirectDeclarator{}, inj{SortId{}, SortDirectDeclarator{}} (From:SortId{}))) [subsort{SortId{}, SortDirectDeclarator{}}()] // subsort
  axiom{R} \exists{R} (Val:SortIOInt{}, \equals{SortIOInt{}, R} (Val:SortIOInt{}, inj{SortInt{}, SortIOInt{}} (From:SortInt{}))) [subsort{SortInt{}, SortIOInt{}}()] // subsort
  axiom{R} \exists{R} (Val:SortTCellOpt{}, \equals{SortTCellOpt{}, R} (Val:SortTCellOpt{}, inj{SortTCell{}, SortTCellOpt{}} (From:SortTCell{}))) [subsort{SortTCell{}, SortTCellOpt{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortListDeclarationSpecifier{}, SortKItem{}} (From:SortListDeclarationSpecifier{}))) [subsort{SortListDeclarationSpecifier{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortParameterList{}, \equals{SortParameterList{}, R} (Val:SortParameterList{}, inj{SortParameterDeclaration{}, SortParameterList{}} (From:SortParameterDeclaration{}))) [subsort{SortParameterDeclaration{}, SortParameterList{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortTCellFragment{}, SortKItem{}} (From:SortTCellFragment{}))) [subsort{SortTCellFragment{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortDirectAbstractDeclarator{}, SortKItem{}} (From:SortDirectAbstractDeclarator{}))) [subsort{SortDirectAbstractDeclarator{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortSelectionStatement{}, SortKItem{}} (From:SortSelectionStatement{}))) [subsort{SortSelectionStatement{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortConstant{}, \equals{SortConstant{}, R} (Val:SortConstant{}, inj{SortFloat{}, SortConstant{}} (From:SortFloat{}))) [subsort{SortFloat{}, SortConstant{}}()] // subsort
  axiom{R} \exists{R} (Val:SortRelationalExpression{}, \equals{SortRelationalExpression{}, R} (Val:SortRelationalExpression{}, inj{SortShiftExpression{}, SortRelationalExpression{}} (From:SortShiftExpression{}))) [subsort{SortShiftExpression{}, SortRelationalExpression{}}()] // subsort
  axiom{R} \exists{R} (Val:SortStatement{}, \equals{SortStatement{}, R} (Val:SortStatement{}, inj{SortJumpStatement{}, SortStatement{}} (From:SortJumpStatement{}))) [subsort{SortJumpStatement{}, SortStatement{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortCastExpression{}, SortKItem{}} (From:SortCastExpression{}))) [subsort{SortCastExpression{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortTypeSpecifier{}, \equals{SortTypeSpecifier{}, R} (Val:SortTypeSpecifier{}, inj{SortEnumOfspecifier{}, SortTypeSpecifier{}} (From:SortEnumOfspecifier{}))) [subsort{SortEnumOfspecifier{}, SortTypeSpecifier{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortLabeledStatement{}, SortKItem{}} (From:SortLabeledStatement{}))) [subsort{SortLabeledStatement{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortPrimaryExpression{}, \equals{SortPrimaryExpression{}, R} (Val:SortPrimaryExpression{}, inj{SortString{}, SortPrimaryExpression{}} (From:SortString{}))) [subsort{SortString{}, SortPrimaryExpression{}}()] // subsort
  axiom{R} \exists{R} (Val:SortSpecifierQualifier{}, \equals{SortSpecifierQualifier{}, R} (Val:SortSpecifierQualifier{}, inj{SortTypeSpecifier{}, SortSpecifierQualifier{}} (From:SortTypeSpecifier{}))) [subsort{SortTypeSpecifier{}, SortSpecifierQualifier{}}()] // subsort
  axiom{R} \exists{R} (Val:SortTypeName{}, \equals{SortTypeName{}, R} (Val:SortTypeName{}, inj{SortListSpecifierQualifier{}, SortTypeName{}} (From:SortListSpecifierQualifier{}))) [subsort{SortListSpecifierQualifier{}, SortTypeName{}}()] // subsort
  axiom{R} \exists{R} (Val:SortConditionalExpression{}, \equals{SortConditionalExpression{}, R} (Val:SortConditionalExpression{}, inj{SortLogicalOforExpression{}, SortConditionalExpression{}} (From:SortLogicalOforExpression{}))) [subsort{SortLogicalOforExpression{}, SortConditionalExpression{}}()] // subsort
  axiom{R} \exists{R} (Val:SortInitializer{}, \equals{SortInitializer{}, R} (Val:SortInitializer{}, inj{SortAssignmentExpression{}, SortInitializer{}} (From:SortAssignmentExpression{}))) [subsort{SortAssignmentExpression{}, SortInitializer{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortShiftExpression{}, SortKItem{}} (From:SortShiftExpression{}))) [subsort{SortShiftExpression{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortEqualityExpression{}, SortKItem{}} (From:SortEqualityExpression{}))) [subsort{SortEqualityExpression{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortMultiplicativeExpression{}, SortKItem{}} (From:SortMultiplicativeExpression{}))) [subsort{SortMultiplicativeExpression{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortAbstractDeclarator{}, \equals{SortAbstractDeclarator{}, R} (Val:SortAbstractDeclarator{}, inj{SortDirectAbstractDeclarator{}, SortAbstractDeclarator{}} (From:SortDirectAbstractDeclarator{}))) [subsort{SortDirectAbstractDeclarator{}, SortAbstractDeclarator{}}()] // subsort
  axiom{R} \exists{R} (Val:SortDeclarationSpecifier{}, \equals{SortDeclarationSpecifier{}, R} (Val:SortDeclarationSpecifier{}, inj{SortStorageClassSpecifier{}, SortDeclarationSpecifier{}} (From:SortStorageClassSpecifier{}))) [subsort{SortStorageClassSpecifier{}, SortDeclarationSpecifier{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortStream{}, SortKItem{}} (From:SortStream{}))) [subsort{SortStream{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortAdditiveExpression{}, \equals{SortAdditiveExpression{}, R} (Val:SortAdditiveExpression{}, inj{SortMultiplicativeExpression{}, SortAdditiveExpression{}} (From:SortMultiplicativeExpression{}))) [subsort{SortMultiplicativeExpression{}, SortAdditiveExpression{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortIOFile{}, SortKItem{}} (From:SortIOFile{}))) [subsort{SortIOFile{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortStructDeclaratorList{}, \equals{SortStructDeclaratorList{}, R} (Val:SortStructDeclaratorList{}, inj{SortStructDeclarator{}, SortStructDeclaratorList{}} (From:SortStructDeclarator{}))) [subsort{SortStructDeclarator{}, SortStructDeclaratorList{}}()] // subsort
  axiom{R} \exists{R} (Val:SortStructDeclarator{}, \equals{SortStructDeclarator{}, R} (Val:SortStructDeclarator{}, inj{SortDeclarator{}, SortStructDeclarator{}} (From:SortDeclarator{}))) [subsort{SortDeclarator{}, SortStructDeclarator{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortExclusiveOforExpression{}, SortKItem{}} (From:SortExclusiveOforExpression{}))) [subsort{SortExclusiveOforExpression{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortCastExpression{}, \equals{SortCastExpression{}, R} (Val:SortCastExpression{}, inj{SortUnaryExpression{}, SortCastExpression{}} (From:SortUnaryExpression{}))) [subsort{SortUnaryExpression{}, SortCastExpression{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortGeneratedTopCell{}, SortKItem{}} (From:SortGeneratedTopCell{}))) [subsort{SortGeneratedTopCell{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortListInitDeclarator{}, SortKItem{}} (From:SortListInitDeclarator{}))) [subsort{SortListInitDeclarator{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortInitializerList{}, \equals{SortInitializerList{}, R} (Val:SortInitializerList{}, inj{SortInitializer{}, SortInitializerList{}} (From:SortInitializer{}))) [subsort{SortInitializer{}, SortInitializerList{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortEnumeratorList{}, SortKItem{}} (From:SortEnumeratorList{}))) [subsort{SortEnumeratorList{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortListSpecifierQualifier{}, SortKItem{}} (From:SortListSpecifierQualifier{}))) [subsort{SortListSpecifierQualifier{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortEnumerationConstant{}, \equals{SortEnumerationConstant{}, R} (Val:SortEnumerationConstant{}, inj{SortId{}, SortEnumerationConstant{}} (From:SortId{}))) [subsort{SortId{}, SortEnumerationConstant{}}()] // subsort
  axiom{R} \exists{R} (Val:SortAssignmentExpression{}, \equals{SortAssignmentExpression{}, R} (Val:SortAssignmentExpression{}, inj{SortConditionalExpression{}, SortAssignmentExpression{}} (From:SortConditionalExpression{}))) [subsort{SortConditionalExpression{}, SortAssignmentExpression{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortIOInt{}, SortKItem{}} (From:SortIOInt{}))) [subsort{SortIOInt{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortEnumerator{}, \equals{SortEnumerator{}, R} (Val:SortEnumerator{}, inj{SortId{}, SortEnumerator{}} (From:SortId{}))) [subsort{SortId{}, SortEnumerator{}}()] // subsort
  axiom{R} \exists{R} (Val:SortShiftExpression{}, \equals{SortShiftExpression{}, R} (Val:SortShiftExpression{}, inj{SortAdditiveExpression{}, SortShiftExpression{}} (From:SortAdditiveExpression{}))) [subsort{SortAdditiveExpression{}, SortShiftExpression{}}()] // subsort
  axiom{R} \exists{R} (Val:SortTypeSpecifier{}, \equals{SortTypeSpecifier{}, R} (Val:SortTypeSpecifier{}, inj{SortStructOrFunionSpecifier{}, SortTypeSpecifier{}} (From:SortStructOrFunionSpecifier{}))) [subsort{SortStructOrFunionSpecifier{}, SortTypeSpecifier{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortStructDeclaratorList{}, SortKItem{}} (From:SortStructDeclaratorList{}))) [subsort{SortStructDeclaratorList{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortAbstractDeclarator{}, \equals{SortAbstractDeclarator{}, R} (Val:SortAbstractDeclarator{}, inj{SortPointer{}, SortAbstractDeclarator{}} (From:SortPointer{}))) [subsort{SortPointer{}, SortAbstractDeclarator{}}()] // subsort
  axiom{R} \exists{R} (Val:SortTypedefOfname{}, \equals{SortTypedefOfname{}, R} (Val:SortTypedefOfname{}, inj{SortId{}, SortTypedefOfname{}} (From:SortId{}))) [subsort{SortId{}, SortTypedefOfname{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortDeclaration{}, SortKItem{}} (From:SortDeclaration{}))) [subsort{SortDeclaration{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortParameterTypeList{}, SortKItem{}} (From:SortParameterTypeList{}))) [subsort{SortParameterTypeList{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortList{}, SortKItem{}} (From:SortList{}))) [subsort{SortList{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortInitdeclarator{}, \equals{SortInitdeclarator{}, R} (Val:SortInitdeclarator{}, inj{SortDeclarator{}, SortInitdeclarator{}} (From:SortDeclarator{}))) [subsort{SortDeclarator{}, SortInitdeclarator{}}()] // subsort
  axiom{R} \exists{R} (Val:SortParameterTypeList{}, \equals{SortParameterTypeList{}, R} (Val:SortParameterTypeList{}, inj{SortParameterList{}, SortParameterTypeList{}} (From:SortParameterList{}))) [subsort{SortParameterList{}, SortParameterTypeList{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortAdditiveExpression{}, SortKItem{}} (From:SortAdditiveExpression{}))) [subsort{SortAdditiveExpression{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortExternalDeclaration{}, \equals{SortExternalDeclaration{}, R} (Val:SortExternalDeclaration{}, inj{SortFunctionDefinition{}, SortExternalDeclaration{}} (From:SortFunctionDefinition{}))) [subsort{SortFunctionDefinition{}, SortExternalDeclaration{}}()] // subsort
  axiom{R} \exists{R} (Val:SortIOString{}, \equals{SortIOString{}, R} (Val:SortIOString{}, inj{SortString{}, SortIOString{}} (From:SortString{}))) [subsort{SortString{}, SortIOString{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortLogicalOforExpression{}, SortKItem{}} (From:SortLogicalOforExpression{}))) [subsort{SortLogicalOforExpression{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortStatement{}, \equals{SortStatement{}, R} (Val:SortStatement{}, inj{SortLabeledStatement{}, SortStatement{}} (From:SortLabeledStatement{}))) [subsort{SortLabeledStatement{}, SortStatement{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortId{}, SortKItem{}} (From:SortId{}))) [subsort{SortId{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortInclusiveOforExpression{}, SortKItem{}} (From:SortInclusiveOforExpression{}))) [subsort{SortInclusiveOforExpression{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortOslCellOpt{}, SortKItem{}} (From:SortOslCellOpt{}))) [subsort{SortOslCellOpt{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortFloat{}, SortKItem{}} (From:SortFloat{}))) [subsort{SortFloat{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortSpecifierQualifier{}, \equals{SortSpecifierQualifier{}, R} (Val:SortSpecifierQualifier{}, inj{SortTypeQualifier{}, SortSpecifierQualifier{}} (From:SortTypeQualifier{}))) [subsort{SortTypeQualifier{}, SortSpecifierQualifier{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortBool{}, SortKItem{}} (From:SortBool{}))) [subsort{SortBool{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortListStructDeclaration{}, SortKItem{}} (From:SortListStructDeclaration{}))) [subsort{SortListStructDeclaration{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortTypedefOfname{}, SortKItem{}} (From:SortTypedefOfname{}))) [subsort{SortTypedefOfname{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortParameterDeclaration{}, SortKItem{}} (From:SortParameterDeclaration{}))) [subsort{SortParameterDeclaration{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortAndExpression{}, SortKItem{}} (From:SortAndExpression{}))) [subsort{SortAndExpression{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortUnaryExpression{}, SortKItem{}} (From:SortUnaryExpression{}))) [subsort{SortUnaryExpression{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortStatement{}, \equals{SortStatement{}, R} (Val:SortStatement{}, inj{SortIterationStatement{}, SortStatement{}} (From:SortIterationStatement{}))) [subsort{SortIterationStatement{}, SortStatement{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortAssignmentOperator{}, SortKItem{}} (From:SortAssignmentOperator{}))) [subsort{SortAssignmentOperator{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortPostfixExpression{}, \equals{SortPostfixExpression{}, R} (Val:SortPostfixExpression{}, inj{SortPrimaryExpression{}, SortPostfixExpression{}} (From:SortPrimaryExpression{}))) [subsort{SortPrimaryExpression{}, SortPostfixExpression{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortConstant{}, SortKItem{}} (From:SortConstant{}))) [subsort{SortConstant{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortDeclarationSpecifier{}, SortKItem{}} (From:SortDeclarationSpecifier{}))) [subsort{SortDeclarationSpecifier{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortStructOrFunionSpecifier{}, SortKItem{}} (From:SortStructOrFunionSpecifier{}))) [subsort{SortStructOrFunionSpecifier{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortListTypeQualifier{}, SortKItem{}} (From:SortListTypeQualifier{}))) [subsort{SortListTypeQualifier{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortSpecifierQualifier{}, SortKItem{}} (From:SortSpecifierQualifier{}))) [subsort{SortSpecifierQualifier{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortParameterDeclaration{}, \equals{SortParameterDeclaration{}, R} (Val:SortParameterDeclaration{}, inj{SortListDeclarationSpecifier{}, SortParameterDeclaration{}} (From:SortListDeclarationSpecifier{}))) [subsort{SortListDeclarationSpecifier{}, SortParameterDeclaration{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortInt{}, SortKItem{}} (From:SortInt{}))) [subsort{SortInt{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortTranslationUnit{}, SortKItem{}} (From:SortTranslationUnit{}))) [subsort{SortTranslationUnit{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortGeneratedTopCellFragment{}, SortKItem{}} (From:SortGeneratedTopCellFragment{}))) [subsort{SortGeneratedTopCellFragment{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortStructDeclarator{}, SortKItem{}} (From:SortStructDeclarator{}))) [subsort{SortStructDeclarator{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortMap{}, SortKItem{}} (From:SortMap{}))) [subsort{SortMap{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortStatement{}, \equals{SortStatement{}, R} (Val:SortStatement{}, inj{SortSelectionStatement{}, SortStatement{}} (From:SortSelectionStatement{}))) [subsort{SortSelectionStatement{}, SortStatement{}}()] // subsort
  axiom{R} \exists{R} (Val:SortTranslationUnit{}, \equals{SortTranslationUnit{}, R} (Val:SortTranslationUnit{}, inj{SortListExternalDeclaration{}, SortTranslationUnit{}} (From:SortListExternalDeclaration{}))) [subsort{SortListExternalDeclaration{}, SortTranslationUnit{}}()] // subsort
  axiom{R} \exists{R} (Val:SortDeclarationSpecifier{}, \equals{SortDeclarationSpecifier{}, R} (Val:SortDeclarationSpecifier{}, inj{SortTypeQualifier{}, SortDeclarationSpecifier{}} (From:SortTypeQualifier{}))) [subsort{SortTypeQualifier{}, SortDeclarationSpecifier{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortStatement{}, SortKItem{}} (From:SortStatement{}))) [subsort{SortStatement{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortIOString{}, \equals{SortIOString{}, R} (Val:SortIOString{}, inj{SortIOError{}, SortIOString{}} (From:SortIOError{}))) [subsort{SortIOError{}, SortIOString{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortEnumerationConstant{}, SortKItem{}} (From:SortEnumerationConstant{}))) [subsort{SortEnumerationConstant{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortMultiplicativeExpression{}, \equals{SortMultiplicativeExpression{}, R} (Val:SortMultiplicativeExpression{}, inj{SortCastExpression{}, SortMultiplicativeExpression{}} (From:SortCastExpression{}))) [subsort{SortCastExpression{}, SortMultiplicativeExpression{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortEnumerator{}, SortKItem{}} (From:SortEnumerator{}))) [subsort{SortEnumerator{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortConditionalExpression{}, SortKItem{}} (From:SortConditionalExpression{}))) [subsort{SortConditionalExpression{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortIOFile{}, \equals{SortIOFile{}, R} (Val:SortIOFile{}, inj{SortIOError{}, SortIOFile{}} (From:SortIOError{}))) [subsort{SortIOError{}, SortIOFile{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortExpressionStatement{}, SortKItem{}} (From:SortExpressionStatement{}))) [subsort{SortExpressionStatement{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortStructOrUnion{}, SortKItem{}} (From:SortStructOrUnion{}))) [subsort{SortStructOrUnion{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortParameterList{}, SortKItem{}} (From:SortParameterList{}))) [subsort{SortParameterList{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortListExternalDeclaration{}, SortKItem{}} (From:SortListExternalDeclaration{}))) [subsort{SortListExternalDeclaration{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, inj{SortTypeQualifier{}, SortKItem{}} (From:SortTypeQualifier{}))) [subsort{SortTypeQualifier{}, SortKItem{}}()] // subsort
  axiom{R} \exists{R} (Val:SortUnaryOperator{}, \equals{SortUnaryOperator{}, R} (Val:SortUnaryOperator{}, Lbl'BangUnds'C-SYNTAX'Unds'UnaryOperator{}())) [functional{}()] // functional
  axiom{}\not{SortUnaryOperator{}} (\and{SortUnaryOperator{}} (Lbl'BangUnds'C-SYNTAX'Unds'UnaryOperator{}(), Lbl'And-Unds'C-SYNTAX'Unds'UnaryOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortUnaryOperator{}} (\and{SortUnaryOperator{}} (Lbl'BangUnds'C-SYNTAX'Unds'UnaryOperator{}(), Lbl'StarUnds'C-SYNTAX'Unds'UnaryOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortUnaryOperator{}} (\and{SortUnaryOperator{}} (Lbl'BangUnds'C-SYNTAX'Unds'UnaryOperator{}(), Lbl'PlusUnds'C-SYNTAX'Unds'UnaryOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortUnaryOperator{}} (\and{SortUnaryOperator{}} (Lbl'BangUnds'C-SYNTAX'Unds'UnaryOperator{}(), Lbl-'Unds'C-SYNTAX'Unds'UnaryOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortUnaryOperator{}} (\and{SortUnaryOperator{}} (Lbl'BangUnds'C-SYNTAX'Unds'UnaryOperator{}(), Lbl'TildUnds'C-SYNTAX'Unds'UnaryOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'E2BIG{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'EACCES{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'EADDRINUSE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'EADDRNOTAVAIL{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'EAFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'EAGAIN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'EALREADY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'EBADF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'EBUSY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'ECHILD{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'ECONNABORTED{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'ECONNREFUSED{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'ECONNRESET{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'EDEADLK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'EDESTADDRREQ{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'EDOM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'EEXIST{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'EFAULT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'EFBIG{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'EHOSTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'EHOSTUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'EINPROGRESS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'EINTR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'EINVAL{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'EIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'EISCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'EISDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'ELOOP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'EMFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'EMLINK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'EMSGSIZE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'ENAMETOOLONG{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'ENETDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'ENETRESET{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'ENETUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'ENFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'ENOBUFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'ENODEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'ENOENT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'ENOEXEC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'ENOLCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'ENOMEM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'ENOPROTOOPT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'ENOSPC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'ENOSYS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'ENOTCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'ENOTDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'ENOTEMPTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'ENOTSOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'ENOTTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'E2BIG{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'EACCES{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'EADDRINUSE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'EADDRNOTAVAIL{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'EAFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'EAGAIN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'EALREADY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'EBADF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'EBUSY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'ECHILD{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'ECONNABORTED{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'ECONNREFUSED{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'ECONNRESET{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'EDEADLK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'EDESTADDRREQ{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'EDOM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'EEXIST{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'EFAULT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'EFBIG{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'EHOSTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'EHOSTUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'EINPROGRESS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'EINTR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'EINVAL{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'EIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'EISCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'EISDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'ELOOP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'EMFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'EMLINK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'EMSGSIZE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'ENAMETOOLONG{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'ENETDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'ENETRESET{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'ENETUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'ENFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'ENOBUFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'ENODEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'ENOENT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'ENOEXEC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'ENOLCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'ENOMEM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'ENOPROTOOPT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'ENOSPC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'ENOSYS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'ENOTCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'ENOTDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'ENOTEMPTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'ENOTSOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'ENOTTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EACCES{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'EADDRINUSE{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'EADDRNOTAVAIL{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'EAFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'EAGAIN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'EALREADY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'EBADF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'EBUSY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'ECHILD{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'ECONNABORTED{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'ECONNREFUSED{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'ECONNRESET{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'EDEADLK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'EDESTADDRREQ{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'EDOM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'EEXIST{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'EFAULT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'EFBIG{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'EHOSTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'EHOSTUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'EINPROGRESS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'EINTR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'EINVAL{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'EIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'EISCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'EISDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'ELOOP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'EMFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'EMLINK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'EMSGSIZE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'ENAMETOOLONG{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'ENETDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'ENETRESET{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'ENETUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'ENFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'ENOBUFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'ENODEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'ENOENT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'ENOEXEC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'ENOLCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'ENOMEM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'ENOPROTOOPT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'ENOSPC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'ENOSYS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'ENOTCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'ENOTDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'ENOTEMPTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'ENOTSOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'ENOTTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'EADDRNOTAVAIL{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'EAFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'EAGAIN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'EALREADY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'EBADF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'EBUSY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'ECHILD{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'ECONNABORTED{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'ECONNREFUSED{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'ECONNRESET{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'EDEADLK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'EDESTADDRREQ{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'EDOM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'EEXIST{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'EFAULT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'EFBIG{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'EHOSTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'EHOSTUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'EINPROGRESS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'EINTR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'EINVAL{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'EIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'EISCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'EISDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'ELOOP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'EMFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'EMLINK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'EMSGSIZE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'ENAMETOOLONG{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'ENETDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'ENETRESET{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'ENETUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'ENFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'ENOBUFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'ENODEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'ENOENT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'ENOEXEC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'ENOLCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'ENOMEM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'ENOPROTOOPT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'ENOSPC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'ENOSYS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'ENOTCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'ENOTDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'ENOTEMPTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'ENOTSOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'ENOTTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'EAFNOSUPPORT{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'EAGAIN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'EALREADY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'EBADF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'EBUSY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'ECHILD{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'ECONNABORTED{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'ECONNREFUSED{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'ECONNRESET{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'EDEADLK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'EDESTADDRREQ{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'EDOM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'EEXIST{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'EFAULT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'EFBIG{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'EHOSTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'EHOSTUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'EINPROGRESS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'EINTR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'EINVAL{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'EIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'EISCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'EISDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'ELOOP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'EMFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'EMLINK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'EMSGSIZE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'ENAMETOOLONG{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'ENETDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'ENETRESET{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'ENETUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'ENFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'ENOBUFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'ENODEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'ENOENT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'ENOEXEC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'ENOLCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'ENOMEM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'ENOPROTOOPT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'ENOSPC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'ENOSYS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'ENOTCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'ENOTDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'ENOTEMPTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'ENOTSOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'ENOTTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'EAGAIN{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'EALREADY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'EBADF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'EBUSY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'ECHILD{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'ECONNABORTED{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'ECONNREFUSED{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'ECONNRESET{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'EDEADLK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'EDESTADDRREQ{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'EDOM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'EEXIST{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'EFAULT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'EFBIG{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'EHOSTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'EHOSTUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'EINPROGRESS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'EINTR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'EINVAL{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'EIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'EISCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'EISDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'ELOOP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'EMFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'EMLINK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'EMSGSIZE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'ENAMETOOLONG{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'ENETDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'ENETRESET{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'ENETUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'ENFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'ENOBUFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'ENODEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'ENOENT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'ENOEXEC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'ENOLCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'ENOMEM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'ENOPROTOOPT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'ENOSPC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'ENOSYS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'ENOTCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'ENOTDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'ENOTEMPTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'ENOTSOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'ENOTTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EAGAIN{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'EALREADY{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'EBADF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'EBUSY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'ECHILD{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'ECONNABORTED{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'ECONNREFUSED{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'ECONNRESET{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'EDEADLK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'EDESTADDRREQ{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'EDOM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'EEXIST{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'EFAULT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'EFBIG{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'EHOSTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'EHOSTUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'EINPROGRESS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'EINTR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'EINVAL{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'EIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'EISCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'EISDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'ELOOP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'EMFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'EMLINK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'EMSGSIZE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'ENAMETOOLONG{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'ENETDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'ENETRESET{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'ENETUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'ENFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'ENOBUFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'ENODEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'ENOENT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'ENOEXEC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'ENOLCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'ENOMEM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'ENOPROTOOPT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'ENOSPC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'ENOSYS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'ENOTCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'ENOTDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'ENOTEMPTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'ENOTSOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'ENOTTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EALREADY{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'EBADF{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'EBUSY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'ECHILD{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'ECONNABORTED{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'ECONNREFUSED{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'ECONNRESET{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'EDEADLK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'EDESTADDRREQ{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'EDOM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'EEXIST{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'EFAULT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'EFBIG{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'EHOSTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'EHOSTUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'EINPROGRESS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'EINTR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'EINVAL{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'EIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'EISCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'EISDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'ELOOP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'EMFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'EMLINK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'EMSGSIZE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'ENAMETOOLONG{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'ENETDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'ENETRESET{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'ENETUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'ENFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'ENOBUFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'ENODEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'ENOENT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'ENOEXEC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'ENOLCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'ENOMEM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'ENOPROTOOPT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'ENOSPC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'ENOSYS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'ENOTCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'ENOTDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'ENOTEMPTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'ENOTSOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'ENOTTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBADF{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'EBUSY{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'ECHILD{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'ECONNABORTED{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'ECONNREFUSED{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'ECONNRESET{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'EDEADLK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'EDESTADDRREQ{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'EDOM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'EEXIST{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'EFAULT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'EFBIG{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'EHOSTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'EHOSTUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'EINPROGRESS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'EINTR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'EINVAL{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'EIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'EISCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'EISDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'ELOOP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'EMFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'EMLINK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'EMSGSIZE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'ENAMETOOLONG{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'ENETDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'ENETRESET{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'ENETUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'ENFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'ENOBUFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'ENODEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'ENOENT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'ENOEXEC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'ENOLCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'ENOMEM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'ENOPROTOOPT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'ENOSPC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'ENOSYS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'ENOTCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'ENOTDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'ENOTEMPTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'ENOTSOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'ENOTTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EBUSY{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'ECHILD{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'ECONNABORTED{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'ECONNREFUSED{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'ECONNRESET{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'EDEADLK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'EDESTADDRREQ{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'EDOM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'EEXIST{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'EFAULT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'EFBIG{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'EHOSTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'EHOSTUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'EINPROGRESS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'EINTR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'EINVAL{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'EIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'EISCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'EISDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'ELOOP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'EMFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'EMLINK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'EMSGSIZE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'ENAMETOOLONG{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'ENETDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'ENETRESET{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'ENETUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'ENFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'ENOBUFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'ENODEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'ENOENT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'ENOEXEC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'ENOLCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'ENOMEM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'ENOPROTOOPT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'ENOSPC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'ENOSYS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'ENOTCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'ENOTDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'ENOTEMPTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'ENOTSOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'ENOTTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECHILD{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'ECONNABORTED{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'ECONNREFUSED{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'ECONNRESET{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'EDEADLK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'EDESTADDRREQ{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'EDOM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'EEXIST{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'EFAULT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'EFBIG{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'EHOSTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'EHOSTUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'EINPROGRESS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'EINTR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'EINVAL{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'EIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'EISCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'EISDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'ELOOP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'EMFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'EMLINK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'EMSGSIZE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'ENAMETOOLONG{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'ENETDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'ENETRESET{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'ENETUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'ENFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'ENOBUFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'ENODEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'ENOENT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'ENOEXEC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'ENOLCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'ENOMEM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'ENOPROTOOPT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'ENOSPC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'ENOSYS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'ENOTCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'ENOTDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'ENOTEMPTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'ENOTSOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'ENOTTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'ECONNREFUSED{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'ECONNRESET{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'EDEADLK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'EDESTADDRREQ{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'EDOM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'EEXIST{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'EFAULT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'EFBIG{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'EHOSTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'EHOSTUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'EINPROGRESS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'EINTR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'EINVAL{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'EIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'EISCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'EISDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'ELOOP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'EMFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'EMLINK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'EMSGSIZE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'ENAMETOOLONG{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'ENETDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'ENETRESET{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'ENETUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'ENFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'ENOBUFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'ENODEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'ENOENT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'ENOEXEC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'ENOLCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'ENOMEM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'ENOPROTOOPT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'ENOSPC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'ENOSYS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'ENOTCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'ENOTDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'ENOTEMPTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'ENOTSOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'ENOTTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'ECONNRESET{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'EDEADLK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'EDESTADDRREQ{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'EDOM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'EEXIST{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'EFAULT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'EFBIG{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'EHOSTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'EHOSTUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'EINPROGRESS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'EINTR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'EINVAL{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'EIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'EISCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'EISDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'ELOOP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'EMFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'EMLINK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'EMSGSIZE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'ENAMETOOLONG{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'ENETDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'ENETRESET{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'ENETUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'ENFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'ENOBUFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'ENODEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'ENOENT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'ENOEXEC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'ENOLCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'ENOMEM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'ENOPROTOOPT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'ENOSPC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'ENOSYS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'ENOTCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'ENOTDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'ENOTEMPTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'ENOTSOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'ENOTTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'EDEADLK{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'EDESTADDRREQ{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'EDOM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'EEXIST{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'EFAULT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'EFBIG{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'EHOSTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'EHOSTUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'EINPROGRESS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'EINTR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'EINVAL{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'EIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'EISCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'EISDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'ELOOP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'EMFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'EMLINK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'EMSGSIZE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'ENAMETOOLONG{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'ENETDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'ENETRESET{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'ENETUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'ENFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'ENOBUFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'ENODEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'ENOENT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'ENOEXEC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'ENOLCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'ENOMEM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'ENOPROTOOPT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'ENOSPC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'ENOSYS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'ENOTCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'ENOTDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'ENOTEMPTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'ENOTSOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'ENOTTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDEADLK{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'EDESTADDRREQ{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'EDOM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'EEXIST{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'EFAULT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'EFBIG{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'EHOSTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'EHOSTUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'EINPROGRESS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'EINTR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'EINVAL{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'EIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'EISCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'EISDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'ELOOP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'EMFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'EMLINK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'EMSGSIZE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'ENAMETOOLONG{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'ENETDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'ENETRESET{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'ENETUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'ENFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'ENOBUFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'ENODEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'ENOENT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'ENOEXEC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'ENOLCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'ENOMEM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'ENOPROTOOPT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'ENOSPC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'ENOSYS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'ENOTCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'ENOTDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'ENOTEMPTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'ENOTSOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'ENOTTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'EDOM{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'EEXIST{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'EFAULT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'EFBIG{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'EHOSTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'EHOSTUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'EINPROGRESS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'EINTR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'EINVAL{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'EIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'EISCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'EISDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'ELOOP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'EMFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'EMLINK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'EMSGSIZE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'ENAMETOOLONG{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'ENETDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'ENETRESET{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'ENETUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'ENFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'ENOBUFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'ENODEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'ENOENT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'ENOEXEC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'ENOLCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'ENOMEM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'ENOPROTOOPT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'ENOSPC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'ENOSYS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'ENOTCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'ENOTDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'ENOTEMPTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'ENOTSOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'ENOTTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EDOM{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'EEXIST{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'EFAULT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'EFBIG{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'EHOSTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'EHOSTUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'EINPROGRESS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'EINTR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'EINVAL{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'EIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'EISCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'EISDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'ELOOP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'EMFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'EMLINK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'EMSGSIZE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'ENAMETOOLONG{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'ENETDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'ENETRESET{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'ENETUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'ENFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'ENOBUFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'ENODEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'ENOENT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'ENOEXEC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'ENOLCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'ENOMEM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'ENOPROTOOPT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'ENOSPC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'ENOSYS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'ENOTCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'ENOTDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'ENOTEMPTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'ENOTSOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'ENOTTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EEXIST{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'EFAULT{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'EFBIG{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'EHOSTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'EHOSTUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'EINPROGRESS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'EINTR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'EINVAL{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'EIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'EISCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'EISDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'ELOOP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'EMFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'EMLINK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'EMSGSIZE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'ENAMETOOLONG{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'ENETDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'ENETRESET{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'ENETUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'ENFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'ENOBUFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'ENODEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'ENOENT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'ENOEXEC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'ENOLCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'ENOMEM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'ENOPROTOOPT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'ENOSPC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'ENOSYS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'ENOTCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'ENOTDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'ENOTEMPTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'ENOTSOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'ENOTTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFAULT{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'EFBIG{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'EHOSTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'EHOSTUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'EINPROGRESS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'EINTR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'EINVAL{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'EIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'EISCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'EISDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'ELOOP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'EMFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'EMLINK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'EMSGSIZE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'ENAMETOOLONG{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'ENETDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'ENETRESET{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'ENETUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'ENFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'ENOBUFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'ENODEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'ENOENT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'ENOEXEC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'ENOLCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'ENOMEM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'ENOPROTOOPT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'ENOSPC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'ENOSYS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'ENOTCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'ENOTDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'ENOTEMPTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'ENOTSOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'ENOTTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EFBIG{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'EHOSTDOWN{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'EHOSTUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'EINPROGRESS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'EINTR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'EINVAL{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'EIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'EISCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'EISDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'ELOOP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'EMFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'EMLINK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'EMSGSIZE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'ENAMETOOLONG{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'ENETDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'ENETRESET{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'ENETUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'ENFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'ENOBUFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'ENODEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'ENOENT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'ENOEXEC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'ENOLCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'ENOMEM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'ENOPROTOOPT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'ENOSPC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'ENOSYS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'ENOTCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'ENOTDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'ENOTEMPTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'ENOTSOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'ENOTTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'EHOSTUNREACH{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), Lbl'Hash'EINPROGRESS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), Lbl'Hash'EINTR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), Lbl'Hash'EINVAL{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), Lbl'Hash'EIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), Lbl'Hash'EISCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), Lbl'Hash'EISDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), Lbl'Hash'ELOOP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), Lbl'Hash'EMFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), Lbl'Hash'EMLINK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), Lbl'Hash'EMSGSIZE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), Lbl'Hash'ENAMETOOLONG{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), Lbl'Hash'ENETDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), Lbl'Hash'ENETRESET{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), Lbl'Hash'ENETUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), Lbl'Hash'ENFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), Lbl'Hash'ENOBUFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), Lbl'Hash'ENODEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), Lbl'Hash'ENOENT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), Lbl'Hash'ENOEXEC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), Lbl'Hash'ENOLCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), Lbl'Hash'ENOMEM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), Lbl'Hash'ENOPROTOOPT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), Lbl'Hash'ENOSPC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), Lbl'Hash'ENOSYS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), Lbl'Hash'ENOTCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), Lbl'Hash'ENOTDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), Lbl'Hash'ENOTEMPTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), Lbl'Hash'ENOTSOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), Lbl'Hash'ENOTTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'EINPROGRESS{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINPROGRESS{}(), Lbl'Hash'EINTR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINPROGRESS{}(), Lbl'Hash'EINVAL{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINPROGRESS{}(), Lbl'Hash'EIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINPROGRESS{}(), Lbl'Hash'EISCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINPROGRESS{}(), Lbl'Hash'EISDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINPROGRESS{}(), Lbl'Hash'ELOOP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINPROGRESS{}(), Lbl'Hash'EMFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINPROGRESS{}(), Lbl'Hash'EMLINK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINPROGRESS{}(), Lbl'Hash'EMSGSIZE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINPROGRESS{}(), Lbl'Hash'ENAMETOOLONG{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINPROGRESS{}(), Lbl'Hash'ENETDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINPROGRESS{}(), Lbl'Hash'ENETRESET{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINPROGRESS{}(), Lbl'Hash'ENETUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINPROGRESS{}(), Lbl'Hash'ENFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINPROGRESS{}(), Lbl'Hash'ENOBUFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINPROGRESS{}(), Lbl'Hash'ENODEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINPROGRESS{}(), Lbl'Hash'ENOENT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINPROGRESS{}(), Lbl'Hash'ENOEXEC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINPROGRESS{}(), Lbl'Hash'ENOLCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINPROGRESS{}(), Lbl'Hash'ENOMEM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINPROGRESS{}(), Lbl'Hash'ENOPROTOOPT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINPROGRESS{}(), Lbl'Hash'ENOSPC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINPROGRESS{}(), Lbl'Hash'ENOSYS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINPROGRESS{}(), Lbl'Hash'ENOTCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINPROGRESS{}(), Lbl'Hash'ENOTDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINPROGRESS{}(), Lbl'Hash'ENOTEMPTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINPROGRESS{}(), Lbl'Hash'ENOTSOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINPROGRESS{}(), Lbl'Hash'ENOTTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINPROGRESS{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINPROGRESS{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINPROGRESS{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINPROGRESS{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINPROGRESS{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINPROGRESS{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINPROGRESS{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINPROGRESS{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINPROGRESS{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINPROGRESS{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINPROGRESS{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINPROGRESS{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINPROGRESS{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINPROGRESS{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINPROGRESS{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINPROGRESS{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINPROGRESS{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINPROGRESS{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINPROGRESS{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINPROGRESS{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'EINTR{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINTR{}(), Lbl'Hash'EINVAL{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINTR{}(), Lbl'Hash'EIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINTR{}(), Lbl'Hash'EISCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINTR{}(), Lbl'Hash'EISDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINTR{}(), Lbl'Hash'ELOOP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINTR{}(), Lbl'Hash'EMFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINTR{}(), Lbl'Hash'EMLINK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINTR{}(), Lbl'Hash'EMSGSIZE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINTR{}(), Lbl'Hash'ENAMETOOLONG{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINTR{}(), Lbl'Hash'ENETDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINTR{}(), Lbl'Hash'ENETRESET{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINTR{}(), Lbl'Hash'ENETUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINTR{}(), Lbl'Hash'ENFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINTR{}(), Lbl'Hash'ENOBUFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINTR{}(), Lbl'Hash'ENODEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINTR{}(), Lbl'Hash'ENOENT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINTR{}(), Lbl'Hash'ENOEXEC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINTR{}(), Lbl'Hash'ENOLCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINTR{}(), Lbl'Hash'ENOMEM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINTR{}(), Lbl'Hash'ENOPROTOOPT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINTR{}(), Lbl'Hash'ENOSPC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINTR{}(), Lbl'Hash'ENOSYS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINTR{}(), Lbl'Hash'ENOTCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINTR{}(), Lbl'Hash'ENOTDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINTR{}(), Lbl'Hash'ENOTEMPTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINTR{}(), Lbl'Hash'ENOTSOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINTR{}(), Lbl'Hash'ENOTTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINTR{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINTR{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINTR{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINTR{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINTR{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINTR{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINTR{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINTR{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINTR{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINTR{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINTR{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINTR{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINTR{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINTR{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINTR{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINTR{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINTR{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINTR{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINTR{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINTR{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'EINVAL{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINVAL{}(), Lbl'Hash'EIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINVAL{}(), Lbl'Hash'EISCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINVAL{}(), Lbl'Hash'EISDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINVAL{}(), Lbl'Hash'ELOOP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINVAL{}(), Lbl'Hash'EMFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINVAL{}(), Lbl'Hash'EMLINK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINVAL{}(), Lbl'Hash'EMSGSIZE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINVAL{}(), Lbl'Hash'ENAMETOOLONG{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINVAL{}(), Lbl'Hash'ENETDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINVAL{}(), Lbl'Hash'ENETRESET{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINVAL{}(), Lbl'Hash'ENETUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINVAL{}(), Lbl'Hash'ENFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINVAL{}(), Lbl'Hash'ENOBUFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINVAL{}(), Lbl'Hash'ENODEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINVAL{}(), Lbl'Hash'ENOENT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINVAL{}(), Lbl'Hash'ENOEXEC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINVAL{}(), Lbl'Hash'ENOLCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINVAL{}(), Lbl'Hash'ENOMEM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINVAL{}(), Lbl'Hash'ENOPROTOOPT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINVAL{}(), Lbl'Hash'ENOSPC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINVAL{}(), Lbl'Hash'ENOSYS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINVAL{}(), Lbl'Hash'ENOTCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINVAL{}(), Lbl'Hash'ENOTDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINVAL{}(), Lbl'Hash'ENOTEMPTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINVAL{}(), Lbl'Hash'ENOTSOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINVAL{}(), Lbl'Hash'ENOTTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINVAL{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINVAL{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINVAL{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINVAL{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINVAL{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINVAL{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINVAL{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINVAL{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINVAL{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINVAL{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINVAL{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINVAL{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINVAL{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINVAL{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINVAL{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINVAL{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINVAL{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINVAL{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINVAL{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EINVAL{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'EIO{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EIO{}(), Lbl'Hash'EISCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EIO{}(), Lbl'Hash'EISDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EIO{}(), Lbl'Hash'ELOOP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EIO{}(), Lbl'Hash'EMFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EIO{}(), Lbl'Hash'EMLINK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EIO{}(), Lbl'Hash'EMSGSIZE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EIO{}(), Lbl'Hash'ENAMETOOLONG{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EIO{}(), Lbl'Hash'ENETDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EIO{}(), Lbl'Hash'ENETRESET{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EIO{}(), Lbl'Hash'ENETUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EIO{}(), Lbl'Hash'ENFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EIO{}(), Lbl'Hash'ENOBUFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EIO{}(), Lbl'Hash'ENODEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EIO{}(), Lbl'Hash'ENOENT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EIO{}(), Lbl'Hash'ENOEXEC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EIO{}(), Lbl'Hash'ENOLCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EIO{}(), Lbl'Hash'ENOMEM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EIO{}(), Lbl'Hash'ENOPROTOOPT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EIO{}(), Lbl'Hash'ENOSPC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EIO{}(), Lbl'Hash'ENOSYS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EIO{}(), Lbl'Hash'ENOTCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EIO{}(), Lbl'Hash'ENOTDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EIO{}(), Lbl'Hash'ENOTEMPTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EIO{}(), Lbl'Hash'ENOTSOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EIO{}(), Lbl'Hash'ENOTTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EIO{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EIO{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EIO{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EIO{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EIO{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EIO{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EIO{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EIO{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EIO{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EIO{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EIO{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EIO{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EIO{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EIO{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EIO{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EIO{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EIO{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EIO{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EIO{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EIO{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'EISCONN{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISCONN{}(), Lbl'Hash'EISDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISCONN{}(), Lbl'Hash'ELOOP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISCONN{}(), Lbl'Hash'EMFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISCONN{}(), Lbl'Hash'EMLINK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISCONN{}(), Lbl'Hash'EMSGSIZE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISCONN{}(), Lbl'Hash'ENAMETOOLONG{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISCONN{}(), Lbl'Hash'ENETDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISCONN{}(), Lbl'Hash'ENETRESET{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISCONN{}(), Lbl'Hash'ENETUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISCONN{}(), Lbl'Hash'ENFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISCONN{}(), Lbl'Hash'ENOBUFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISCONN{}(), Lbl'Hash'ENODEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISCONN{}(), Lbl'Hash'ENOENT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISCONN{}(), Lbl'Hash'ENOEXEC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISCONN{}(), Lbl'Hash'ENOLCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISCONN{}(), Lbl'Hash'ENOMEM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISCONN{}(), Lbl'Hash'ENOPROTOOPT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISCONN{}(), Lbl'Hash'ENOSPC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISCONN{}(), Lbl'Hash'ENOSYS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISCONN{}(), Lbl'Hash'ENOTCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISCONN{}(), Lbl'Hash'ENOTDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISCONN{}(), Lbl'Hash'ENOTEMPTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISCONN{}(), Lbl'Hash'ENOTSOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISCONN{}(), Lbl'Hash'ENOTTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISCONN{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISCONN{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISCONN{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISCONN{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISCONN{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISCONN{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISCONN{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISCONN{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISCONN{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISCONN{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISCONN{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISCONN{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISCONN{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISCONN{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISCONN{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISCONN{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISCONN{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISCONN{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISCONN{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISCONN{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'EISDIR{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISDIR{}(), Lbl'Hash'ELOOP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISDIR{}(), Lbl'Hash'EMFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISDIR{}(), Lbl'Hash'EMLINK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISDIR{}(), Lbl'Hash'EMSGSIZE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISDIR{}(), Lbl'Hash'ENAMETOOLONG{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISDIR{}(), Lbl'Hash'ENETDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISDIR{}(), Lbl'Hash'ENETRESET{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISDIR{}(), Lbl'Hash'ENETUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISDIR{}(), Lbl'Hash'ENFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISDIR{}(), Lbl'Hash'ENOBUFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISDIR{}(), Lbl'Hash'ENODEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISDIR{}(), Lbl'Hash'ENOENT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISDIR{}(), Lbl'Hash'ENOEXEC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISDIR{}(), Lbl'Hash'ENOLCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISDIR{}(), Lbl'Hash'ENOMEM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISDIR{}(), Lbl'Hash'ENOPROTOOPT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISDIR{}(), Lbl'Hash'ENOSPC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISDIR{}(), Lbl'Hash'ENOSYS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISDIR{}(), Lbl'Hash'ENOTCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISDIR{}(), Lbl'Hash'ENOTDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISDIR{}(), Lbl'Hash'ENOTEMPTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISDIR{}(), Lbl'Hash'ENOTSOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISDIR{}(), Lbl'Hash'ENOTTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISDIR{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISDIR{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISDIR{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISDIR{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISDIR{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISDIR{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISDIR{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISDIR{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISDIR{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISDIR{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISDIR{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISDIR{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISDIR{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISDIR{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISDIR{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISDIR{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISDIR{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISDIR{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISDIR{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EISDIR{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'ELOOP{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ELOOP{}(), Lbl'Hash'EMFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ELOOP{}(), Lbl'Hash'EMLINK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ELOOP{}(), Lbl'Hash'EMSGSIZE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ELOOP{}(), Lbl'Hash'ENAMETOOLONG{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ELOOP{}(), Lbl'Hash'ENETDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ELOOP{}(), Lbl'Hash'ENETRESET{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ELOOP{}(), Lbl'Hash'ENETUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ELOOP{}(), Lbl'Hash'ENFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ELOOP{}(), Lbl'Hash'ENOBUFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ELOOP{}(), Lbl'Hash'ENODEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ELOOP{}(), Lbl'Hash'ENOENT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ELOOP{}(), Lbl'Hash'ENOEXEC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ELOOP{}(), Lbl'Hash'ENOLCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ELOOP{}(), Lbl'Hash'ENOMEM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ELOOP{}(), Lbl'Hash'ENOPROTOOPT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ELOOP{}(), Lbl'Hash'ENOSPC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ELOOP{}(), Lbl'Hash'ENOSYS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ELOOP{}(), Lbl'Hash'ENOTCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ELOOP{}(), Lbl'Hash'ENOTDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ELOOP{}(), Lbl'Hash'ENOTEMPTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ELOOP{}(), Lbl'Hash'ENOTSOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ELOOP{}(), Lbl'Hash'ENOTTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ELOOP{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ELOOP{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ELOOP{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ELOOP{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ELOOP{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ELOOP{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ELOOP{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ELOOP{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ELOOP{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ELOOP{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ELOOP{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ELOOP{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ELOOP{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ELOOP{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ELOOP{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ELOOP{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ELOOP{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ELOOP{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ELOOP{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ELOOP{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'EMFILE{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMFILE{}(), Lbl'Hash'EMLINK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMFILE{}(), Lbl'Hash'EMSGSIZE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMFILE{}(), Lbl'Hash'ENAMETOOLONG{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMFILE{}(), Lbl'Hash'ENETDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMFILE{}(), Lbl'Hash'ENETRESET{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMFILE{}(), Lbl'Hash'ENETUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMFILE{}(), Lbl'Hash'ENFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMFILE{}(), Lbl'Hash'ENOBUFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMFILE{}(), Lbl'Hash'ENODEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMFILE{}(), Lbl'Hash'ENOENT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMFILE{}(), Lbl'Hash'ENOEXEC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMFILE{}(), Lbl'Hash'ENOLCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMFILE{}(), Lbl'Hash'ENOMEM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMFILE{}(), Lbl'Hash'ENOPROTOOPT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMFILE{}(), Lbl'Hash'ENOSPC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMFILE{}(), Lbl'Hash'ENOSYS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMFILE{}(), Lbl'Hash'ENOTCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMFILE{}(), Lbl'Hash'ENOTDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMFILE{}(), Lbl'Hash'ENOTEMPTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMFILE{}(), Lbl'Hash'ENOTSOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMFILE{}(), Lbl'Hash'ENOTTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMFILE{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMFILE{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMFILE{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMFILE{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMFILE{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMFILE{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMFILE{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMFILE{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMFILE{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMFILE{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMFILE{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMFILE{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMFILE{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMFILE{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMFILE{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMFILE{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMFILE{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMFILE{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMFILE{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMFILE{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'EMLINK{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMLINK{}(), Lbl'Hash'EMSGSIZE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMLINK{}(), Lbl'Hash'ENAMETOOLONG{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMLINK{}(), Lbl'Hash'ENETDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMLINK{}(), Lbl'Hash'ENETRESET{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMLINK{}(), Lbl'Hash'ENETUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMLINK{}(), Lbl'Hash'ENFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMLINK{}(), Lbl'Hash'ENOBUFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMLINK{}(), Lbl'Hash'ENODEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMLINK{}(), Lbl'Hash'ENOENT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMLINK{}(), Lbl'Hash'ENOEXEC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMLINK{}(), Lbl'Hash'ENOLCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMLINK{}(), Lbl'Hash'ENOMEM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMLINK{}(), Lbl'Hash'ENOPROTOOPT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMLINK{}(), Lbl'Hash'ENOSPC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMLINK{}(), Lbl'Hash'ENOSYS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMLINK{}(), Lbl'Hash'ENOTCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMLINK{}(), Lbl'Hash'ENOTDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMLINK{}(), Lbl'Hash'ENOTEMPTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMLINK{}(), Lbl'Hash'ENOTSOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMLINK{}(), Lbl'Hash'ENOTTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMLINK{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMLINK{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMLINK{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMLINK{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMLINK{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMLINK{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMLINK{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMLINK{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMLINK{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMLINK{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMLINK{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMLINK{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMLINK{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMLINK{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMLINK{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMLINK{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMLINK{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMLINK{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMLINK{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMLINK{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'EMSGSIZE{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMSGSIZE{}(), Lbl'Hash'ENAMETOOLONG{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMSGSIZE{}(), Lbl'Hash'ENETDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMSGSIZE{}(), Lbl'Hash'ENETRESET{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMSGSIZE{}(), Lbl'Hash'ENETUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMSGSIZE{}(), Lbl'Hash'ENFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMSGSIZE{}(), Lbl'Hash'ENOBUFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMSGSIZE{}(), Lbl'Hash'ENODEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMSGSIZE{}(), Lbl'Hash'ENOENT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMSGSIZE{}(), Lbl'Hash'ENOEXEC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMSGSIZE{}(), Lbl'Hash'ENOLCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMSGSIZE{}(), Lbl'Hash'ENOMEM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMSGSIZE{}(), Lbl'Hash'ENOPROTOOPT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMSGSIZE{}(), Lbl'Hash'ENOSPC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMSGSIZE{}(), Lbl'Hash'ENOSYS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMSGSIZE{}(), Lbl'Hash'ENOTCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMSGSIZE{}(), Lbl'Hash'ENOTDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMSGSIZE{}(), Lbl'Hash'ENOTEMPTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMSGSIZE{}(), Lbl'Hash'ENOTSOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMSGSIZE{}(), Lbl'Hash'ENOTTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMSGSIZE{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMSGSIZE{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMSGSIZE{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMSGSIZE{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMSGSIZE{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMSGSIZE{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMSGSIZE{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMSGSIZE{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMSGSIZE{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMSGSIZE{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMSGSIZE{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMSGSIZE{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMSGSIZE{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMSGSIZE{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMSGSIZE{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMSGSIZE{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMSGSIZE{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMSGSIZE{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMSGSIZE{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EMSGSIZE{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'ENAMETOOLONG{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENAMETOOLONG{}(), Lbl'Hash'ENETDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENAMETOOLONG{}(), Lbl'Hash'ENETRESET{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENAMETOOLONG{}(), Lbl'Hash'ENETUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENAMETOOLONG{}(), Lbl'Hash'ENFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENAMETOOLONG{}(), Lbl'Hash'ENOBUFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENAMETOOLONG{}(), Lbl'Hash'ENODEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENAMETOOLONG{}(), Lbl'Hash'ENOENT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENAMETOOLONG{}(), Lbl'Hash'ENOEXEC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENAMETOOLONG{}(), Lbl'Hash'ENOLCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENAMETOOLONG{}(), Lbl'Hash'ENOMEM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENAMETOOLONG{}(), Lbl'Hash'ENOPROTOOPT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENAMETOOLONG{}(), Lbl'Hash'ENOSPC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENAMETOOLONG{}(), Lbl'Hash'ENOSYS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENAMETOOLONG{}(), Lbl'Hash'ENOTCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENAMETOOLONG{}(), Lbl'Hash'ENOTDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENAMETOOLONG{}(), Lbl'Hash'ENOTEMPTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENAMETOOLONG{}(), Lbl'Hash'ENOTSOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENAMETOOLONG{}(), Lbl'Hash'ENOTTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENAMETOOLONG{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENAMETOOLONG{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENAMETOOLONG{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENAMETOOLONG{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENAMETOOLONG{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENAMETOOLONG{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENAMETOOLONG{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENAMETOOLONG{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENAMETOOLONG{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENAMETOOLONG{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENAMETOOLONG{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENAMETOOLONG{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENAMETOOLONG{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENAMETOOLONG{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENAMETOOLONG{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENAMETOOLONG{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENAMETOOLONG{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENAMETOOLONG{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENAMETOOLONG{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENAMETOOLONG{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'ENETDOWN{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETDOWN{}(), Lbl'Hash'ENETRESET{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETDOWN{}(), Lbl'Hash'ENETUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETDOWN{}(), Lbl'Hash'ENFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETDOWN{}(), Lbl'Hash'ENOBUFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETDOWN{}(), Lbl'Hash'ENODEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETDOWN{}(), Lbl'Hash'ENOENT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETDOWN{}(), Lbl'Hash'ENOEXEC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETDOWN{}(), Lbl'Hash'ENOLCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETDOWN{}(), Lbl'Hash'ENOMEM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETDOWN{}(), Lbl'Hash'ENOPROTOOPT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETDOWN{}(), Lbl'Hash'ENOSPC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETDOWN{}(), Lbl'Hash'ENOSYS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETDOWN{}(), Lbl'Hash'ENOTCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETDOWN{}(), Lbl'Hash'ENOTDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETDOWN{}(), Lbl'Hash'ENOTEMPTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETDOWN{}(), Lbl'Hash'ENOTSOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETDOWN{}(), Lbl'Hash'ENOTTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETDOWN{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETDOWN{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETDOWN{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETDOWN{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETDOWN{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETDOWN{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETDOWN{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETDOWN{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETDOWN{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETDOWN{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETDOWN{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETDOWN{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETDOWN{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETDOWN{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETDOWN{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETDOWN{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETDOWN{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETDOWN{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETDOWN{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETDOWN{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'ENETRESET{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETRESET{}(), Lbl'Hash'ENETUNREACH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETRESET{}(), Lbl'Hash'ENFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETRESET{}(), Lbl'Hash'ENOBUFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETRESET{}(), Lbl'Hash'ENODEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETRESET{}(), Lbl'Hash'ENOENT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETRESET{}(), Lbl'Hash'ENOEXEC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETRESET{}(), Lbl'Hash'ENOLCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETRESET{}(), Lbl'Hash'ENOMEM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETRESET{}(), Lbl'Hash'ENOPROTOOPT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETRESET{}(), Lbl'Hash'ENOSPC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETRESET{}(), Lbl'Hash'ENOSYS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETRESET{}(), Lbl'Hash'ENOTCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETRESET{}(), Lbl'Hash'ENOTDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETRESET{}(), Lbl'Hash'ENOTEMPTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETRESET{}(), Lbl'Hash'ENOTSOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETRESET{}(), Lbl'Hash'ENOTTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETRESET{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETRESET{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETRESET{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETRESET{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETRESET{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETRESET{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETRESET{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETRESET{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETRESET{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETRESET{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETRESET{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETRESET{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETRESET{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETRESET{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETRESET{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETRESET{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETRESET{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETRESET{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETRESET{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETRESET{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'ENETUNREACH{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETUNREACH{}(), Lbl'Hash'ENFILE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETUNREACH{}(), Lbl'Hash'ENOBUFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETUNREACH{}(), Lbl'Hash'ENODEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETUNREACH{}(), Lbl'Hash'ENOENT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETUNREACH{}(), Lbl'Hash'ENOEXEC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETUNREACH{}(), Lbl'Hash'ENOLCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETUNREACH{}(), Lbl'Hash'ENOMEM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETUNREACH{}(), Lbl'Hash'ENOPROTOOPT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETUNREACH{}(), Lbl'Hash'ENOSPC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETUNREACH{}(), Lbl'Hash'ENOSYS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETUNREACH{}(), Lbl'Hash'ENOTCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETUNREACH{}(), Lbl'Hash'ENOTDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETUNREACH{}(), Lbl'Hash'ENOTEMPTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETUNREACH{}(), Lbl'Hash'ENOTSOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETUNREACH{}(), Lbl'Hash'ENOTTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETUNREACH{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETUNREACH{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETUNREACH{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETUNREACH{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETUNREACH{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETUNREACH{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETUNREACH{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETUNREACH{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETUNREACH{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETUNREACH{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETUNREACH{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETUNREACH{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETUNREACH{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETUNREACH{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETUNREACH{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETUNREACH{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETUNREACH{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETUNREACH{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETUNREACH{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENETUNREACH{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'ENFILE{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENFILE{}(), Lbl'Hash'ENOBUFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENFILE{}(), Lbl'Hash'ENODEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENFILE{}(), Lbl'Hash'ENOENT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENFILE{}(), Lbl'Hash'ENOEXEC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENFILE{}(), Lbl'Hash'ENOLCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENFILE{}(), Lbl'Hash'ENOMEM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENFILE{}(), Lbl'Hash'ENOPROTOOPT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENFILE{}(), Lbl'Hash'ENOSPC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENFILE{}(), Lbl'Hash'ENOSYS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENFILE{}(), Lbl'Hash'ENOTCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENFILE{}(), Lbl'Hash'ENOTDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENFILE{}(), Lbl'Hash'ENOTEMPTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENFILE{}(), Lbl'Hash'ENOTSOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENFILE{}(), Lbl'Hash'ENOTTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENFILE{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENFILE{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENFILE{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENFILE{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENFILE{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENFILE{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENFILE{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENFILE{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENFILE{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENFILE{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENFILE{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENFILE{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENFILE{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENFILE{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENFILE{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENFILE{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENFILE{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENFILE{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENFILE{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENFILE{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'ENOBUFS{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOBUFS{}(), Lbl'Hash'ENODEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOBUFS{}(), Lbl'Hash'ENOENT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOBUFS{}(), Lbl'Hash'ENOEXEC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOBUFS{}(), Lbl'Hash'ENOLCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOBUFS{}(), Lbl'Hash'ENOMEM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOBUFS{}(), Lbl'Hash'ENOPROTOOPT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOBUFS{}(), Lbl'Hash'ENOSPC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOBUFS{}(), Lbl'Hash'ENOSYS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOBUFS{}(), Lbl'Hash'ENOTCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOBUFS{}(), Lbl'Hash'ENOTDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOBUFS{}(), Lbl'Hash'ENOTEMPTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOBUFS{}(), Lbl'Hash'ENOTSOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOBUFS{}(), Lbl'Hash'ENOTTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOBUFS{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOBUFS{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOBUFS{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOBUFS{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOBUFS{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOBUFS{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOBUFS{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOBUFS{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOBUFS{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOBUFS{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOBUFS{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOBUFS{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOBUFS{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOBUFS{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOBUFS{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOBUFS{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOBUFS{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOBUFS{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOBUFS{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOBUFS{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'ENODEV{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENODEV{}(), Lbl'Hash'ENOENT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENODEV{}(), Lbl'Hash'ENOEXEC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENODEV{}(), Lbl'Hash'ENOLCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENODEV{}(), Lbl'Hash'ENOMEM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENODEV{}(), Lbl'Hash'ENOPROTOOPT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENODEV{}(), Lbl'Hash'ENOSPC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENODEV{}(), Lbl'Hash'ENOSYS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENODEV{}(), Lbl'Hash'ENOTCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENODEV{}(), Lbl'Hash'ENOTDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENODEV{}(), Lbl'Hash'ENOTEMPTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENODEV{}(), Lbl'Hash'ENOTSOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENODEV{}(), Lbl'Hash'ENOTTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENODEV{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENODEV{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENODEV{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENODEV{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENODEV{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENODEV{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENODEV{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENODEV{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENODEV{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENODEV{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENODEV{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENODEV{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENODEV{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENODEV{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENODEV{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENODEV{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENODEV{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENODEV{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENODEV{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENODEV{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'ENOENT{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOENT{}(), Lbl'Hash'ENOEXEC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOENT{}(), Lbl'Hash'ENOLCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOENT{}(), Lbl'Hash'ENOMEM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOENT{}(), Lbl'Hash'ENOPROTOOPT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOENT{}(), Lbl'Hash'ENOSPC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOENT{}(), Lbl'Hash'ENOSYS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOENT{}(), Lbl'Hash'ENOTCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOENT{}(), Lbl'Hash'ENOTDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOENT{}(), Lbl'Hash'ENOTEMPTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOENT{}(), Lbl'Hash'ENOTSOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOENT{}(), Lbl'Hash'ENOTTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOENT{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOENT{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOENT{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOENT{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOENT{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOENT{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOENT{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOENT{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOENT{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOENT{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOENT{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOENT{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOENT{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOENT{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOENT{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOENT{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOENT{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOENT{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOENT{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOENT{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'ENOEXEC{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOEXEC{}(), Lbl'Hash'ENOLCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOEXEC{}(), Lbl'Hash'ENOMEM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOEXEC{}(), Lbl'Hash'ENOPROTOOPT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOEXEC{}(), Lbl'Hash'ENOSPC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOEXEC{}(), Lbl'Hash'ENOSYS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOEXEC{}(), Lbl'Hash'ENOTCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOEXEC{}(), Lbl'Hash'ENOTDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOEXEC{}(), Lbl'Hash'ENOTEMPTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOEXEC{}(), Lbl'Hash'ENOTSOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOEXEC{}(), Lbl'Hash'ENOTTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOEXEC{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOEXEC{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOEXEC{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOEXEC{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOEXEC{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOEXEC{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOEXEC{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOEXEC{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOEXEC{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOEXEC{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOEXEC{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOEXEC{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOEXEC{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOEXEC{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOEXEC{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOEXEC{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOEXEC{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOEXEC{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOEXEC{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOEXEC{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'ENOLCK{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOLCK{}(), Lbl'Hash'ENOMEM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOLCK{}(), Lbl'Hash'ENOPROTOOPT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOLCK{}(), Lbl'Hash'ENOSPC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOLCK{}(), Lbl'Hash'ENOSYS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOLCK{}(), Lbl'Hash'ENOTCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOLCK{}(), Lbl'Hash'ENOTDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOLCK{}(), Lbl'Hash'ENOTEMPTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOLCK{}(), Lbl'Hash'ENOTSOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOLCK{}(), Lbl'Hash'ENOTTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOLCK{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOLCK{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOLCK{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOLCK{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOLCK{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOLCK{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOLCK{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOLCK{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOLCK{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOLCK{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOLCK{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOLCK{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOLCK{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOLCK{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOLCK{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOLCK{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOLCK{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOLCK{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOLCK{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOLCK{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'ENOMEM{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOMEM{}(), Lbl'Hash'ENOPROTOOPT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOMEM{}(), Lbl'Hash'ENOSPC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOMEM{}(), Lbl'Hash'ENOSYS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOMEM{}(), Lbl'Hash'ENOTCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOMEM{}(), Lbl'Hash'ENOTDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOMEM{}(), Lbl'Hash'ENOTEMPTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOMEM{}(), Lbl'Hash'ENOTSOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOMEM{}(), Lbl'Hash'ENOTTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOMEM{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOMEM{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOMEM{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOMEM{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOMEM{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOMEM{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOMEM{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOMEM{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOMEM{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOMEM{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOMEM{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOMEM{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOMEM{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOMEM{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOMEM{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOMEM{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOMEM{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOMEM{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOMEM{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOMEM{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'ENOPROTOOPT{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOPROTOOPT{}(), Lbl'Hash'ENOSPC{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOPROTOOPT{}(), Lbl'Hash'ENOSYS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOPROTOOPT{}(), Lbl'Hash'ENOTCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOPROTOOPT{}(), Lbl'Hash'ENOTDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOPROTOOPT{}(), Lbl'Hash'ENOTEMPTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOPROTOOPT{}(), Lbl'Hash'ENOTSOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOPROTOOPT{}(), Lbl'Hash'ENOTTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOPROTOOPT{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOPROTOOPT{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOPROTOOPT{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOPROTOOPT{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOPROTOOPT{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOPROTOOPT{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOPROTOOPT{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOPROTOOPT{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOPROTOOPT{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOPROTOOPT{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOPROTOOPT{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOPROTOOPT{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOPROTOOPT{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOPROTOOPT{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOPROTOOPT{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOPROTOOPT{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOPROTOOPT{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOPROTOOPT{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOPROTOOPT{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOPROTOOPT{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'ENOSPC{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSPC{}(), Lbl'Hash'ENOSYS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSPC{}(), Lbl'Hash'ENOTCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSPC{}(), Lbl'Hash'ENOTDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSPC{}(), Lbl'Hash'ENOTEMPTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSPC{}(), Lbl'Hash'ENOTSOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSPC{}(), Lbl'Hash'ENOTTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSPC{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSPC{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSPC{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSPC{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSPC{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSPC{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSPC{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSPC{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSPC{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSPC{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSPC{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSPC{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSPC{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSPC{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSPC{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSPC{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSPC{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSPC{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSPC{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSPC{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'ENOSYS{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSYS{}(), Lbl'Hash'ENOTCONN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSYS{}(), Lbl'Hash'ENOTDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSYS{}(), Lbl'Hash'ENOTEMPTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSYS{}(), Lbl'Hash'ENOTSOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSYS{}(), Lbl'Hash'ENOTTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSYS{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSYS{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSYS{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSYS{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSYS{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSYS{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSYS{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSYS{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSYS{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSYS{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSYS{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSYS{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSYS{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSYS{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSYS{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSYS{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSYS{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSYS{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSYS{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOSYS{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'ENOTCONN{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTCONN{}(), Lbl'Hash'ENOTDIR{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTCONN{}(), Lbl'Hash'ENOTEMPTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTCONN{}(), Lbl'Hash'ENOTSOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTCONN{}(), Lbl'Hash'ENOTTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTCONN{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTCONN{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTCONN{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTCONN{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTCONN{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTCONN{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTCONN{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTCONN{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTCONN{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTCONN{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTCONN{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTCONN{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTCONN{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTCONN{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTCONN{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTCONN{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTCONN{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTCONN{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTCONN{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTCONN{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'ENOTDIR{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTDIR{}(), Lbl'Hash'ENOTEMPTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTDIR{}(), Lbl'Hash'ENOTSOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTDIR{}(), Lbl'Hash'ENOTTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTDIR{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTDIR{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTDIR{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTDIR{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTDIR{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTDIR{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTDIR{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTDIR{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTDIR{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTDIR{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTDIR{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTDIR{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTDIR{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTDIR{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTDIR{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTDIR{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTDIR{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTDIR{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTDIR{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTDIR{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'ENOTEMPTY{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTEMPTY{}(), Lbl'Hash'ENOTSOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTEMPTY{}(), Lbl'Hash'ENOTTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTEMPTY{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTEMPTY{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTEMPTY{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTEMPTY{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTEMPTY{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTEMPTY{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTEMPTY{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTEMPTY{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTEMPTY{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTEMPTY{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTEMPTY{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTEMPTY{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTEMPTY{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTEMPTY{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTEMPTY{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTEMPTY{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTEMPTY{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTEMPTY{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTEMPTY{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTEMPTY{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'ENOTSOCK{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTSOCK{}(), Lbl'Hash'ENOTTY{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTSOCK{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTSOCK{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTSOCK{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTSOCK{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTSOCK{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTSOCK{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTSOCK{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTSOCK{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTSOCK{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTSOCK{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTSOCK{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTSOCK{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTSOCK{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTSOCK{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTSOCK{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTSOCK{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTSOCK{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTSOCK{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTSOCK{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTSOCK{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'ENOTTY{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTTY{}(), Lbl'Hash'ENXIO{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTTY{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTTY{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTTY{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTTY{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTTY{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTTY{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTTY{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTTY{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTTY{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTTY{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTTY{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTTY{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTTY{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTTY{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTTY{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTTY{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTTY{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTTY{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENOTTY{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'ENXIO{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENXIO{}(), Lbl'Hash'EOF{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENXIO{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENXIO{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENXIO{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENXIO{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENXIO{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENXIO{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENXIO{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENXIO{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENXIO{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENXIO{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENXIO{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENXIO{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENXIO{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENXIO{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENXIO{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENXIO{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENXIO{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ENXIO{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'EOF{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOF{}(), Lbl'Hash'EOPNOTSUPP{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOF{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOF{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOF{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOF{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOF{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOF{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOF{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOF{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOF{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOF{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOF{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOF{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOF{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOF{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOF{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOF{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOF{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'EOPNOTSUPP{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOPNOTSUPP{}(), Lbl'Hash'EOVERFLOW{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOPNOTSUPP{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOPNOTSUPP{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOPNOTSUPP{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOPNOTSUPP{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOPNOTSUPP{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOPNOTSUPP{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOPNOTSUPP{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOPNOTSUPP{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOPNOTSUPP{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOPNOTSUPP{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOPNOTSUPP{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOPNOTSUPP{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOPNOTSUPP{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOPNOTSUPP{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOPNOTSUPP{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOPNOTSUPP{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'EOVERFLOW{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOVERFLOW{}(), Lbl'Hash'EPERM{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOVERFLOW{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOVERFLOW{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOVERFLOW{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOVERFLOW{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOVERFLOW{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOVERFLOW{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOVERFLOW{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOVERFLOW{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOVERFLOW{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOVERFLOW{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOVERFLOW{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOVERFLOW{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOVERFLOW{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOVERFLOW{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EOVERFLOW{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'EPERM{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPERM{}(), Lbl'Hash'EPFNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPERM{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPERM{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPERM{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPERM{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPERM{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPERM{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPERM{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPERM{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPERM{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPERM{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPERM{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPERM{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPERM{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPERM{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'EPFNOSUPPORT{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPFNOSUPPORT{}(), Lbl'Hash'EPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPFNOSUPPORT{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPFNOSUPPORT{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPFNOSUPPORT{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPFNOSUPPORT{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPFNOSUPPORT{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPFNOSUPPORT{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPFNOSUPPORT{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPFNOSUPPORT{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPFNOSUPPORT{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPFNOSUPPORT{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPFNOSUPPORT{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPFNOSUPPORT{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPFNOSUPPORT{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'EPIPE{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPIPE{}(), Lbl'Hash'EPROTONOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPIPE{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPIPE{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPIPE{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPIPE{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPIPE{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPIPE{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPIPE{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPIPE{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPIPE{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPIPE{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPIPE{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPIPE{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'EPROTONOSUPPORT{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPROTONOSUPPORT{}(), Lbl'Hash'EPROTOTYPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPROTONOSUPPORT{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPROTONOSUPPORT{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPROTONOSUPPORT{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPROTONOSUPPORT{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPROTONOSUPPORT{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPROTONOSUPPORT{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPROTONOSUPPORT{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPROTONOSUPPORT{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPROTONOSUPPORT{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPROTONOSUPPORT{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPROTONOSUPPORT{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'EPROTOTYPE{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPROTOTYPE{}(), Lbl'Hash'ERANGE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPROTOTYPE{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPROTOTYPE{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPROTOTYPE{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPROTOTYPE{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPROTOTYPE{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPROTOTYPE{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPROTOTYPE{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPROTOTYPE{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPROTOTYPE{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EPROTOTYPE{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'ERANGE{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ERANGE{}(), Lbl'Hash'EROFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ERANGE{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ERANGE{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ERANGE{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ERANGE{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ERANGE{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ERANGE{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ERANGE{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ERANGE{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ERANGE{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'EROFS{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EROFS{}(), Lbl'Hash'ESHUTDOWN{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EROFS{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EROFS{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EROFS{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EROFS{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EROFS{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EROFS{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EROFS{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EROFS{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'ESHUTDOWN{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ESHUTDOWN{}(), Lbl'Hash'ESOCKTNOSUPPORT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ESHUTDOWN{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ESHUTDOWN{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ESHUTDOWN{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ESHUTDOWN{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ESHUTDOWN{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ESHUTDOWN{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ESHUTDOWN{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'ESOCKTNOSUPPORT{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ESOCKTNOSUPPORT{}(), Lbl'Hash'ESPIPE{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ESOCKTNOSUPPORT{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ESOCKTNOSUPPORT{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ESOCKTNOSUPPORT{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ESOCKTNOSUPPORT{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ESOCKTNOSUPPORT{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ESOCKTNOSUPPORT{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'ESPIPE{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ESPIPE{}(), Lbl'Hash'ESRCH{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ESPIPE{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ESPIPE{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ESPIPE{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ESPIPE{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ESPIPE{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'ESRCH{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ESRCH{}(), Lbl'Hash'ETIMEDOUT{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ESRCH{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ESRCH{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ESRCH{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ESRCH{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'ETIMEDOUT{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ETIMEDOUT{}(), Lbl'Hash'ETOOMANYREFS{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ETIMEDOUT{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ETIMEDOUT{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ETIMEDOUT{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'ETOOMANYREFS{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ETOOMANYREFS{}(), Lbl'Hash'EWOULDBLOCK{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ETOOMANYREFS{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'ETOOMANYREFS{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'EWOULDBLOCK{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EWOULDBLOCK{}(), Lbl'Hash'EXDEV{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EWOULDBLOCK{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'EXDEV{}())) [functional{}()] // functional
  axiom{}\not{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'EXDEV{}(), Lbl'Hash'unknownIOError{}(Y0:SortInt{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortStream{}, \equals{SortStream{}, R} (Val:SortStream{}, Lbl'Hash'buffer'LParUndsRParUnds'K-IO'Unds'Stream'Unds'K{}(K0:SortK{}))) [functional{}()] // functional
  axiom{}\implies{SortStream{}} (\and{SortStream{}} (Lbl'Hash'buffer'LParUndsRParUnds'K-IO'Unds'Stream'Unds'K{}(X0:SortK{}), Lbl'Hash'buffer'LParUndsRParUnds'K-IO'Unds'Stream'Unds'K{}(Y0:SortK{})), Lbl'Hash'buffer'LParUndsRParUnds'K-IO'Unds'Stream'Unds'K{}(\and{SortK{}} (X0:SortK{}, Y0:SortK{}))) [constructor{}()] // no confusion same constructor
  axiom{R, SortSort} \exists{R} (Val:SortSort, \equals{SortSort, R} (Val:SortSort, Lbl'Hash'if'UndsHash'then'UndsHash'else'UndsHash'fi'Unds'K-EQUAL-SYNTAX'Unds'Sort'Unds'Bool'Unds'Sort'Unds'Sort{SortSort}(K0:SortBool{}, K1:SortSort, K2:SortSort))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortK{}, \equals{SortK{}, R} (Val:SortK{}, Lbl'Hash'logToFile{}(K0:SortString{}, K1:SortString{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortK{}, \equals{SortK{}, R} (Val:SortK{}, Lbl'Hash'remove'LParUndsRParUnds'K-IO'Unds'K'Unds'String{}(K0:SortString{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortInt{}, \equals{SortInt{}, R} (Val:SortInt{}, Lbl'Hash'stderr'Unds'K-IO'Unds'Int{}())) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortInt{}, \equals{SortInt{}, R} (Val:SortInt{}, Lbl'Hash'stdin'Unds'K-IO'Unds'Int{}())) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortInt{}, \equals{SortInt{}, R} (Val:SortInt{}, Lbl'Hash'stdout'Unds'K-IO'Unds'Int{}())) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, Lbl'Hash'systemResult{}(K0:SortInt{}, K1:SortString{}, K2:SortString{}))) [functional{}()] // functional
  axiom{}\implies{SortKItem{}} (\and{SortKItem{}} (Lbl'Hash'systemResult{}(X0:SortInt{}, X1:SortString{}, X2:SortString{}), Lbl'Hash'systemResult{}(Y0:SortInt{}, Y1:SortString{}, Y2:SortString{})), Lbl'Hash'systemResult{}(\and{SortInt{}} (X0:SortInt{}, Y0:SortInt{}), \and{SortString{}} (X1:SortString{}, Y1:SortString{}), \and{SortString{}} (X2:SortString{}, Y2:SortString{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortIOFile{}, \equals{SortIOFile{}, R} (Val:SortIOFile{}, Lbl'Hash'tempFile{}(K0:SortString{}, K1:SortInt{}))) [functional{}()] // functional
  axiom{}\implies{SortIOFile{}} (\and{SortIOFile{}} (Lbl'Hash'tempFile{}(X0:SortString{}, X1:SortInt{}), Lbl'Hash'tempFile{}(Y0:SortString{}, Y1:SortInt{})), Lbl'Hash'tempFile{}(\and{SortString{}} (X0:SortString{}, Y0:SortString{}), \and{SortInt{}} (X1:SortInt{}, Y1:SortInt{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortIOError{}, \equals{SortIOError{}, R} (Val:SortIOError{}, Lbl'Hash'unknownIOError{}(K0:SortInt{}))) [functional{}()] // functional
  axiom{}\implies{SortIOError{}} (\and{SortIOError{}} (Lbl'Hash'unknownIOError{}(X0:SortInt{}), Lbl'Hash'unknownIOError{}(Y0:SortInt{})), Lbl'Hash'unknownIOError{}(\and{SortInt{}} (X0:SortInt{}, Y0:SortInt{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortAssignmentOperator{}, \equals{SortAssignmentOperator{}, R} (Val:SortAssignmentOperator{}, Lbl'PercEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}())) [functional{}()] // functional
  axiom{}\not{SortAssignmentOperator{}} (\and{SortAssignmentOperator{}} (Lbl'PercEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}(), Lbl'And-EqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortAssignmentOperator{}} (\and{SortAssignmentOperator{}} (Lbl'PercEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}(), Lbl'StarEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortAssignmentOperator{}} (\and{SortAssignmentOperator{}} (Lbl'PercEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}(), Lbl'PlusEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortAssignmentOperator{}} (\and{SortAssignmentOperator{}} (Lbl'PercEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}(), Lbl'SlshEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortAssignmentOperator{}} (\and{SortAssignmentOperator{}} (Lbl'PercEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}(), Lbl'EqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortAssignmentOperator{}} (\and{SortAssignmentOperator{}} (Lbl'PercEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}(), LblOf'EqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortAssignmentOperator{}} (\and{SortAssignmentOperator{}} (Lbl'PercEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}(), Lbl'Xor-EqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortAssignmentOperator{}} (\and{SortAssignmentOperator{}} (Lbl'PercEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}(), Lbl'PipeEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortAssignmentOperator{}, \equals{SortAssignmentOperator{}, R} (Val:SortAssignmentOperator{}, Lbl'And-EqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}())) [functional{}()] // functional
  axiom{}\not{SortAssignmentOperator{}} (\and{SortAssignmentOperator{}} (Lbl'And-EqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}(), Lbl'StarEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortAssignmentOperator{}} (\and{SortAssignmentOperator{}} (Lbl'And-EqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}(), Lbl'PlusEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortAssignmentOperator{}} (\and{SortAssignmentOperator{}} (Lbl'And-EqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}(), Lbl'SlshEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortAssignmentOperator{}} (\and{SortAssignmentOperator{}} (Lbl'And-EqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}(), Lbl'EqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortAssignmentOperator{}} (\and{SortAssignmentOperator{}} (Lbl'And-EqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}(), LblOf'EqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortAssignmentOperator{}} (\and{SortAssignmentOperator{}} (Lbl'And-EqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}(), Lbl'Xor-EqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortAssignmentOperator{}} (\and{SortAssignmentOperator{}} (Lbl'And-EqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}(), Lbl'PipeEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortUnaryOperator{}, \equals{SortUnaryOperator{}, R} (Val:SortUnaryOperator{}, Lbl'And-Unds'C-SYNTAX'Unds'UnaryOperator{}())) [functional{}()] // functional
  axiom{}\not{SortUnaryOperator{}} (\and{SortUnaryOperator{}} (Lbl'And-Unds'C-SYNTAX'Unds'UnaryOperator{}(), Lbl'StarUnds'C-SYNTAX'Unds'UnaryOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortUnaryOperator{}} (\and{SortUnaryOperator{}} (Lbl'And-Unds'C-SYNTAX'Unds'UnaryOperator{}(), Lbl'PlusUnds'C-SYNTAX'Unds'UnaryOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortUnaryOperator{}} (\and{SortUnaryOperator{}} (Lbl'And-Unds'C-SYNTAX'Unds'UnaryOperator{}(), Lbl-'Unds'C-SYNTAX'Unds'UnaryOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortUnaryOperator{}} (\and{SortUnaryOperator{}} (Lbl'And-Unds'C-SYNTAX'Unds'UnaryOperator{}(), Lbl'TildUnds'C-SYNTAX'Unds'UnaryOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortDirectAbstractDeclarator{}, \equals{SortDirectAbstractDeclarator{}, R} (Val:SortDirectAbstractDeclarator{}, Lbl'LParRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator{}())) [functional{}()] // functional
  axiom{}\not{SortDirectAbstractDeclarator{}} (\and{SortDirectAbstractDeclarator{}} (Lbl'LParRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator{}(), Lbl'LParUndsRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'AbstractDeclarator{}(Y0:SortAbstractDeclarator{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortDirectAbstractDeclarator{}} (\and{SortDirectAbstractDeclarator{}} (Lbl'LParRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator{}(), Lbl'LParUndsRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'ParameterTypeList{}(Y0:SortParameterTypeList{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortDirectAbstractDeclarator{}} (\and{SortDirectAbstractDeclarator{}} (Lbl'LParRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator{}(), Lbl'LSqBRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortDirectAbstractDeclarator{}} (\and{SortDirectAbstractDeclarator{}} (Lbl'LParRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator{}(), Lbl'LSqBUndsRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'ConstantExpression{}(Y0:SortConstantExpression{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortDirectAbstractDeclarator{}} (\and{SortDirectAbstractDeclarator{}} (Lbl'LParRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator{}(), Lbl'UndsLParRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator{}(Y0:SortDirectAbstractDeclarator{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortDirectAbstractDeclarator{}} (\and{SortDirectAbstractDeclarator{}} (Lbl'LParRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator{}(), Lbl'UndsLParUndsRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator'Unds'ParameterTypeList{}(Y0:SortDirectAbstractDeclarator{}, Y1:SortParameterTypeList{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortDirectAbstractDeclarator{}} (\and{SortDirectAbstractDeclarator{}} (Lbl'LParRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator{}(), Lbl'UndsLSqBRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator{}(Y0:SortDirectAbstractDeclarator{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortDirectAbstractDeclarator{}} (\and{SortDirectAbstractDeclarator{}} (Lbl'LParRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator{}(), Lbl'UndsLSqBUndsRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator'Unds'ConstantExpression{}(Y0:SortDirectAbstractDeclarator{}, Y1:SortConstantExpression{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortDirectAbstractDeclarator{}, \equals{SortDirectAbstractDeclarator{}, R} (Val:SortDirectAbstractDeclarator{}, Lbl'LParUndsRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'AbstractDeclarator{}(K0:SortAbstractDeclarator{}))) [functional{}()] // functional
  axiom{}\implies{SortDirectAbstractDeclarator{}} (\and{SortDirectAbstractDeclarator{}} (Lbl'LParUndsRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'AbstractDeclarator{}(X0:SortAbstractDeclarator{}), Lbl'LParUndsRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'AbstractDeclarator{}(Y0:SortAbstractDeclarator{})), Lbl'LParUndsRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'AbstractDeclarator{}(\and{SortAbstractDeclarator{}} (X0:SortAbstractDeclarator{}, Y0:SortAbstractDeclarator{}))) [constructor{}()] // no confusion same constructor
  axiom{}\not{SortDirectAbstractDeclarator{}} (\and{SortDirectAbstractDeclarator{}} (Lbl'LParUndsRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'AbstractDeclarator{}(X0:SortAbstractDeclarator{}), Lbl'LParUndsRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'ParameterTypeList{}(Y0:SortParameterTypeList{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortDirectAbstractDeclarator{}} (\and{SortDirectAbstractDeclarator{}} (Lbl'LParUndsRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'AbstractDeclarator{}(X0:SortAbstractDeclarator{}), Lbl'LSqBRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortDirectAbstractDeclarator{}} (\and{SortDirectAbstractDeclarator{}} (Lbl'LParUndsRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'AbstractDeclarator{}(X0:SortAbstractDeclarator{}), Lbl'LSqBUndsRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'ConstantExpression{}(Y0:SortConstantExpression{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortDirectAbstractDeclarator{}} (\and{SortDirectAbstractDeclarator{}} (Lbl'LParUndsRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'AbstractDeclarator{}(X0:SortAbstractDeclarator{}), Lbl'UndsLParRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator{}(Y0:SortDirectAbstractDeclarator{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortDirectAbstractDeclarator{}} (\and{SortDirectAbstractDeclarator{}} (Lbl'LParUndsRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'AbstractDeclarator{}(X0:SortAbstractDeclarator{}), Lbl'UndsLParUndsRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator'Unds'ParameterTypeList{}(Y0:SortDirectAbstractDeclarator{}, Y1:SortParameterTypeList{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortDirectAbstractDeclarator{}} (\and{SortDirectAbstractDeclarator{}} (Lbl'LParUndsRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'AbstractDeclarator{}(X0:SortAbstractDeclarator{}), Lbl'UndsLSqBRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator{}(Y0:SortDirectAbstractDeclarator{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortDirectAbstractDeclarator{}} (\and{SortDirectAbstractDeclarator{}} (Lbl'LParUndsRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'AbstractDeclarator{}(X0:SortAbstractDeclarator{}), Lbl'UndsLSqBUndsRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator'Unds'ConstantExpression{}(Y0:SortDirectAbstractDeclarator{}, Y1:SortConstantExpression{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortDirectAbstractDeclarator{}, \equals{SortDirectAbstractDeclarator{}, R} (Val:SortDirectAbstractDeclarator{}, Lbl'LParUndsRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'ParameterTypeList{}(K0:SortParameterTypeList{}))) [functional{}()] // functional
  axiom{}\implies{SortDirectAbstractDeclarator{}} (\and{SortDirectAbstractDeclarator{}} (Lbl'LParUndsRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'ParameterTypeList{}(X0:SortParameterTypeList{}), Lbl'LParUndsRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'ParameterTypeList{}(Y0:SortParameterTypeList{})), Lbl'LParUndsRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'ParameterTypeList{}(\and{SortParameterTypeList{}} (X0:SortParameterTypeList{}, Y0:SortParameterTypeList{}))) [constructor{}()] // no confusion same constructor
  axiom{}\not{SortDirectAbstractDeclarator{}} (\and{SortDirectAbstractDeclarator{}} (Lbl'LParUndsRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'ParameterTypeList{}(X0:SortParameterTypeList{}), Lbl'LSqBRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortDirectAbstractDeclarator{}} (\and{SortDirectAbstractDeclarator{}} (Lbl'LParUndsRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'ParameterTypeList{}(X0:SortParameterTypeList{}), Lbl'LSqBUndsRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'ConstantExpression{}(Y0:SortConstantExpression{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortDirectAbstractDeclarator{}} (\and{SortDirectAbstractDeclarator{}} (Lbl'LParUndsRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'ParameterTypeList{}(X0:SortParameterTypeList{}), Lbl'UndsLParRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator{}(Y0:SortDirectAbstractDeclarator{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortDirectAbstractDeclarator{}} (\and{SortDirectAbstractDeclarator{}} (Lbl'LParUndsRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'ParameterTypeList{}(X0:SortParameterTypeList{}), Lbl'UndsLParUndsRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator'Unds'ParameterTypeList{}(Y0:SortDirectAbstractDeclarator{}, Y1:SortParameterTypeList{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortDirectAbstractDeclarator{}} (\and{SortDirectAbstractDeclarator{}} (Lbl'LParUndsRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'ParameterTypeList{}(X0:SortParameterTypeList{}), Lbl'UndsLSqBRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator{}(Y0:SortDirectAbstractDeclarator{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortDirectAbstractDeclarator{}} (\and{SortDirectAbstractDeclarator{}} (Lbl'LParUndsRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'ParameterTypeList{}(X0:SortParameterTypeList{}), Lbl'UndsLSqBUndsRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator'Unds'ConstantExpression{}(Y0:SortDirectAbstractDeclarator{}, Y1:SortConstantExpression{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortDirectDeclarator{}, \equals{SortDirectDeclarator{}, R} (Val:SortDirectDeclarator{}, Lbl'LParUndsRParUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'Declarator{}(K0:SortDeclarator{}))) [functional{}()] // functional
  axiom{}\implies{SortDirectDeclarator{}} (\and{SortDirectDeclarator{}} (Lbl'LParUndsRParUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'Declarator{}(X0:SortDeclarator{}), Lbl'LParUndsRParUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'Declarator{}(Y0:SortDeclarator{})), Lbl'LParUndsRParUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'Declarator{}(\and{SortDeclarator{}} (X0:SortDeclarator{}, Y0:SortDeclarator{}))) [constructor{}()] // no confusion same constructor
  axiom{}\not{SortDirectDeclarator{}} (\and{SortDirectDeclarator{}} (Lbl'LParUndsRParUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'Declarator{}(X0:SortDeclarator{}), Lbl'UndsLParUndsRParUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'DirectDeclarator'Unds'Ids{}(Y0:SortDirectDeclarator{}, Y1:SortIds{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortDirectDeclarator{}} (\and{SortDirectDeclarator{}} (Lbl'LParUndsRParUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'Declarator{}(X0:SortDeclarator{}), Lbl'UndsLParUndsRParUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'DirectDeclarator'Unds'ParameterTypeList{}(Y0:SortDirectDeclarator{}, Y1:SortParameterTypeList{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortDirectDeclarator{}} (\and{SortDirectDeclarator{}} (Lbl'LParUndsRParUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'Declarator{}(X0:SortDeclarator{}), Lbl'UndsLSqBRSqBUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'DirectDeclarator{}(Y0:SortDirectDeclarator{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortDirectDeclarator{}} (\and{SortDirectDeclarator{}} (Lbl'LParUndsRParUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'Declarator{}(X0:SortDeclarator{}), Lbl'UndsLSqBUndsRSqBUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'DirectDeclarator'Unds'ConstantExpression{}(Y0:SortDirectDeclarator{}, Y1:SortConstantExpression{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortPrimaryExpression{}, \equals{SortPrimaryExpression{}, R} (Val:SortPrimaryExpression{}, Lbl'LParUndsRParUnds'C-SYNTAX'Unds'PrimaryExpression'Unds'Expression{}(K0:SortExpression{}))) [functional{}()] // functional
  axiom{}\implies{SortPrimaryExpression{}} (\and{SortPrimaryExpression{}} (Lbl'LParUndsRParUnds'C-SYNTAX'Unds'PrimaryExpression'Unds'Expression{}(X0:SortExpression{}), Lbl'LParUndsRParUnds'C-SYNTAX'Unds'PrimaryExpression'Unds'Expression{}(Y0:SortExpression{})), Lbl'LParUndsRParUnds'C-SYNTAX'Unds'PrimaryExpression'Unds'Expression{}(\and{SortExpression{}} (X0:SortExpression{}, Y0:SortExpression{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortCastExpression{}, \equals{SortCastExpression{}, R} (Val:SortCastExpression{}, Lbl'LParUndsRParUndsUnds'C-SYNTAX'Unds'CastExpression'Unds'TypeName'Unds'CastExpression{}(K0:SortTypeName{}, K1:SortCastExpression{}))) [functional{}()] // functional
  axiom{}\implies{SortCastExpression{}} (\and{SortCastExpression{}} (Lbl'LParUndsRParUndsUnds'C-SYNTAX'Unds'CastExpression'Unds'TypeName'Unds'CastExpression{}(X0:SortTypeName{}, X1:SortCastExpression{}), Lbl'LParUndsRParUndsUnds'C-SYNTAX'Unds'CastExpression'Unds'TypeName'Unds'CastExpression{}(Y0:SortTypeName{}, Y1:SortCastExpression{})), Lbl'LParUndsRParUndsUnds'C-SYNTAX'Unds'CastExpression'Unds'TypeName'Unds'CastExpression{}(\and{SortTypeName{}} (X0:SortTypeName{}, Y0:SortTypeName{}), \and{SortCastExpression{}} (X1:SortCastExpression{}, Y1:SortCastExpression{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortAssignmentOperator{}, \equals{SortAssignmentOperator{}, R} (Val:SortAssignmentOperator{}, Lbl'StarEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}())) [functional{}()] // functional
  axiom{}\not{SortAssignmentOperator{}} (\and{SortAssignmentOperator{}} (Lbl'StarEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}(), Lbl'PlusEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortAssignmentOperator{}} (\and{SortAssignmentOperator{}} (Lbl'StarEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}(), Lbl'SlshEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortAssignmentOperator{}} (\and{SortAssignmentOperator{}} (Lbl'StarEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}(), Lbl'EqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortAssignmentOperator{}} (\and{SortAssignmentOperator{}} (Lbl'StarEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}(), LblOf'EqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortAssignmentOperator{}} (\and{SortAssignmentOperator{}} (Lbl'StarEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}(), Lbl'Xor-EqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortAssignmentOperator{}} (\and{SortAssignmentOperator{}} (Lbl'StarEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}(), Lbl'PipeEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortUnaryOperator{}, \equals{SortUnaryOperator{}, R} (Val:SortUnaryOperator{}, Lbl'StarUnds'C-SYNTAX'Unds'UnaryOperator{}())) [functional{}()] // functional
  axiom{}\not{SortUnaryOperator{}} (\and{SortUnaryOperator{}} (Lbl'StarUnds'C-SYNTAX'Unds'UnaryOperator{}(), Lbl'PlusUnds'C-SYNTAX'Unds'UnaryOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortUnaryOperator{}} (\and{SortUnaryOperator{}} (Lbl'StarUnds'C-SYNTAX'Unds'UnaryOperator{}(), Lbl-'Unds'C-SYNTAX'Unds'UnaryOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortUnaryOperator{}} (\and{SortUnaryOperator{}} (Lbl'StarUnds'C-SYNTAX'Unds'UnaryOperator{}(), Lbl'TildUnds'C-SYNTAX'Unds'UnaryOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortPointer{}, \equals{SortPointer{}, R} (Val:SortPointer{}, Lbl'StarUndsUnds'C-SYNTAX'Unds'Pointer'Unds'ListTypeQualifier{}(K0:SortListTypeQualifier{}))) [functional{}()] // functional
  axiom{}\implies{SortPointer{}} (\and{SortPointer{}} (Lbl'StarUndsUnds'C-SYNTAX'Unds'Pointer'Unds'ListTypeQualifier{}(X0:SortListTypeQualifier{}), Lbl'StarUndsUnds'C-SYNTAX'Unds'Pointer'Unds'ListTypeQualifier{}(Y0:SortListTypeQualifier{})), Lbl'StarUndsUnds'C-SYNTAX'Unds'Pointer'Unds'ListTypeQualifier{}(\and{SortListTypeQualifier{}} (X0:SortListTypeQualifier{}, Y0:SortListTypeQualifier{}))) [constructor{}()] // no confusion same constructor
  axiom{}\not{SortPointer{}} (\and{SortPointer{}} (Lbl'StarUndsUnds'C-SYNTAX'Unds'Pointer'Unds'ListTypeQualifier{}(X0:SortListTypeQualifier{}), Lbl'StarUndsUndsUnds'C-SYNTAX'Unds'Pointer'Unds'ListTypeQualifier'Unds'Pointer{}(Y0:SortListTypeQualifier{}, Y1:SortPointer{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortPointer{}, \equals{SortPointer{}, R} (Val:SortPointer{}, Lbl'StarUndsUndsUnds'C-SYNTAX'Unds'Pointer'Unds'ListTypeQualifier'Unds'Pointer{}(K0:SortListTypeQualifier{}, K1:SortPointer{}))) [functional{}()] // functional
  axiom{}\implies{SortPointer{}} (\and{SortPointer{}} (Lbl'StarUndsUndsUnds'C-SYNTAX'Unds'Pointer'Unds'ListTypeQualifier'Unds'Pointer{}(X0:SortListTypeQualifier{}, X1:SortPointer{}), Lbl'StarUndsUndsUnds'C-SYNTAX'Unds'Pointer'Unds'ListTypeQualifier'Unds'Pointer{}(Y0:SortListTypeQualifier{}, Y1:SortPointer{})), Lbl'StarUndsUndsUnds'C-SYNTAX'Unds'Pointer'Unds'ListTypeQualifier'Unds'Pointer{}(\and{SortListTypeQualifier{}} (X0:SortListTypeQualifier{}, Y0:SortListTypeQualifier{}), \and{SortPointer{}} (X1:SortPointer{}, Y1:SortPointer{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortUnaryExpression{}, \equals{SortUnaryExpression{}, R} (Val:SortUnaryExpression{}, Lbl'PlusPlusUndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'UnaryExpression{}(K0:SortUnaryExpression{}))) [functional{}()] // functional
  axiom{}\implies{SortUnaryExpression{}} (\and{SortUnaryExpression{}} (Lbl'PlusPlusUndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'UnaryExpression{}(X0:SortUnaryExpression{}), Lbl'PlusPlusUndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'UnaryExpression{}(Y0:SortUnaryExpression{})), Lbl'PlusPlusUndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'UnaryExpression{}(\and{SortUnaryExpression{}} (X0:SortUnaryExpression{}, Y0:SortUnaryExpression{}))) [constructor{}()] // no confusion same constructor
  axiom{}\not{SortUnaryExpression{}} (\and{SortUnaryExpression{}} (Lbl'PlusPlusUndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'UnaryExpression{}(X0:SortUnaryExpression{}), Lbl--'UndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'UnaryExpression{}(Y0:SortUnaryExpression{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortUnaryExpression{}} (\and{SortUnaryExpression{}} (Lbl'PlusPlusUndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'UnaryExpression{}(X0:SortUnaryExpression{}), Lbl'UndsUndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'UnaryOperator'Unds'CastExpression{}(Y0:SortUnaryOperator{}, Y1:SortCastExpression{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortUnaryExpression{}} (\and{SortUnaryExpression{}} (Lbl'PlusPlusUndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'UnaryExpression{}(X0:SortUnaryExpression{}), Lblsizeof'UndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'TypeName{}(Y0:SortTypeName{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortUnaryExpression{}} (\and{SortUnaryExpression{}} (Lbl'PlusPlusUndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'UnaryExpression{}(X0:SortUnaryExpression{}), Lblsizeof'UndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'UnaryExpression{}(Y0:SortUnaryExpression{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortAssignmentOperator{}, \equals{SortAssignmentOperator{}, R} (Val:SortAssignmentOperator{}, Lbl'PlusEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}())) [functional{}()] // functional
  axiom{}\not{SortAssignmentOperator{}} (\and{SortAssignmentOperator{}} (Lbl'PlusEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}(), Lbl'SlshEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortAssignmentOperator{}} (\and{SortAssignmentOperator{}} (Lbl'PlusEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}(), Lbl'EqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortAssignmentOperator{}} (\and{SortAssignmentOperator{}} (Lbl'PlusEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}(), LblOf'EqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortAssignmentOperator{}} (\and{SortAssignmentOperator{}} (Lbl'PlusEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}(), Lbl'Xor-EqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortAssignmentOperator{}} (\and{SortAssignmentOperator{}} (Lbl'PlusEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}(), Lbl'PipeEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortUnaryOperator{}, \equals{SortUnaryOperator{}, R} (Val:SortUnaryOperator{}, Lbl'PlusUnds'C-SYNTAX'Unds'UnaryOperator{}())) [functional{}()] // functional
  axiom{}\not{SortUnaryOperator{}} (\and{SortUnaryOperator{}} (Lbl'PlusUnds'C-SYNTAX'Unds'UnaryOperator{}(), Lbl-'Unds'C-SYNTAX'Unds'UnaryOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortUnaryOperator{}} (\and{SortUnaryOperator{}} (Lbl'PlusUnds'C-SYNTAX'Unds'UnaryOperator{}(), Lbl'TildUnds'C-SYNTAX'Unds'UnaryOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortUnaryExpression{}, \equals{SortUnaryExpression{}, R} (Val:SortUnaryExpression{}, Lbl--'UndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'UnaryExpression{}(K0:SortUnaryExpression{}))) [functional{}()] // functional
  axiom{}\implies{SortUnaryExpression{}} (\and{SortUnaryExpression{}} (Lbl--'UndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'UnaryExpression{}(X0:SortUnaryExpression{}), Lbl--'UndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'UnaryExpression{}(Y0:SortUnaryExpression{})), Lbl--'UndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'UnaryExpression{}(\and{SortUnaryExpression{}} (X0:SortUnaryExpression{}, Y0:SortUnaryExpression{}))) [constructor{}()] // no confusion same constructor
  axiom{}\not{SortUnaryExpression{}} (\and{SortUnaryExpression{}} (Lbl--'UndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'UnaryExpression{}(X0:SortUnaryExpression{}), Lbl'UndsUndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'UnaryOperator'Unds'CastExpression{}(Y0:SortUnaryOperator{}, Y1:SortCastExpression{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortUnaryExpression{}} (\and{SortUnaryExpression{}} (Lbl--'UndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'UnaryExpression{}(X0:SortUnaryExpression{}), Lblsizeof'UndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'TypeName{}(Y0:SortTypeName{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortUnaryExpression{}} (\and{SortUnaryExpression{}} (Lbl--'UndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'UnaryExpression{}(X0:SortUnaryExpression{}), Lblsizeof'UndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'UnaryExpression{}(Y0:SortUnaryExpression{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortUnaryOperator{}, \equals{SortUnaryOperator{}, R} (Val:SortUnaryOperator{}, Lbl-'Unds'C-SYNTAX'Unds'UnaryOperator{}())) [functional{}()] // functional
  axiom{}\not{SortUnaryOperator{}} (\and{SortUnaryOperator{}} (Lbl-'Unds'C-SYNTAX'Unds'UnaryOperator{}(), Lbl'TildUnds'C-SYNTAX'Unds'UnaryOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortList{}, \equals{SortList{}, R} (Val:SortList{}, Lbl'Stop'List{}())) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortEnumeratorList{}, \equals{SortEnumeratorList{}, R} (Val:SortEnumeratorList{}, Lbl'Stop'List'LBraQuotUndsCommUndsUnds'C-SYNTAX'Unds'EnumeratorList'Unds'Enumerator'Unds'EnumeratorList'QuotRBraUnds'EnumeratorList{}())) [functional{}()] // functional
  axiom{}\not{SortEnumeratorList{}} (\and{SortEnumeratorList{}} (Lbl'Stop'List'LBraQuotUndsCommUndsUnds'C-SYNTAX'Unds'EnumeratorList'Unds'Enumerator'Unds'EnumeratorList'QuotRBraUnds'EnumeratorList{}(), Lbl'UndsCommUndsUnds'C-SYNTAX'Unds'EnumeratorList'Unds'Enumerator'Unds'EnumeratorList{}(Y0:SortEnumerator{}, Y1:SortEnumeratorList{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortListAssignmentExpression{}, \equals{SortListAssignmentExpression{}, R} (Val:SortListAssignmentExpression{}, Lbl'Stop'List'LBraQuotUndsCommUndsUnds'C-SYNTAX'Unds'ListAssignmentExpression'Unds'AssignmentExpression'Unds'ListAssignmentExpression'QuotRBraUnds'ListAssignmentExpression{}())) [functional{}()] // functional
  axiom{}\not{SortListAssignmentExpression{}} (\and{SortListAssignmentExpression{}} (Lbl'Stop'List'LBraQuotUndsCommUndsUnds'C-SYNTAX'Unds'ListAssignmentExpression'Unds'AssignmentExpression'Unds'ListAssignmentExpression'QuotRBraUnds'ListAssignmentExpression{}(), Lbl'UndsCommUndsUnds'C-SYNTAX'Unds'ListAssignmentExpression'Unds'AssignmentExpression'Unds'ListAssignmentExpression{}(Y0:SortAssignmentExpression{}, Y1:SortListAssignmentExpression{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortListInitDeclarator{}, \equals{SortListInitDeclarator{}, R} (Val:SortListInitDeclarator{}, Lbl'Stop'List'LBraQuotUndsCommUndsUnds'C-SYNTAX'Unds'ListInitDeclarator'Unds'Initdeclarator'Unds'ListInitDeclarator'QuotRBraUnds'ListInitDeclarator{}())) [functional{}()] // functional
  axiom{}\not{SortListInitDeclarator{}} (\and{SortListInitDeclarator{}} (Lbl'Stop'List'LBraQuotUndsCommUndsUnds'C-SYNTAX'Unds'ListInitDeclarator'Unds'Initdeclarator'Unds'ListInitDeclarator'QuotRBraUnds'ListInitDeclarator{}(), Lbl'UndsCommUndsUnds'C-SYNTAX'Unds'ListInitDeclarator'Unds'Initdeclarator'Unds'ListInitDeclarator{}(Y0:SortInitdeclarator{}, Y1:SortListInitDeclarator{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortListStructDeclaration{}, \equals{SortListStructDeclaration{}, R} (Val:SortListStructDeclaration{}, Lbl'Stop'List'LBraQuotUndsSClnUndsUnds'C-SYNTAX'Unds'ListStructDeclaration'Unds'StructDeclaration'Unds'ListStructDeclaration'QuotRBraUnds'ListStructDeclaration{}())) [functional{}()] // functional
  axiom{}\not{SortListStructDeclaration{}} (\and{SortListStructDeclaration{}} (Lbl'Stop'List'LBraQuotUndsSClnUndsUnds'C-SYNTAX'Unds'ListStructDeclaration'Unds'StructDeclaration'Unds'ListStructDeclaration'QuotRBraUnds'ListStructDeclaration{}(), Lbl'UndsSClnUndsUnds'C-SYNTAX'Unds'ListStructDeclaration'Unds'StructDeclaration'Unds'ListStructDeclaration{}(Y0:SortStructDeclaration{}, Y1:SortListStructDeclaration{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIds{}, \equals{SortIds{}, R} (Val:SortIds{}, Lbl'Stop'List'LBraQuotUndsUndsUnds'C-SYNTAX'Unds'Ids'Unds'Id'Unds'Ids'QuotRBraUnds'Ids{}())) [functional{}()] // functional
  axiom{}\not{SortIds{}} (\and{SortIds{}} (Lbl'Stop'List'LBraQuotUndsUndsUnds'C-SYNTAX'Unds'Ids'Unds'Id'Unds'Ids'QuotRBraUnds'Ids{}(), Lbl'UndsUndsUnds'C-SYNTAX'Unds'Ids'Unds'Id'Unds'Ids{}(Y0:SortId{}, Y1:SortIds{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortListDeclarationSpecifier{}, \equals{SortListDeclarationSpecifier{}, R} (Val:SortListDeclarationSpecifier{}, Lbl'Stop'List'LBraQuotUndsUndsUnds'C-SYNTAX'Unds'ListDeclarationSpecifier'Unds'DeclarationSpecifier'Unds'ListDeclarationSpecifier'QuotRBraUnds'ListDeclarationSpecifier{}())) [functional{}()] // functional
  axiom{}\not{SortListDeclarationSpecifier{}} (\and{SortListDeclarationSpecifier{}} (Lbl'Stop'List'LBraQuotUndsUndsUnds'C-SYNTAX'Unds'ListDeclarationSpecifier'Unds'DeclarationSpecifier'Unds'ListDeclarationSpecifier'QuotRBraUnds'ListDeclarationSpecifier{}(), Lbl'UndsUndsUnds'C-SYNTAX'Unds'ListDeclarationSpecifier'Unds'DeclarationSpecifier'Unds'ListDeclarationSpecifier{}(Y0:SortDeclarationSpecifier{}, Y1:SortListDeclarationSpecifier{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortListDeclaration{}, \equals{SortListDeclaration{}, R} (Val:SortListDeclaration{}, Lbl'Stop'List'LBraQuotUndsUndsUnds'C-SYNTAX'Unds'ListDeclaration'Unds'Declaration'Unds'ListDeclaration'QuotRBraUnds'ListDeclaration{}())) [functional{}()] // functional
  axiom{}\not{SortListDeclaration{}} (\and{SortListDeclaration{}} (Lbl'Stop'List'LBraQuotUndsUndsUnds'C-SYNTAX'Unds'ListDeclaration'Unds'Declaration'Unds'ListDeclaration'QuotRBraUnds'ListDeclaration{}(), Lbl'UndsUndsUnds'C-SYNTAX'Unds'ListDeclaration'Unds'Declaration'Unds'ListDeclaration{}(Y0:SortDeclaration{}, Y1:SortListDeclaration{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortListExternalDeclaration{}, \equals{SortListExternalDeclaration{}, R} (Val:SortListExternalDeclaration{}, Lbl'Stop'List'LBraQuotUndsUndsUnds'C-SYNTAX'Unds'ListExternalDeclaration'Unds'ExternalDeclaration'Unds'ListExternalDeclaration'QuotRBraUnds'ListExternalDeclaration{}())) [functional{}()] // functional
  axiom{}\not{SortListExternalDeclaration{}} (\and{SortListExternalDeclaration{}} (Lbl'Stop'List'LBraQuotUndsUndsUnds'C-SYNTAX'Unds'ListExternalDeclaration'Unds'ExternalDeclaration'Unds'ListExternalDeclaration'QuotRBraUnds'ListExternalDeclaration{}(), Lbl'UndsUndsUnds'C-SYNTAX'Unds'ListExternalDeclaration'Unds'ExternalDeclaration'Unds'ListExternalDeclaration{}(Y0:SortExternalDeclaration{}, Y1:SortListExternalDeclaration{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortListSpecifierQualifier{}, \equals{SortListSpecifierQualifier{}, R} (Val:SortListSpecifierQualifier{}, Lbl'Stop'List'LBraQuotUndsUndsUnds'C-SYNTAX'Unds'ListSpecifierQualifier'Unds'SpecifierQualifier'Unds'ListSpecifierQualifier'QuotRBraUnds'ListSpecifierQualifier{}())) [functional{}()] // functional
  axiom{}\not{SortListSpecifierQualifier{}} (\and{SortListSpecifierQualifier{}} (Lbl'Stop'List'LBraQuotUndsUndsUnds'C-SYNTAX'Unds'ListSpecifierQualifier'Unds'SpecifierQualifier'Unds'ListSpecifierQualifier'QuotRBraUnds'ListSpecifierQualifier{}(), Lbl'UndsUndsUnds'C-SYNTAX'Unds'ListSpecifierQualifier'Unds'SpecifierQualifier'Unds'ListSpecifierQualifier{}(Y0:SortSpecifierQualifier{}, Y1:SortListSpecifierQualifier{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortListStatement{}, \equals{SortListStatement{}, R} (Val:SortListStatement{}, Lbl'Stop'List'LBraQuotUndsUndsUnds'C-SYNTAX'Unds'ListStatement'Unds'Statement'Unds'ListStatement'QuotRBraUnds'ListStatement{}())) [functional{}()] // functional
  axiom{}\not{SortListStatement{}} (\and{SortListStatement{}} (Lbl'Stop'List'LBraQuotUndsUndsUnds'C-SYNTAX'Unds'ListStatement'Unds'Statement'Unds'ListStatement'QuotRBraUnds'ListStatement{}(), Lbl'UndsUndsUnds'C-SYNTAX'Unds'ListStatement'Unds'Statement'Unds'ListStatement{}(Y0:SortStatement{}, Y1:SortListStatement{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortListTypeQualifier{}, \equals{SortListTypeQualifier{}, R} (Val:SortListTypeQualifier{}, Lbl'Stop'List'LBraQuotUndsUndsUnds'C-SYNTAX'Unds'ListTypeQualifier'Unds'TypeQualifier'Unds'ListTypeQualifier'QuotRBraUnds'ListTypeQualifier{}())) [functional{}()] // functional
  axiom{}\not{SortListTypeQualifier{}} (\and{SortListTypeQualifier{}} (Lbl'Stop'List'LBraQuotUndsUndsUnds'C-SYNTAX'Unds'ListTypeQualifier'Unds'TypeQualifier'Unds'ListTypeQualifier'QuotRBraUnds'ListTypeQualifier{}(), Lbl'UndsUndsUnds'C-SYNTAX'Unds'ListTypeQualifier'Unds'TypeQualifier'Unds'ListTypeQualifier{}(Y0:SortTypeQualifier{}, Y1:SortListTypeQualifier{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortMap{}, \equals{SortMap{}, R} (Val:SortMap{}, Lbl'Stop'Map{}())) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortSet{}, \equals{SortSet{}, R} (Val:SortSet{}, Lbl'Stop'Set{}())) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortAssignmentOperator{}, \equals{SortAssignmentOperator{}, R} (Val:SortAssignmentOperator{}, Lbl'SlshEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}())) [functional{}()] // functional
  axiom{}\not{SortAssignmentOperator{}} (\and{SortAssignmentOperator{}} (Lbl'SlshEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}(), Lbl'EqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortAssignmentOperator{}} (\and{SortAssignmentOperator{}} (Lbl'SlshEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}(), LblOf'EqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortAssignmentOperator{}} (\and{SortAssignmentOperator{}} (Lbl'SlshEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}(), Lbl'Xor-EqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortAssignmentOperator{}} (\and{SortAssignmentOperator{}} (Lbl'SlshEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}(), Lbl'PipeEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortStructDeclarator{}, \equals{SortStructDeclarator{}, R} (Val:SortStructDeclarator{}, Lbl'ColnUndsUnds'C-SYNTAX'Unds'StructDeclarator'Unds'ConstantExpression{}(K0:SortConstantExpression{}))) [functional{}()] // functional
  axiom{}\implies{SortStructDeclarator{}} (\and{SortStructDeclarator{}} (Lbl'ColnUndsUnds'C-SYNTAX'Unds'StructDeclarator'Unds'ConstantExpression{}(X0:SortConstantExpression{}), Lbl'ColnUndsUnds'C-SYNTAX'Unds'StructDeclarator'Unds'ConstantExpression{}(Y0:SortConstantExpression{})), Lbl'ColnUndsUnds'C-SYNTAX'Unds'StructDeclarator'Unds'ConstantExpression{}(\and{SortConstantExpression{}} (X0:SortConstantExpression{}, Y0:SortConstantExpression{}))) [constructor{}()] // no confusion same constructor
  axiom{}\not{SortStructDeclarator{}} (\and{SortStructDeclarator{}} (Lbl'ColnUndsUnds'C-SYNTAX'Unds'StructDeclarator'Unds'ConstantExpression{}(X0:SortConstantExpression{}), Lbl'UndsColnUndsUnds'C-SYNTAX'Unds'StructDeclarator'Unds'Declarator'Unds'ConstantExpression{}(Y0:SortDeclarator{}, Y1:SortConstantExpression{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortExpressionStatement{}, \equals{SortExpressionStatement{}, R} (Val:SortExpressionStatement{}, Lbl'SClnUnds'C-SYNTAX'Unds'ExpressionStatement{}())) [functional{}()] // functional
  axiom{}\not{SortExpressionStatement{}} (\and{SortExpressionStatement{}} (Lbl'SClnUnds'C-SYNTAX'Unds'ExpressionStatement{}(), Lbl'UndsSClnUnds'C-SYNTAX'Unds'ExpressionStatement'Unds'Expression{}(Y0:SortExpression{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortTCell{}, \equals{SortTCell{}, R} (Val:SortTCell{}, Lbl'-LT-'T'-GT-'{}(K0:SortKCell{}, K1:SortOslCell{}))) [functional{}()] // functional
  axiom{}\implies{SortTCell{}} (\and{SortTCell{}} (Lbl'-LT-'T'-GT-'{}(X0:SortKCell{}, X1:SortOslCell{}), Lbl'-LT-'T'-GT-'{}(Y0:SortKCell{}, Y1:SortOslCell{})), Lbl'-LT-'T'-GT-'{}(\and{SortKCell{}} (X0:SortKCell{}, Y0:SortKCell{}), \and{SortOslCell{}} (X1:SortOslCell{}, Y1:SortOslCell{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortTCellFragment{}, \equals{SortTCellFragment{}, R} (Val:SortTCellFragment{}, Lbl'-LT-'T'-GT-'-fragment{}(K0:SortKCellOpt{}, K1:SortOslCellOpt{}))) [functional{}()] // functional
  axiom{}\implies{SortTCellFragment{}} (\and{SortTCellFragment{}} (Lbl'-LT-'T'-GT-'-fragment{}(X0:SortKCellOpt{}, X1:SortOslCellOpt{}), Lbl'-LT-'T'-GT-'-fragment{}(Y0:SortKCellOpt{}, Y1:SortOslCellOpt{})), Lbl'-LT-'T'-GT-'-fragment{}(\and{SortKCellOpt{}} (X0:SortKCellOpt{}, Y0:SortKCellOpt{}), \and{SortOslCellOpt{}} (X1:SortOslCellOpt{}, Y1:SortOslCellOpt{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortGeneratedCounterCell{}, \equals{SortGeneratedCounterCell{}, R} (Val:SortGeneratedCounterCell{}, Lbl'-LT-'generatedCounter'-GT-'{}(K0:SortInt{}))) [functional{}()] // functional
  axiom{}\implies{SortGeneratedCounterCell{}} (\and{SortGeneratedCounterCell{}} (Lbl'-LT-'generatedCounter'-GT-'{}(X0:SortInt{}), Lbl'-LT-'generatedCounter'-GT-'{}(Y0:SortInt{})), Lbl'-LT-'generatedCounter'-GT-'{}(\and{SortInt{}} (X0:SortInt{}, Y0:SortInt{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortGeneratedTopCell{}, \equals{SortGeneratedTopCell{}, R} (Val:SortGeneratedTopCell{}, Lbl'-LT-'generatedTop'-GT-'{}(K0:SortTCell{}, K1:SortGeneratedCounterCell{}))) [functional{}()] // functional
  axiom{}\implies{SortGeneratedTopCell{}} (\and{SortGeneratedTopCell{}} (Lbl'-LT-'generatedTop'-GT-'{}(X0:SortTCell{}, X1:SortGeneratedCounterCell{}), Lbl'-LT-'generatedTop'-GT-'{}(Y0:SortTCell{}, Y1:SortGeneratedCounterCell{})), Lbl'-LT-'generatedTop'-GT-'{}(\and{SortTCell{}} (X0:SortTCell{}, Y0:SortTCell{}), \and{SortGeneratedCounterCell{}} (X1:SortGeneratedCounterCell{}, Y1:SortGeneratedCounterCell{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortGeneratedTopCellFragment{}, \equals{SortGeneratedTopCellFragment{}, R} (Val:SortGeneratedTopCellFragment{}, Lbl'-LT-'generatedTop'-GT-'-fragment{}(K0:SortTCellOpt{}, K1:SortGeneratedCounterCellOpt{}))) [functional{}()] // functional
  axiom{}\implies{SortGeneratedTopCellFragment{}} (\and{SortGeneratedTopCellFragment{}} (Lbl'-LT-'generatedTop'-GT-'-fragment{}(X0:SortTCellOpt{}, X1:SortGeneratedCounterCellOpt{}), Lbl'-LT-'generatedTop'-GT-'-fragment{}(Y0:SortTCellOpt{}, Y1:SortGeneratedCounterCellOpt{})), Lbl'-LT-'generatedTop'-GT-'-fragment{}(\and{SortTCellOpt{}} (X0:SortTCellOpt{}, Y0:SortTCellOpt{}), \and{SortGeneratedCounterCellOpt{}} (X1:SortGeneratedCounterCellOpt{}, Y1:SortGeneratedCounterCellOpt{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortKCell{}, \equals{SortKCell{}, R} (Val:SortKCell{}, Lbl'-LT-'k'-GT-'{}(K0:SortK{}))) [functional{}()] // functional
  axiom{}\implies{SortKCell{}} (\and{SortKCell{}} (Lbl'-LT-'k'-GT-'{}(X0:SortK{}), Lbl'-LT-'k'-GT-'{}(Y0:SortK{})), Lbl'-LT-'k'-GT-'{}(\and{SortK{}} (X0:SortK{}, Y0:SortK{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortOslCell{}, \equals{SortOslCell{}, R} (Val:SortOslCell{}, Lbl'-LT-'osl'-GT-'{}(K0:SortK{}))) [functional{}()] // functional
  axiom{}\implies{SortOslCell{}} (\and{SortOslCell{}} (Lbl'-LT-'osl'-GT-'{}(X0:SortK{}), Lbl'-LT-'osl'-GT-'{}(Y0:SortK{})), Lbl'-LT-'osl'-GT-'{}(\and{SortK{}} (X0:SortK{}, Y0:SortK{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortAssignmentOperator{}, \equals{SortAssignmentOperator{}, R} (Val:SortAssignmentOperator{}, Lbl'EqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}())) [functional{}()] // functional
  axiom{}\not{SortAssignmentOperator{}} (\and{SortAssignmentOperator{}} (Lbl'EqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}(), LblOf'EqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortAssignmentOperator{}} (\and{SortAssignmentOperator{}} (Lbl'EqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}(), Lbl'Xor-EqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortAssignmentOperator{}} (\and{SortAssignmentOperator{}} (Lbl'EqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}(), Lbl'PipeEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortString{}, \equals{SortString{}, R} (Val:SortString{}, LblBool2String'LParUndsRParUnds'STRING-COMMON'Unds'String'Unds'Bool{}(K0:SortBool{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortString{}, \equals{SortString{}, R} (Val:SortString{}, LblFloat2String'LParUndsRParUnds'STRING-COMMON'Unds'String'Unds'Float{}(K0:SortFloat{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortString{}, \equals{SortString{}, R} (Val:SortString{}, LblId2String'LParUndsRParUnds'ID-COMMON'Unds'String'Unds'Id{}(K0:SortId{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortString{}, \equals{SortString{}, R} (Val:SortString{}, LblInt2String'LParUndsRParUnds'STRING-COMMON'Unds'String'Unds'Int{}(K0:SortInt{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortList{}, \equals{SortList{}, R} (Val:SortList{}, LblListItem{}(K0:SortKItem{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortMap{}, \equals{SortMap{}, R} (Val:SortMap{}, LblMap'Coln'update{}(K0:SortMap{}, K1:SortKItem{}, K2:SortKItem{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortAssignmentOperator{}, \equals{SortAssignmentOperator{}, R} (Val:SortAssignmentOperator{}, LblOf'EqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}())) [functional{}()] // functional
  axiom{}\not{SortAssignmentOperator{}} (\and{SortAssignmentOperator{}} (LblOf'EqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}(), Lbl'Xor-EqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortAssignmentOperator{}} (\and{SortAssignmentOperator{}} (LblOf'EqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}(), Lbl'PipeEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortSet{}, \equals{SortSet{}, R} (Val:SortSet{}, LblSet'Coln'difference{}(K0:SortSet{}, K1:SortSet{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortBool{}, \equals{SortBool{}, R} (Val:SortBool{}, LblSet'Coln'in{}(K0:SortKItem{}, K1:SortSet{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortSet{}, \equals{SortSet{}, R} (Val:SortSet{}, LblSetItem{}(K0:SortKItem{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortId{}, \equals{SortId{}, R} (Val:SortId{}, LblString2Id'LParUndsRParUnds'ID-COMMON'Unds'Id'Unds'String{}(K0:SortString{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortDirectAbstractDeclarator{}, \equals{SortDirectAbstractDeclarator{}, R} (Val:SortDirectAbstractDeclarator{}, Lbl'LSqBRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator{}())) [functional{}()] // functional
  axiom{}\not{SortDirectAbstractDeclarator{}} (\and{SortDirectAbstractDeclarator{}} (Lbl'LSqBRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator{}(), Lbl'LSqBUndsRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'ConstantExpression{}(Y0:SortConstantExpression{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortDirectAbstractDeclarator{}} (\and{SortDirectAbstractDeclarator{}} (Lbl'LSqBRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator{}(), Lbl'UndsLParRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator{}(Y0:SortDirectAbstractDeclarator{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortDirectAbstractDeclarator{}} (\and{SortDirectAbstractDeclarator{}} (Lbl'LSqBRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator{}(), Lbl'UndsLParUndsRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator'Unds'ParameterTypeList{}(Y0:SortDirectAbstractDeclarator{}, Y1:SortParameterTypeList{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortDirectAbstractDeclarator{}} (\and{SortDirectAbstractDeclarator{}} (Lbl'LSqBRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator{}(), Lbl'UndsLSqBRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator{}(Y0:SortDirectAbstractDeclarator{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortDirectAbstractDeclarator{}} (\and{SortDirectAbstractDeclarator{}} (Lbl'LSqBRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator{}(), Lbl'UndsLSqBUndsRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator'Unds'ConstantExpression{}(Y0:SortDirectAbstractDeclarator{}, Y1:SortConstantExpression{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortDirectAbstractDeclarator{}, \equals{SortDirectAbstractDeclarator{}, R} (Val:SortDirectAbstractDeclarator{}, Lbl'LSqBUndsRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'ConstantExpression{}(K0:SortConstantExpression{}))) [functional{}()] // functional
  axiom{}\implies{SortDirectAbstractDeclarator{}} (\and{SortDirectAbstractDeclarator{}} (Lbl'LSqBUndsRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'ConstantExpression{}(X0:SortConstantExpression{}), Lbl'LSqBUndsRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'ConstantExpression{}(Y0:SortConstantExpression{})), Lbl'LSqBUndsRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'ConstantExpression{}(\and{SortConstantExpression{}} (X0:SortConstantExpression{}, Y0:SortConstantExpression{}))) [constructor{}()] // no confusion same constructor
  axiom{}\not{SortDirectAbstractDeclarator{}} (\and{SortDirectAbstractDeclarator{}} (Lbl'LSqBUndsRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'ConstantExpression{}(X0:SortConstantExpression{}), Lbl'UndsLParRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator{}(Y0:SortDirectAbstractDeclarator{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortDirectAbstractDeclarator{}} (\and{SortDirectAbstractDeclarator{}} (Lbl'LSqBUndsRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'ConstantExpression{}(X0:SortConstantExpression{}), Lbl'UndsLParUndsRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator'Unds'ParameterTypeList{}(Y0:SortDirectAbstractDeclarator{}, Y1:SortParameterTypeList{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortDirectAbstractDeclarator{}} (\and{SortDirectAbstractDeclarator{}} (Lbl'LSqBUndsRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'ConstantExpression{}(X0:SortConstantExpression{}), Lbl'UndsLSqBRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator{}(Y0:SortDirectAbstractDeclarator{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortDirectAbstractDeclarator{}} (\and{SortDirectAbstractDeclarator{}} (Lbl'LSqBUndsRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'ConstantExpression{}(X0:SortConstantExpression{}), Lbl'UndsLSqBUndsRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator'Unds'ConstantExpression{}(Y0:SortDirectAbstractDeclarator{}, Y1:SortConstantExpression{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortAssignmentOperator{}, \equals{SortAssignmentOperator{}, R} (Val:SortAssignmentOperator{}, Lbl'Xor-EqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}())) [functional{}()] // functional
  axiom{}\not{SortAssignmentOperator{}} (\and{SortAssignmentOperator{}} (Lbl'Xor-EqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}(), Lbl'PipeEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}())) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortEqualityExpression{}, \equals{SortEqualityExpression{}, R} (Val:SortEqualityExpression{}, Lbl'UndsBangEqlsUndsUnds'C-SYNTAX'Unds'EqualityExpression'Unds'EqualityExpression'Unds'RelationalExpression{}(K0:SortEqualityExpression{}, K1:SortRelationalExpression{}))) [functional{}()] // functional
  axiom{}\implies{SortEqualityExpression{}} (\and{SortEqualityExpression{}} (Lbl'UndsBangEqlsUndsUnds'C-SYNTAX'Unds'EqualityExpression'Unds'EqualityExpression'Unds'RelationalExpression{}(X0:SortEqualityExpression{}, X1:SortRelationalExpression{}), Lbl'UndsBangEqlsUndsUnds'C-SYNTAX'Unds'EqualityExpression'Unds'EqualityExpression'Unds'RelationalExpression{}(Y0:SortEqualityExpression{}, Y1:SortRelationalExpression{})), Lbl'UndsBangEqlsUndsUnds'C-SYNTAX'Unds'EqualityExpression'Unds'EqualityExpression'Unds'RelationalExpression{}(\and{SortEqualityExpression{}} (X0:SortEqualityExpression{}, Y0:SortEqualityExpression{}), \and{SortRelationalExpression{}} (X1:SortRelationalExpression{}, Y1:SortRelationalExpression{}))) [constructor{}()] // no confusion same constructor
  axiom{}\not{SortEqualityExpression{}} (\and{SortEqualityExpression{}} (Lbl'UndsBangEqlsUndsUnds'C-SYNTAX'Unds'EqualityExpression'Unds'EqualityExpression'Unds'RelationalExpression{}(X0:SortEqualityExpression{}, X1:SortRelationalExpression{}), Lbl'UndsEqlsEqlsUndsUnds'C-SYNTAX'Unds'EqualityExpression'Unds'EqualityExpression'Unds'RelationalExpression{}(Y0:SortEqualityExpression{}, Y1:SortRelationalExpression{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortMultiplicativeExpression{}, \equals{SortMultiplicativeExpression{}, R} (Val:SortMultiplicativeExpression{}, Lbl'UndsPercUndsUnds'C-SYNTAX'Unds'MultiplicativeExpression'Unds'MultiplicativeExpression'Unds'CastExpression{}(K0:SortMultiplicativeExpression{}, K1:SortCastExpression{}))) [functional{}()] // functional
  axiom{}\implies{SortMultiplicativeExpression{}} (\and{SortMultiplicativeExpression{}} (Lbl'UndsPercUndsUnds'C-SYNTAX'Unds'MultiplicativeExpression'Unds'MultiplicativeExpression'Unds'CastExpression{}(X0:SortMultiplicativeExpression{}, X1:SortCastExpression{}), Lbl'UndsPercUndsUnds'C-SYNTAX'Unds'MultiplicativeExpression'Unds'MultiplicativeExpression'Unds'CastExpression{}(Y0:SortMultiplicativeExpression{}, Y1:SortCastExpression{})), Lbl'UndsPercUndsUnds'C-SYNTAX'Unds'MultiplicativeExpression'Unds'MultiplicativeExpression'Unds'CastExpression{}(\and{SortMultiplicativeExpression{}} (X0:SortMultiplicativeExpression{}, Y0:SortMultiplicativeExpression{}), \and{SortCastExpression{}} (X1:SortCastExpression{}, Y1:SortCastExpression{}))) [constructor{}()] // no confusion same constructor
  axiom{}\not{SortMultiplicativeExpression{}} (\and{SortMultiplicativeExpression{}} (Lbl'UndsPercUndsUnds'C-SYNTAX'Unds'MultiplicativeExpression'Unds'MultiplicativeExpression'Unds'CastExpression{}(X0:SortMultiplicativeExpression{}, X1:SortCastExpression{}), Lbl'UndsStarUndsUnds'C-SYNTAX'Unds'MultiplicativeExpression'Unds'MultiplicativeExpression'Unds'CastExpression{}(Y0:SortMultiplicativeExpression{}, Y1:SortCastExpression{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortMultiplicativeExpression{}} (\and{SortMultiplicativeExpression{}} (Lbl'UndsPercUndsUnds'C-SYNTAX'Unds'MultiplicativeExpression'Unds'MultiplicativeExpression'Unds'CastExpression{}(X0:SortMultiplicativeExpression{}, X1:SortCastExpression{}), Lbl'UndsSlshUndsUnds'C-SYNTAX'Unds'MultiplicativeExpression'Unds'MultiplicativeExpression'Unds'CastExpression{}(Y0:SortMultiplicativeExpression{}, Y1:SortCastExpression{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortLogicalOfandExpression{}, \equals{SortLogicalOfandExpression{}, R} (Val:SortLogicalOfandExpression{}, Lbl'UndsAnd-And-UndsUnds'C-SYNTAX'Unds'LogicalOfandExpression'Unds'LogicalOfandExpression'Unds'InclusiveOforExpression{}(K0:SortLogicalOfandExpression{}, K1:SortInclusiveOforExpression{}))) [functional{}()] // functional
  axiom{}\implies{SortLogicalOfandExpression{}} (\and{SortLogicalOfandExpression{}} (Lbl'UndsAnd-And-UndsUnds'C-SYNTAX'Unds'LogicalOfandExpression'Unds'LogicalOfandExpression'Unds'InclusiveOforExpression{}(X0:SortLogicalOfandExpression{}, X1:SortInclusiveOforExpression{}), Lbl'UndsAnd-And-UndsUnds'C-SYNTAX'Unds'LogicalOfandExpression'Unds'LogicalOfandExpression'Unds'InclusiveOforExpression{}(Y0:SortLogicalOfandExpression{}, Y1:SortInclusiveOforExpression{})), Lbl'UndsAnd-And-UndsUnds'C-SYNTAX'Unds'LogicalOfandExpression'Unds'LogicalOfandExpression'Unds'InclusiveOforExpression{}(\and{SortLogicalOfandExpression{}} (X0:SortLogicalOfandExpression{}, Y0:SortLogicalOfandExpression{}), \and{SortInclusiveOforExpression{}} (X1:SortInclusiveOforExpression{}, Y1:SortInclusiveOforExpression{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortInt{}, \equals{SortInt{}, R} (Val:SortInt{}, Lbl'UndsAnd-'Int'Unds'{}(K0:SortInt{}, K1:SortInt{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortAndExpression{}, \equals{SortAndExpression{}, R} (Val:SortAndExpression{}, Lbl'UndsAnd-UndsUnds'C-SYNTAX'Unds'AndExpression'Unds'AndExpression'Unds'EqualityExpression{}(K0:SortAndExpression{}, K1:SortEqualityExpression{}))) [functional{}()] // functional
  axiom{}\implies{SortAndExpression{}} (\and{SortAndExpression{}} (Lbl'UndsAnd-UndsUnds'C-SYNTAX'Unds'AndExpression'Unds'AndExpression'Unds'EqualityExpression{}(X0:SortAndExpression{}, X1:SortEqualityExpression{}), Lbl'UndsAnd-UndsUnds'C-SYNTAX'Unds'AndExpression'Unds'AndExpression'Unds'EqualityExpression{}(Y0:SortAndExpression{}, Y1:SortEqualityExpression{})), Lbl'UndsAnd-UndsUnds'C-SYNTAX'Unds'AndExpression'Unds'AndExpression'Unds'EqualityExpression{}(\and{SortAndExpression{}} (X0:SortAndExpression{}, Y0:SortAndExpression{}), \and{SortEqualityExpression{}} (X1:SortEqualityExpression{}, Y1:SortEqualityExpression{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortDirectAbstractDeclarator{}, \equals{SortDirectAbstractDeclarator{}, R} (Val:SortDirectAbstractDeclarator{}, Lbl'UndsLParRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator{}(K0:SortDirectAbstractDeclarator{}))) [functional{}()] // functional
  axiom{}\implies{SortDirectAbstractDeclarator{}} (\and{SortDirectAbstractDeclarator{}} (Lbl'UndsLParRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator{}(X0:SortDirectAbstractDeclarator{}), Lbl'UndsLParRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator{}(Y0:SortDirectAbstractDeclarator{})), Lbl'UndsLParRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator{}(\and{SortDirectAbstractDeclarator{}} (X0:SortDirectAbstractDeclarator{}, Y0:SortDirectAbstractDeclarator{}))) [constructor{}()] // no confusion same constructor
  axiom{}\not{SortDirectAbstractDeclarator{}} (\and{SortDirectAbstractDeclarator{}} (Lbl'UndsLParRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator{}(X0:SortDirectAbstractDeclarator{}), Lbl'UndsLParUndsRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator'Unds'ParameterTypeList{}(Y0:SortDirectAbstractDeclarator{}, Y1:SortParameterTypeList{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortDirectAbstractDeclarator{}} (\and{SortDirectAbstractDeclarator{}} (Lbl'UndsLParRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator{}(X0:SortDirectAbstractDeclarator{}), Lbl'UndsLSqBRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator{}(Y0:SortDirectAbstractDeclarator{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortDirectAbstractDeclarator{}} (\and{SortDirectAbstractDeclarator{}} (Lbl'UndsLParRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator{}(X0:SortDirectAbstractDeclarator{}), Lbl'UndsLSqBUndsRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator'Unds'ConstantExpression{}(Y0:SortDirectAbstractDeclarator{}, Y1:SortConstantExpression{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortDirectAbstractDeclarator{}, \equals{SortDirectAbstractDeclarator{}, R} (Val:SortDirectAbstractDeclarator{}, Lbl'UndsLParUndsRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator'Unds'ParameterTypeList{}(K0:SortDirectAbstractDeclarator{}, K1:SortParameterTypeList{}))) [functional{}()] // functional
  axiom{}\implies{SortDirectAbstractDeclarator{}} (\and{SortDirectAbstractDeclarator{}} (Lbl'UndsLParUndsRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator'Unds'ParameterTypeList{}(X0:SortDirectAbstractDeclarator{}, X1:SortParameterTypeList{}), Lbl'UndsLParUndsRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator'Unds'ParameterTypeList{}(Y0:SortDirectAbstractDeclarator{}, Y1:SortParameterTypeList{})), Lbl'UndsLParUndsRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator'Unds'ParameterTypeList{}(\and{SortDirectAbstractDeclarator{}} (X0:SortDirectAbstractDeclarator{}, Y0:SortDirectAbstractDeclarator{}), \and{SortParameterTypeList{}} (X1:SortParameterTypeList{}, Y1:SortParameterTypeList{}))) [constructor{}()] // no confusion same constructor
  axiom{}\not{SortDirectAbstractDeclarator{}} (\and{SortDirectAbstractDeclarator{}} (Lbl'UndsLParUndsRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator'Unds'ParameterTypeList{}(X0:SortDirectAbstractDeclarator{}, X1:SortParameterTypeList{}), Lbl'UndsLSqBRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator{}(Y0:SortDirectAbstractDeclarator{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortDirectAbstractDeclarator{}} (\and{SortDirectAbstractDeclarator{}} (Lbl'UndsLParUndsRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator'Unds'ParameterTypeList{}(X0:SortDirectAbstractDeclarator{}, X1:SortParameterTypeList{}), Lbl'UndsLSqBUndsRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator'Unds'ConstantExpression{}(Y0:SortDirectAbstractDeclarator{}, Y1:SortConstantExpression{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortDirectDeclarator{}, \equals{SortDirectDeclarator{}, R} (Val:SortDirectDeclarator{}, Lbl'UndsLParUndsRParUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'DirectDeclarator'Unds'Ids{}(K0:SortDirectDeclarator{}, K1:SortIds{}))) [functional{}()] // functional
  axiom{}\implies{SortDirectDeclarator{}} (\and{SortDirectDeclarator{}} (Lbl'UndsLParUndsRParUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'DirectDeclarator'Unds'Ids{}(X0:SortDirectDeclarator{}, X1:SortIds{}), Lbl'UndsLParUndsRParUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'DirectDeclarator'Unds'Ids{}(Y0:SortDirectDeclarator{}, Y1:SortIds{})), Lbl'UndsLParUndsRParUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'DirectDeclarator'Unds'Ids{}(\and{SortDirectDeclarator{}} (X0:SortDirectDeclarator{}, Y0:SortDirectDeclarator{}), \and{SortIds{}} (X1:SortIds{}, Y1:SortIds{}))) [constructor{}()] // no confusion same constructor
  axiom{}\not{SortDirectDeclarator{}} (\and{SortDirectDeclarator{}} (Lbl'UndsLParUndsRParUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'DirectDeclarator'Unds'Ids{}(X0:SortDirectDeclarator{}, X1:SortIds{}), Lbl'UndsLParUndsRParUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'DirectDeclarator'Unds'ParameterTypeList{}(Y0:SortDirectDeclarator{}, Y1:SortParameterTypeList{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortDirectDeclarator{}} (\and{SortDirectDeclarator{}} (Lbl'UndsLParUndsRParUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'DirectDeclarator'Unds'Ids{}(X0:SortDirectDeclarator{}, X1:SortIds{}), Lbl'UndsLSqBRSqBUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'DirectDeclarator{}(Y0:SortDirectDeclarator{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortDirectDeclarator{}} (\and{SortDirectDeclarator{}} (Lbl'UndsLParUndsRParUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'DirectDeclarator'Unds'Ids{}(X0:SortDirectDeclarator{}, X1:SortIds{}), Lbl'UndsLSqBUndsRSqBUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'DirectDeclarator'Unds'ConstantExpression{}(Y0:SortDirectDeclarator{}, Y1:SortConstantExpression{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortDirectDeclarator{}, \equals{SortDirectDeclarator{}, R} (Val:SortDirectDeclarator{}, Lbl'UndsLParUndsRParUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'DirectDeclarator'Unds'ParameterTypeList{}(K0:SortDirectDeclarator{}, K1:SortParameterTypeList{}))) [functional{}()] // functional
  axiom{}\implies{SortDirectDeclarator{}} (\and{SortDirectDeclarator{}} (Lbl'UndsLParUndsRParUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'DirectDeclarator'Unds'ParameterTypeList{}(X0:SortDirectDeclarator{}, X1:SortParameterTypeList{}), Lbl'UndsLParUndsRParUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'DirectDeclarator'Unds'ParameterTypeList{}(Y0:SortDirectDeclarator{}, Y1:SortParameterTypeList{})), Lbl'UndsLParUndsRParUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'DirectDeclarator'Unds'ParameterTypeList{}(\and{SortDirectDeclarator{}} (X0:SortDirectDeclarator{}, Y0:SortDirectDeclarator{}), \and{SortParameterTypeList{}} (X1:SortParameterTypeList{}, Y1:SortParameterTypeList{}))) [constructor{}()] // no confusion same constructor
  axiom{}\not{SortDirectDeclarator{}} (\and{SortDirectDeclarator{}} (Lbl'UndsLParUndsRParUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'DirectDeclarator'Unds'ParameterTypeList{}(X0:SortDirectDeclarator{}, X1:SortParameterTypeList{}), Lbl'UndsLSqBRSqBUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'DirectDeclarator{}(Y0:SortDirectDeclarator{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortDirectDeclarator{}} (\and{SortDirectDeclarator{}} (Lbl'UndsLParUndsRParUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'DirectDeclarator'Unds'ParameterTypeList{}(X0:SortDirectDeclarator{}, X1:SortParameterTypeList{}), Lbl'UndsLSqBUndsRSqBUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'DirectDeclarator'Unds'ConstantExpression{}(Y0:SortDirectDeclarator{}, Y1:SortConstantExpression{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortPostfixExpression{}, \equals{SortPostfixExpression{}, R} (Val:SortPostfixExpression{}, Lbl'UndsLParUndsRParUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression'Unds'ListAssignmentExpression{}(K0:SortPostfixExpression{}, K1:SortListAssignmentExpression{}))) [functional{}()] // functional
  axiom{}\implies{SortPostfixExpression{}} (\and{SortPostfixExpression{}} (Lbl'UndsLParUndsRParUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression'Unds'ListAssignmentExpression{}(X0:SortPostfixExpression{}, X1:SortListAssignmentExpression{}), Lbl'UndsLParUndsRParUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression'Unds'ListAssignmentExpression{}(Y0:SortPostfixExpression{}, Y1:SortListAssignmentExpression{})), Lbl'UndsLParUndsRParUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression'Unds'ListAssignmentExpression{}(\and{SortPostfixExpression{}} (X0:SortPostfixExpression{}, Y0:SortPostfixExpression{}), \and{SortListAssignmentExpression{}} (X1:SortListAssignmentExpression{}, Y1:SortListAssignmentExpression{}))) [constructor{}()] // no confusion same constructor
  axiom{}\not{SortPostfixExpression{}} (\and{SortPostfixExpression{}} (Lbl'UndsLParUndsRParUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression'Unds'ListAssignmentExpression{}(X0:SortPostfixExpression{}, X1:SortListAssignmentExpression{}), Lbl'UndsPlusPlusUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression{}(Y0:SortPostfixExpression{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortPostfixExpression{}} (\and{SortPostfixExpression{}} (Lbl'UndsLParUndsRParUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression'Unds'ListAssignmentExpression{}(X0:SortPostfixExpression{}, X1:SortListAssignmentExpression{}), Lbl'Unds'--'Unds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression{}(Y0:SortPostfixExpression{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortPostfixExpression{}} (\and{SortPostfixExpression{}} (Lbl'UndsLParUndsRParUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression'Unds'ListAssignmentExpression{}(X0:SortPostfixExpression{}, X1:SortListAssignmentExpression{}), Lbl'Unds'-'-GT-UndsUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression'Unds'Id{}(Y0:SortPostfixExpression{}, Y1:SortId{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortPostfixExpression{}} (\and{SortPostfixExpression{}} (Lbl'UndsLParUndsRParUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression'Unds'ListAssignmentExpression{}(X0:SortPostfixExpression{}, X1:SortListAssignmentExpression{}), Lbl'UndsStopUndsUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression'Unds'Id{}(Y0:SortPostfixExpression{}, Y1:SortId{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortPostfixExpression{}} (\and{SortPostfixExpression{}} (Lbl'UndsLParUndsRParUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression'Unds'ListAssignmentExpression{}(X0:SortPostfixExpression{}, X1:SortListAssignmentExpression{}), Lbl'UndsLSqBUndsRSqBUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression'Unds'Expression{}(Y0:SortPostfixExpression{}, Y1:SortExpression{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortInt{}, \equals{SortInt{}, R} (Val:SortInt{}, Lbl'UndsStar'Int'Unds'{}(K0:SortInt{}, K1:SortInt{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortMultiplicativeExpression{}, \equals{SortMultiplicativeExpression{}, R} (Val:SortMultiplicativeExpression{}, Lbl'UndsStarUndsUnds'C-SYNTAX'Unds'MultiplicativeExpression'Unds'MultiplicativeExpression'Unds'CastExpression{}(K0:SortMultiplicativeExpression{}, K1:SortCastExpression{}))) [functional{}()] // functional
  axiom{}\implies{SortMultiplicativeExpression{}} (\and{SortMultiplicativeExpression{}} (Lbl'UndsStarUndsUnds'C-SYNTAX'Unds'MultiplicativeExpression'Unds'MultiplicativeExpression'Unds'CastExpression{}(X0:SortMultiplicativeExpression{}, X1:SortCastExpression{}), Lbl'UndsStarUndsUnds'C-SYNTAX'Unds'MultiplicativeExpression'Unds'MultiplicativeExpression'Unds'CastExpression{}(Y0:SortMultiplicativeExpression{}, Y1:SortCastExpression{})), Lbl'UndsStarUndsUnds'C-SYNTAX'Unds'MultiplicativeExpression'Unds'MultiplicativeExpression'Unds'CastExpression{}(\and{SortMultiplicativeExpression{}} (X0:SortMultiplicativeExpression{}, Y0:SortMultiplicativeExpression{}), \and{SortCastExpression{}} (X1:SortCastExpression{}, Y1:SortCastExpression{}))) [constructor{}()] // no confusion same constructor
  axiom{}\not{SortMultiplicativeExpression{}} (\and{SortMultiplicativeExpression{}} (Lbl'UndsStarUndsUnds'C-SYNTAX'Unds'MultiplicativeExpression'Unds'MultiplicativeExpression'Unds'CastExpression{}(X0:SortMultiplicativeExpression{}, X1:SortCastExpression{}), Lbl'UndsSlshUndsUnds'C-SYNTAX'Unds'MultiplicativeExpression'Unds'MultiplicativeExpression'Unds'CastExpression{}(Y0:SortMultiplicativeExpression{}, Y1:SortCastExpression{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortPostfixExpression{}, \equals{SortPostfixExpression{}, R} (Val:SortPostfixExpression{}, Lbl'UndsPlusPlusUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression{}(K0:SortPostfixExpression{}))) [functional{}()] // functional
  axiom{}\implies{SortPostfixExpression{}} (\and{SortPostfixExpression{}} (Lbl'UndsPlusPlusUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression{}(X0:SortPostfixExpression{}), Lbl'UndsPlusPlusUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression{}(Y0:SortPostfixExpression{})), Lbl'UndsPlusPlusUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression{}(\and{SortPostfixExpression{}} (X0:SortPostfixExpression{}, Y0:SortPostfixExpression{}))) [constructor{}()] // no confusion same constructor
  axiom{}\not{SortPostfixExpression{}} (\and{SortPostfixExpression{}} (Lbl'UndsPlusPlusUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression{}(X0:SortPostfixExpression{}), Lbl'Unds'--'Unds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression{}(Y0:SortPostfixExpression{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortPostfixExpression{}} (\and{SortPostfixExpression{}} (Lbl'UndsPlusPlusUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression{}(X0:SortPostfixExpression{}), Lbl'Unds'-'-GT-UndsUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression'Unds'Id{}(Y0:SortPostfixExpression{}, Y1:SortId{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortPostfixExpression{}} (\and{SortPostfixExpression{}} (Lbl'UndsPlusPlusUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression{}(X0:SortPostfixExpression{}), Lbl'UndsStopUndsUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression'Unds'Id{}(Y0:SortPostfixExpression{}, Y1:SortId{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortPostfixExpression{}} (\and{SortPostfixExpression{}} (Lbl'UndsPlusPlusUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression{}(X0:SortPostfixExpression{}), Lbl'UndsLSqBUndsRSqBUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression'Unds'Expression{}(Y0:SortPostfixExpression{}, Y1:SortExpression{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortInt{}, \equals{SortInt{}, R} (Val:SortInt{}, Lbl'UndsPlus'Int'Unds'{}(K0:SortInt{}, K1:SortInt{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortString{}, \equals{SortString{}, R} (Val:SortString{}, Lbl'UndsPlus'String'UndsUnds'STRING-COMMON'Unds'String'Unds'String'Unds'String{}(K0:SortString{}, K1:SortString{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortAdditiveExpression{}, \equals{SortAdditiveExpression{}, R} (Val:SortAdditiveExpression{}, Lbl'UndsPlusUndsUnds'C-SYNTAX'Unds'AdditiveExpression'Unds'AdditiveExpression'Unds'MultiplicativeExpression{}(K0:SortAdditiveExpression{}, K1:SortMultiplicativeExpression{}))) [functional{}()] // functional
  axiom{}\implies{SortAdditiveExpression{}} (\and{SortAdditiveExpression{}} (Lbl'UndsPlusUndsUnds'C-SYNTAX'Unds'AdditiveExpression'Unds'AdditiveExpression'Unds'MultiplicativeExpression{}(X0:SortAdditiveExpression{}, X1:SortMultiplicativeExpression{}), Lbl'UndsPlusUndsUnds'C-SYNTAX'Unds'AdditiveExpression'Unds'AdditiveExpression'Unds'MultiplicativeExpression{}(Y0:SortAdditiveExpression{}, Y1:SortMultiplicativeExpression{})), Lbl'UndsPlusUndsUnds'C-SYNTAX'Unds'AdditiveExpression'Unds'AdditiveExpression'Unds'MultiplicativeExpression{}(\and{SortAdditiveExpression{}} (X0:SortAdditiveExpression{}, Y0:SortAdditiveExpression{}), \and{SortMultiplicativeExpression{}} (X1:SortMultiplicativeExpression{}, Y1:SortMultiplicativeExpression{}))) [constructor{}()] // no confusion same constructor
  axiom{}\not{SortAdditiveExpression{}} (\and{SortAdditiveExpression{}} (Lbl'UndsPlusUndsUnds'C-SYNTAX'Unds'AdditiveExpression'Unds'AdditiveExpression'Unds'MultiplicativeExpression{}(X0:SortAdditiveExpression{}, X1:SortMultiplicativeExpression{}), Lbl'Unds'-'UndsUnds'C-SYNTAX'Unds'AdditiveExpression'Unds'AdditiveExpression'Unds'MultiplicativeExpression{}(Y0:SortAdditiveExpression{}, Y1:SortMultiplicativeExpression{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortParameterTypeList{}, \equals{SortParameterTypeList{}, R} (Val:SortParameterTypeList{}, Lbl'UndsCommStopStopStopUnds'C-SYNTAX'Unds'ParameterTypeList'Unds'ParameterList{}(K0:SortParameterList{}))) [functional{}()] // functional
  axiom{}\implies{SortParameterTypeList{}} (\and{SortParameterTypeList{}} (Lbl'UndsCommStopStopStopUnds'C-SYNTAX'Unds'ParameterTypeList'Unds'ParameterList{}(X0:SortParameterList{}), Lbl'UndsCommStopStopStopUnds'C-SYNTAX'Unds'ParameterTypeList'Unds'ParameterList{}(Y0:SortParameterList{})), Lbl'UndsCommStopStopStopUnds'C-SYNTAX'Unds'ParameterTypeList'Unds'ParameterList{}(\and{SortParameterList{}} (X0:SortParameterList{}, Y0:SortParameterList{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortEnumeratorList{}, \equals{SortEnumeratorList{}, R} (Val:SortEnumeratorList{}, Lbl'UndsCommUndsUnds'C-SYNTAX'Unds'EnumeratorList'Unds'Enumerator'Unds'EnumeratorList{}(K0:SortEnumerator{}, K1:SortEnumeratorList{}))) [functional{}()] // functional
  axiom{}\implies{SortEnumeratorList{}} (\and{SortEnumeratorList{}} (Lbl'UndsCommUndsUnds'C-SYNTAX'Unds'EnumeratorList'Unds'Enumerator'Unds'EnumeratorList{}(X0:SortEnumerator{}, X1:SortEnumeratorList{}), Lbl'UndsCommUndsUnds'C-SYNTAX'Unds'EnumeratorList'Unds'Enumerator'Unds'EnumeratorList{}(Y0:SortEnumerator{}, Y1:SortEnumeratorList{})), Lbl'UndsCommUndsUnds'C-SYNTAX'Unds'EnumeratorList'Unds'Enumerator'Unds'EnumeratorList{}(\and{SortEnumerator{}} (X0:SortEnumerator{}, Y0:SortEnumerator{}), \and{SortEnumeratorList{}} (X1:SortEnumeratorList{}, Y1:SortEnumeratorList{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortExpression{}, \equals{SortExpression{}, R} (Val:SortExpression{}, Lbl'UndsCommUndsUnds'C-SYNTAX'Unds'Expression'Unds'Expression'Unds'AssignmentExpression{}(K0:SortExpression{}, K1:SortAssignmentExpression{}))) [functional{}()] // functional
  axiom{}\implies{SortExpression{}} (\and{SortExpression{}} (Lbl'UndsCommUndsUnds'C-SYNTAX'Unds'Expression'Unds'Expression'Unds'AssignmentExpression{}(X0:SortExpression{}, X1:SortAssignmentExpression{}), Lbl'UndsCommUndsUnds'C-SYNTAX'Unds'Expression'Unds'Expression'Unds'AssignmentExpression{}(Y0:SortExpression{}, Y1:SortAssignmentExpression{})), Lbl'UndsCommUndsUnds'C-SYNTAX'Unds'Expression'Unds'Expression'Unds'AssignmentExpression{}(\and{SortExpression{}} (X0:SortExpression{}, Y0:SortExpression{}), \and{SortAssignmentExpression{}} (X1:SortAssignmentExpression{}, Y1:SortAssignmentExpression{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortInitializerList{}, \equals{SortInitializerList{}, R} (Val:SortInitializerList{}, Lbl'UndsCommUndsUnds'C-SYNTAX'Unds'InitializerList'Unds'InitializerList'Unds'Initializer{}(K0:SortInitializerList{}, K1:SortInitializer{}))) [functional{}()] // functional
  axiom{}\implies{SortInitializerList{}} (\and{SortInitializerList{}} (Lbl'UndsCommUndsUnds'C-SYNTAX'Unds'InitializerList'Unds'InitializerList'Unds'Initializer{}(X0:SortInitializerList{}, X1:SortInitializer{}), Lbl'UndsCommUndsUnds'C-SYNTAX'Unds'InitializerList'Unds'InitializerList'Unds'Initializer{}(Y0:SortInitializerList{}, Y1:SortInitializer{})), Lbl'UndsCommUndsUnds'C-SYNTAX'Unds'InitializerList'Unds'InitializerList'Unds'Initializer{}(\and{SortInitializerList{}} (X0:SortInitializerList{}, Y0:SortInitializerList{}), \and{SortInitializer{}} (X1:SortInitializer{}, Y1:SortInitializer{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortListAssignmentExpression{}, \equals{SortListAssignmentExpression{}, R} (Val:SortListAssignmentExpression{}, Lbl'UndsCommUndsUnds'C-SYNTAX'Unds'ListAssignmentExpression'Unds'AssignmentExpression'Unds'ListAssignmentExpression{}(K0:SortAssignmentExpression{}, K1:SortListAssignmentExpression{}))) [functional{}()] // functional
  axiom{}\implies{SortListAssignmentExpression{}} (\and{SortListAssignmentExpression{}} (Lbl'UndsCommUndsUnds'C-SYNTAX'Unds'ListAssignmentExpression'Unds'AssignmentExpression'Unds'ListAssignmentExpression{}(X0:SortAssignmentExpression{}, X1:SortListAssignmentExpression{}), Lbl'UndsCommUndsUnds'C-SYNTAX'Unds'ListAssignmentExpression'Unds'AssignmentExpression'Unds'ListAssignmentExpression{}(Y0:SortAssignmentExpression{}, Y1:SortListAssignmentExpression{})), Lbl'UndsCommUndsUnds'C-SYNTAX'Unds'ListAssignmentExpression'Unds'AssignmentExpression'Unds'ListAssignmentExpression{}(\and{SortAssignmentExpression{}} (X0:SortAssignmentExpression{}, Y0:SortAssignmentExpression{}), \and{SortListAssignmentExpression{}} (X1:SortListAssignmentExpression{}, Y1:SortListAssignmentExpression{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortListInitDeclarator{}, \equals{SortListInitDeclarator{}, R} (Val:SortListInitDeclarator{}, Lbl'UndsCommUndsUnds'C-SYNTAX'Unds'ListInitDeclarator'Unds'Initdeclarator'Unds'ListInitDeclarator{}(K0:SortInitdeclarator{}, K1:SortListInitDeclarator{}))) [functional{}()] // functional
  axiom{}\implies{SortListInitDeclarator{}} (\and{SortListInitDeclarator{}} (Lbl'UndsCommUndsUnds'C-SYNTAX'Unds'ListInitDeclarator'Unds'Initdeclarator'Unds'ListInitDeclarator{}(X0:SortInitdeclarator{}, X1:SortListInitDeclarator{}), Lbl'UndsCommUndsUnds'C-SYNTAX'Unds'ListInitDeclarator'Unds'Initdeclarator'Unds'ListInitDeclarator{}(Y0:SortInitdeclarator{}, Y1:SortListInitDeclarator{})), Lbl'UndsCommUndsUnds'C-SYNTAX'Unds'ListInitDeclarator'Unds'Initdeclarator'Unds'ListInitDeclarator{}(\and{SortInitdeclarator{}} (X0:SortInitdeclarator{}, Y0:SortInitdeclarator{}), \and{SortListInitDeclarator{}} (X1:SortListInitDeclarator{}, Y1:SortListInitDeclarator{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortParameterList{}, \equals{SortParameterList{}, R} (Val:SortParameterList{}, Lbl'UndsCommUndsUnds'C-SYNTAX'Unds'ParameterList'Unds'ParameterList'Unds'ParameterDeclaration{}(K0:SortParameterList{}, K1:SortParameterDeclaration{}))) [functional{}()] // functional
  axiom{}\implies{SortParameterList{}} (\and{SortParameterList{}} (Lbl'UndsCommUndsUnds'C-SYNTAX'Unds'ParameterList'Unds'ParameterList'Unds'ParameterDeclaration{}(X0:SortParameterList{}, X1:SortParameterDeclaration{}), Lbl'UndsCommUndsUnds'C-SYNTAX'Unds'ParameterList'Unds'ParameterList'Unds'ParameterDeclaration{}(Y0:SortParameterList{}, Y1:SortParameterDeclaration{})), Lbl'UndsCommUndsUnds'C-SYNTAX'Unds'ParameterList'Unds'ParameterList'Unds'ParameterDeclaration{}(\and{SortParameterList{}} (X0:SortParameterList{}, Y0:SortParameterList{}), \and{SortParameterDeclaration{}} (X1:SortParameterDeclaration{}, Y1:SortParameterDeclaration{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortStructDeclaratorList{}, \equals{SortStructDeclaratorList{}, R} (Val:SortStructDeclaratorList{}, Lbl'UndsCommUndsUnds'C-SYNTAX'Unds'StructDeclaratorList'Unds'StructDeclaratorList'Unds'StructDeclarator{}(K0:SortStructDeclaratorList{}, K1:SortStructDeclarator{}))) [functional{}()] // functional
  axiom{}\implies{SortStructDeclaratorList{}} (\and{SortStructDeclaratorList{}} (Lbl'UndsCommUndsUnds'C-SYNTAX'Unds'StructDeclaratorList'Unds'StructDeclaratorList'Unds'StructDeclarator{}(X0:SortStructDeclaratorList{}, X1:SortStructDeclarator{}), Lbl'UndsCommUndsUnds'C-SYNTAX'Unds'StructDeclaratorList'Unds'StructDeclaratorList'Unds'StructDeclarator{}(Y0:SortStructDeclaratorList{}, Y1:SortStructDeclarator{})), Lbl'UndsCommUndsUnds'C-SYNTAX'Unds'StructDeclaratorList'Unds'StructDeclaratorList'Unds'StructDeclarator{}(\and{SortStructDeclaratorList{}} (X0:SortStructDeclaratorList{}, Y0:SortStructDeclaratorList{}), \and{SortStructDeclarator{}} (X1:SortStructDeclarator{}, Y1:SortStructDeclarator{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortPostfixExpression{}, \equals{SortPostfixExpression{}, R} (Val:SortPostfixExpression{}, Lbl'Unds'--'Unds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression{}(K0:SortPostfixExpression{}))) [functional{}()] // functional
  axiom{}\implies{SortPostfixExpression{}} (\and{SortPostfixExpression{}} (Lbl'Unds'--'Unds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression{}(X0:SortPostfixExpression{}), Lbl'Unds'--'Unds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression{}(Y0:SortPostfixExpression{})), Lbl'Unds'--'Unds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression{}(\and{SortPostfixExpression{}} (X0:SortPostfixExpression{}, Y0:SortPostfixExpression{}))) [constructor{}()] // no confusion same constructor
  axiom{}\not{SortPostfixExpression{}} (\and{SortPostfixExpression{}} (Lbl'Unds'--'Unds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression{}(X0:SortPostfixExpression{}), Lbl'Unds'-'-GT-UndsUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression'Unds'Id{}(Y0:SortPostfixExpression{}, Y1:SortId{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortPostfixExpression{}} (\and{SortPostfixExpression{}} (Lbl'Unds'--'Unds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression{}(X0:SortPostfixExpression{}), Lbl'UndsStopUndsUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression'Unds'Id{}(Y0:SortPostfixExpression{}, Y1:SortId{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortPostfixExpression{}} (\and{SortPostfixExpression{}} (Lbl'Unds'--'Unds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression{}(X0:SortPostfixExpression{}), Lbl'UndsLSqBUndsRSqBUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression'Unds'Expression{}(Y0:SortPostfixExpression{}, Y1:SortExpression{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortPostfixExpression{}, \equals{SortPostfixExpression{}, R} (Val:SortPostfixExpression{}, Lbl'Unds'-'-GT-UndsUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression'Unds'Id{}(K0:SortPostfixExpression{}, K1:SortId{}))) [functional{}()] // functional
  axiom{}\implies{SortPostfixExpression{}} (\and{SortPostfixExpression{}} (Lbl'Unds'-'-GT-UndsUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression'Unds'Id{}(X0:SortPostfixExpression{}, X1:SortId{}), Lbl'Unds'-'-GT-UndsUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression'Unds'Id{}(Y0:SortPostfixExpression{}, Y1:SortId{})), Lbl'Unds'-'-GT-UndsUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression'Unds'Id{}(\and{SortPostfixExpression{}} (X0:SortPostfixExpression{}, Y0:SortPostfixExpression{}), \and{SortId{}} (X1:SortId{}, Y1:SortId{}))) [constructor{}()] // no confusion same constructor
  axiom{}\not{SortPostfixExpression{}} (\and{SortPostfixExpression{}} (Lbl'Unds'-'-GT-UndsUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression'Unds'Id{}(X0:SortPostfixExpression{}, X1:SortId{}), Lbl'UndsStopUndsUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression'Unds'Id{}(Y0:SortPostfixExpression{}, Y1:SortId{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortPostfixExpression{}} (\and{SortPostfixExpression{}} (Lbl'Unds'-'-GT-UndsUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression'Unds'Id{}(X0:SortPostfixExpression{}, X1:SortId{}), Lbl'UndsLSqBUndsRSqBUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression'Unds'Expression{}(Y0:SortPostfixExpression{}, Y1:SortExpression{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortInt{}, \equals{SortInt{}, R} (Val:SortInt{}, Lbl'Unds'-Int'Unds'{}(K0:SortInt{}, K1:SortInt{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortMap{}, \equals{SortMap{}, R} (Val:SortMap{}, Lbl'Unds'-Map'UndsUnds'MAP'Unds'Map'Unds'Map'Unds'Map{}(K0:SortMap{}, K1:SortMap{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortAdditiveExpression{}, \equals{SortAdditiveExpression{}, R} (Val:SortAdditiveExpression{}, Lbl'Unds'-'UndsUnds'C-SYNTAX'Unds'AdditiveExpression'Unds'AdditiveExpression'Unds'MultiplicativeExpression{}(K0:SortAdditiveExpression{}, K1:SortMultiplicativeExpression{}))) [functional{}()] // functional
  axiom{}\implies{SortAdditiveExpression{}} (\and{SortAdditiveExpression{}} (Lbl'Unds'-'UndsUnds'C-SYNTAX'Unds'AdditiveExpression'Unds'AdditiveExpression'Unds'MultiplicativeExpression{}(X0:SortAdditiveExpression{}, X1:SortMultiplicativeExpression{}), Lbl'Unds'-'UndsUnds'C-SYNTAX'Unds'AdditiveExpression'Unds'AdditiveExpression'Unds'MultiplicativeExpression{}(Y0:SortAdditiveExpression{}, Y1:SortMultiplicativeExpression{})), Lbl'Unds'-'UndsUnds'C-SYNTAX'Unds'AdditiveExpression'Unds'AdditiveExpression'Unds'MultiplicativeExpression{}(\and{SortAdditiveExpression{}} (X0:SortAdditiveExpression{}, Y0:SortAdditiveExpression{}), \and{SortMultiplicativeExpression{}} (X1:SortMultiplicativeExpression{}, Y1:SortMultiplicativeExpression{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortPostfixExpression{}, \equals{SortPostfixExpression{}, R} (Val:SortPostfixExpression{}, Lbl'UndsStopUndsUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression'Unds'Id{}(K0:SortPostfixExpression{}, K1:SortId{}))) [functional{}()] // functional
  axiom{}\implies{SortPostfixExpression{}} (\and{SortPostfixExpression{}} (Lbl'UndsStopUndsUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression'Unds'Id{}(X0:SortPostfixExpression{}, X1:SortId{}), Lbl'UndsStopUndsUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression'Unds'Id{}(Y0:SortPostfixExpression{}, Y1:SortId{})), Lbl'UndsStopUndsUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression'Unds'Id{}(\and{SortPostfixExpression{}} (X0:SortPostfixExpression{}, Y0:SortPostfixExpression{}), \and{SortId{}} (X1:SortId{}, Y1:SortId{}))) [constructor{}()] // no confusion same constructor
  axiom{}\not{SortPostfixExpression{}} (\and{SortPostfixExpression{}} (Lbl'UndsStopUndsUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression'Unds'Id{}(X0:SortPostfixExpression{}, X1:SortId{}), Lbl'UndsLSqBUndsRSqBUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression'Unds'Expression{}(Y0:SortPostfixExpression{}, Y1:SortExpression{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortMultiplicativeExpression{}, \equals{SortMultiplicativeExpression{}, R} (Val:SortMultiplicativeExpression{}, Lbl'UndsSlshUndsUnds'C-SYNTAX'Unds'MultiplicativeExpression'Unds'MultiplicativeExpression'Unds'CastExpression{}(K0:SortMultiplicativeExpression{}, K1:SortCastExpression{}))) [functional{}()] // functional
  axiom{}\implies{SortMultiplicativeExpression{}} (\and{SortMultiplicativeExpression{}} (Lbl'UndsSlshUndsUnds'C-SYNTAX'Unds'MultiplicativeExpression'Unds'MultiplicativeExpression'Unds'CastExpression{}(X0:SortMultiplicativeExpression{}, X1:SortCastExpression{}), Lbl'UndsSlshUndsUnds'C-SYNTAX'Unds'MultiplicativeExpression'Unds'MultiplicativeExpression'Unds'CastExpression{}(Y0:SortMultiplicativeExpression{}, Y1:SortCastExpression{})), Lbl'UndsSlshUndsUnds'C-SYNTAX'Unds'MultiplicativeExpression'Unds'MultiplicativeExpression'Unds'CastExpression{}(\and{SortMultiplicativeExpression{}} (X0:SortMultiplicativeExpression{}, Y0:SortMultiplicativeExpression{}), \and{SortCastExpression{}} (X1:SortCastExpression{}, Y1:SortCastExpression{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortLabeledStatement{}, \equals{SortLabeledStatement{}, R} (Val:SortLabeledStatement{}, Lbl'UndsColnUndsUnds'C-SYNTAX'Unds'LabeledStatement'Unds'Id'Unds'Statement{}(K0:SortId{}, K1:SortStatement{}))) [functional{}()] // functional
  axiom{}\implies{SortLabeledStatement{}} (\and{SortLabeledStatement{}} (Lbl'UndsColnUndsUnds'C-SYNTAX'Unds'LabeledStatement'Unds'Id'Unds'Statement{}(X0:SortId{}, X1:SortStatement{}), Lbl'UndsColnUndsUnds'C-SYNTAX'Unds'LabeledStatement'Unds'Id'Unds'Statement{}(Y0:SortId{}, Y1:SortStatement{})), Lbl'UndsColnUndsUnds'C-SYNTAX'Unds'LabeledStatement'Unds'Id'Unds'Statement{}(\and{SortId{}} (X0:SortId{}, Y0:SortId{}), \and{SortStatement{}} (X1:SortStatement{}, Y1:SortStatement{}))) [constructor{}()] // no confusion same constructor
  axiom{}\not{SortLabeledStatement{}} (\and{SortLabeledStatement{}} (Lbl'UndsColnUndsUnds'C-SYNTAX'Unds'LabeledStatement'Unds'Id'Unds'Statement{}(X0:SortId{}, X1:SortStatement{}), Lblcase'UndsColnUndsUnds'C-SYNTAX'Unds'LabeledStatement'Unds'ConstantExpression'Unds'Statement{}(Y0:SortConstantExpression{}, Y1:SortStatement{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortLabeledStatement{}} (\and{SortLabeledStatement{}} (Lbl'UndsColnUndsUnds'C-SYNTAX'Unds'LabeledStatement'Unds'Id'Unds'Statement{}(X0:SortId{}, X1:SortStatement{}), Lbldefault'ColnUndsUnds'C-SYNTAX'Unds'LabeledStatement'Unds'Statement{}(Y0:SortStatement{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortStructDeclarator{}, \equals{SortStructDeclarator{}, R} (Val:SortStructDeclarator{}, Lbl'UndsColnUndsUnds'C-SYNTAX'Unds'StructDeclarator'Unds'Declarator'Unds'ConstantExpression{}(K0:SortDeclarator{}, K1:SortConstantExpression{}))) [functional{}()] // functional
  axiom{}\implies{SortStructDeclarator{}} (\and{SortStructDeclarator{}} (Lbl'UndsColnUndsUnds'C-SYNTAX'Unds'StructDeclarator'Unds'Declarator'Unds'ConstantExpression{}(X0:SortDeclarator{}, X1:SortConstantExpression{}), Lbl'UndsColnUndsUnds'C-SYNTAX'Unds'StructDeclarator'Unds'Declarator'Unds'ConstantExpression{}(Y0:SortDeclarator{}, Y1:SortConstantExpression{})), Lbl'UndsColnUndsUnds'C-SYNTAX'Unds'StructDeclarator'Unds'Declarator'Unds'ConstantExpression{}(\and{SortDeclarator{}} (X0:SortDeclarator{}, Y0:SortDeclarator{}), \and{SortConstantExpression{}} (X1:SortConstantExpression{}, Y1:SortConstantExpression{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortExpressionStatement{}, \equals{SortExpressionStatement{}, R} (Val:SortExpressionStatement{}, Lbl'UndsSClnUnds'C-SYNTAX'Unds'ExpressionStatement'Unds'Expression{}(K0:SortExpression{}))) [functional{}()] // functional
  axiom{}\implies{SortExpressionStatement{}} (\and{SortExpressionStatement{}} (Lbl'UndsSClnUnds'C-SYNTAX'Unds'ExpressionStatement'Unds'Expression{}(X0:SortExpression{}), Lbl'UndsSClnUnds'C-SYNTAX'Unds'ExpressionStatement'Unds'Expression{}(Y0:SortExpression{})), Lbl'UndsSClnUnds'C-SYNTAX'Unds'ExpressionStatement'Unds'Expression{}(\and{SortExpression{}} (X0:SortExpression{}, Y0:SortExpression{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortListStructDeclaration{}, \equals{SortListStructDeclaration{}, R} (Val:SortListStructDeclaration{}, Lbl'UndsSClnUndsUnds'C-SYNTAX'Unds'ListStructDeclaration'Unds'StructDeclaration'Unds'ListStructDeclaration{}(K0:SortStructDeclaration{}, K1:SortListStructDeclaration{}))) [functional{}()] // functional
  axiom{}\implies{SortListStructDeclaration{}} (\and{SortListStructDeclaration{}} (Lbl'UndsSClnUndsUnds'C-SYNTAX'Unds'ListStructDeclaration'Unds'StructDeclaration'Unds'ListStructDeclaration{}(X0:SortStructDeclaration{}, X1:SortListStructDeclaration{}), Lbl'UndsSClnUndsUnds'C-SYNTAX'Unds'ListStructDeclaration'Unds'StructDeclaration'Unds'ListStructDeclaration{}(Y0:SortStructDeclaration{}, Y1:SortListStructDeclaration{})), Lbl'UndsSClnUndsUnds'C-SYNTAX'Unds'ListStructDeclaration'Unds'StructDeclaration'Unds'ListStructDeclaration{}(\and{SortStructDeclaration{}} (X0:SortStructDeclaration{}, Y0:SortStructDeclaration{}), \and{SortListStructDeclaration{}} (X1:SortListStructDeclaration{}, Y1:SortListStructDeclaration{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortShiftExpression{}, \equals{SortShiftExpression{}, R} (Val:SortShiftExpression{}, Lbl'Unds-LT--LT-UndsUnds'C-SYNTAX'Unds'ShiftExpression'Unds'ShiftExpression'Unds'AdditiveExpression{}(K0:SortShiftExpression{}, K1:SortAdditiveExpression{}))) [functional{}()] // functional
  axiom{}\implies{SortShiftExpression{}} (\and{SortShiftExpression{}} (Lbl'Unds-LT--LT-UndsUnds'C-SYNTAX'Unds'ShiftExpression'Unds'ShiftExpression'Unds'AdditiveExpression{}(X0:SortShiftExpression{}, X1:SortAdditiveExpression{}), Lbl'Unds-LT--LT-UndsUnds'C-SYNTAX'Unds'ShiftExpression'Unds'ShiftExpression'Unds'AdditiveExpression{}(Y0:SortShiftExpression{}, Y1:SortAdditiveExpression{})), Lbl'Unds-LT--LT-UndsUnds'C-SYNTAX'Unds'ShiftExpression'Unds'ShiftExpression'Unds'AdditiveExpression{}(\and{SortShiftExpression{}} (X0:SortShiftExpression{}, Y0:SortShiftExpression{}), \and{SortAdditiveExpression{}} (X1:SortAdditiveExpression{}, Y1:SortAdditiveExpression{}))) [constructor{}()] // no confusion same constructor
  axiom{}\not{SortShiftExpression{}} (\and{SortShiftExpression{}} (Lbl'Unds-LT--LT-UndsUnds'C-SYNTAX'Unds'ShiftExpression'Unds'ShiftExpression'Unds'AdditiveExpression{}(X0:SortShiftExpression{}, X1:SortAdditiveExpression{}), Lbl'Unds-GT--GT-UndsUnds'C-SYNTAX'Unds'ShiftExpression'Unds'ShiftExpression'Unds'AdditiveExpression{}(Y0:SortShiftExpression{}, Y1:SortAdditiveExpression{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortBool{}, \equals{SortBool{}, R} (Val:SortBool{}, Lbl'Unds-LT-Eqls'Int'Unds'{}(K0:SortInt{}, K1:SortInt{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortBool{}, \equals{SortBool{}, R} (Val:SortBool{}, Lbl'Unds-LT-Eqls'Map'UndsUnds'MAP'Unds'Bool'Unds'Map'Unds'Map{}(K0:SortMap{}, K1:SortMap{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortBool{}, \equals{SortBool{}, R} (Val:SortBool{}, Lbl'Unds-LT-Eqls'Set'UndsUnds'SET'Unds'Bool'Unds'Set'Unds'Set{}(K0:SortSet{}, K1:SortSet{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortBool{}, \equals{SortBool{}, R} (Val:SortBool{}, Lbl'Unds-LT-Eqls'String'UndsUnds'STRING-COMMON'Unds'Bool'Unds'String'Unds'String{}(K0:SortString{}, K1:SortString{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortRelationalExpression{}, \equals{SortRelationalExpression{}, R} (Val:SortRelationalExpression{}, Lbl'Unds-LT-EqlsUndsUnds'C-SYNTAX'Unds'RelationalExpression'Unds'RelationalExpression'Unds'ShiftExpression{}(K0:SortRelationalExpression{}, K1:SortShiftExpression{}))) [functional{}()] // functional
  axiom{}\implies{SortRelationalExpression{}} (\and{SortRelationalExpression{}} (Lbl'Unds-LT-EqlsUndsUnds'C-SYNTAX'Unds'RelationalExpression'Unds'RelationalExpression'Unds'ShiftExpression{}(X0:SortRelationalExpression{}, X1:SortShiftExpression{}), Lbl'Unds-LT-EqlsUndsUnds'C-SYNTAX'Unds'RelationalExpression'Unds'RelationalExpression'Unds'ShiftExpression{}(Y0:SortRelationalExpression{}, Y1:SortShiftExpression{})), Lbl'Unds-LT-EqlsUndsUnds'C-SYNTAX'Unds'RelationalExpression'Unds'RelationalExpression'Unds'ShiftExpression{}(\and{SortRelationalExpression{}} (X0:SortRelationalExpression{}, Y0:SortRelationalExpression{}), \and{SortShiftExpression{}} (X1:SortShiftExpression{}, Y1:SortShiftExpression{}))) [constructor{}()] // no confusion same constructor
  axiom{}\not{SortRelationalExpression{}} (\and{SortRelationalExpression{}} (Lbl'Unds-LT-EqlsUndsUnds'C-SYNTAX'Unds'RelationalExpression'Unds'RelationalExpression'Unds'ShiftExpression{}(X0:SortRelationalExpression{}, X1:SortShiftExpression{}), Lbl'Unds-LT-UndsUnds'C-SYNTAX'Unds'RelationalExpression'Unds'RelationalExpression'Unds'ShiftExpression{}(Y0:SortRelationalExpression{}, Y1:SortShiftExpression{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortRelationalExpression{}} (\and{SortRelationalExpression{}} (Lbl'Unds-LT-EqlsUndsUnds'C-SYNTAX'Unds'RelationalExpression'Unds'RelationalExpression'Unds'ShiftExpression{}(X0:SortRelationalExpression{}, X1:SortShiftExpression{}), Lbl'Unds-GT-EqlsUndsUnds'C-SYNTAX'Unds'RelationalExpression'Unds'RelationalExpression'Unds'ShiftExpression{}(Y0:SortRelationalExpression{}, Y1:SortShiftExpression{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortRelationalExpression{}} (\and{SortRelationalExpression{}} (Lbl'Unds-LT-EqlsUndsUnds'C-SYNTAX'Unds'RelationalExpression'Unds'RelationalExpression'Unds'ShiftExpression{}(X0:SortRelationalExpression{}, X1:SortShiftExpression{}), Lbl'Unds-GT-UndsUnds'C-SYNTAX'Unds'RelationalExpression'Unds'RelationalExpression'Unds'ShiftExpression{}(Y0:SortRelationalExpression{}, Y1:SortShiftExpression{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortBool{}, \equals{SortBool{}, R} (Val:SortBool{}, Lbl'Unds-LT-'Int'Unds'{}(K0:SortInt{}, K1:SortInt{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortBool{}, \equals{SortBool{}, R} (Val:SortBool{}, Lbl'Unds-LT-'String'UndsUnds'STRING-COMMON'Unds'Bool'Unds'String'Unds'String{}(K0:SortString{}, K1:SortString{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortRelationalExpression{}, \equals{SortRelationalExpression{}, R} (Val:SortRelationalExpression{}, Lbl'Unds-LT-UndsUnds'C-SYNTAX'Unds'RelationalExpression'Unds'RelationalExpression'Unds'ShiftExpression{}(K0:SortRelationalExpression{}, K1:SortShiftExpression{}))) [functional{}()] // functional
  axiom{}\implies{SortRelationalExpression{}} (\and{SortRelationalExpression{}} (Lbl'Unds-LT-UndsUnds'C-SYNTAX'Unds'RelationalExpression'Unds'RelationalExpression'Unds'ShiftExpression{}(X0:SortRelationalExpression{}, X1:SortShiftExpression{}), Lbl'Unds-LT-UndsUnds'C-SYNTAX'Unds'RelationalExpression'Unds'RelationalExpression'Unds'ShiftExpression{}(Y0:SortRelationalExpression{}, Y1:SortShiftExpression{})), Lbl'Unds-LT-UndsUnds'C-SYNTAX'Unds'RelationalExpression'Unds'RelationalExpression'Unds'ShiftExpression{}(\and{SortRelationalExpression{}} (X0:SortRelationalExpression{}, Y0:SortRelationalExpression{}), \and{SortShiftExpression{}} (X1:SortShiftExpression{}, Y1:SortShiftExpression{}))) [constructor{}()] // no confusion same constructor
  axiom{}\not{SortRelationalExpression{}} (\and{SortRelationalExpression{}} (Lbl'Unds-LT-UndsUnds'C-SYNTAX'Unds'RelationalExpression'Unds'RelationalExpression'Unds'ShiftExpression{}(X0:SortRelationalExpression{}, X1:SortShiftExpression{}), Lbl'Unds-GT-EqlsUndsUnds'C-SYNTAX'Unds'RelationalExpression'Unds'RelationalExpression'Unds'ShiftExpression{}(Y0:SortRelationalExpression{}, Y1:SortShiftExpression{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortRelationalExpression{}} (\and{SortRelationalExpression{}} (Lbl'Unds-LT-UndsUnds'C-SYNTAX'Unds'RelationalExpression'Unds'RelationalExpression'Unds'ShiftExpression{}(X0:SortRelationalExpression{}, X1:SortShiftExpression{}), Lbl'Unds-GT-UndsUnds'C-SYNTAX'Unds'RelationalExpression'Unds'RelationalExpression'Unds'ShiftExpression{}(Y0:SortRelationalExpression{}, Y1:SortShiftExpression{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortBool{}, \equals{SortBool{}, R} (Val:SortBool{}, Lbl'UndsEqlsSlshEqls'Bool'Unds'{}(K0:SortBool{}, K1:SortBool{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortBool{}, \equals{SortBool{}, R} (Val:SortBool{}, Lbl'UndsEqlsSlshEqls'Int'Unds'{}(K0:SortInt{}, K1:SortInt{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortBool{}, \equals{SortBool{}, R} (Val:SortBool{}, Lbl'UndsEqlsSlshEqls'K'Unds'{}(K0:SortK{}, K1:SortK{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortBool{}, \equals{SortBool{}, R} (Val:SortBool{}, Lbl'UndsEqlsSlshEqls'String'UndsUnds'STRING-COMMON'Unds'Bool'Unds'String'Unds'String{}(K0:SortString{}, K1:SortString{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortBool{}, \equals{SortBool{}, R} (Val:SortBool{}, Lbl'UndsEqlsEqls'Bool'Unds'{}(K0:SortBool{}, K1:SortBool{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortBool{}, \equals{SortBool{}, R} (Val:SortBool{}, Lbl'UndsEqlsEqls'Int'Unds'{}(K0:SortInt{}, K1:SortInt{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortBool{}, \equals{SortBool{}, R} (Val:SortBool{}, Lbl'UndsEqlsEqls'K'Unds'{}(K0:SortK{}, K1:SortK{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortBool{}, \equals{SortBool{}, R} (Val:SortBool{}, Lbl'UndsEqlsEqls'String'UndsUnds'STRING-COMMON'Unds'Bool'Unds'String'Unds'String{}(K0:SortString{}, K1:SortString{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortEqualityExpression{}, \equals{SortEqualityExpression{}, R} (Val:SortEqualityExpression{}, Lbl'UndsEqlsEqlsUndsUnds'C-SYNTAX'Unds'EqualityExpression'Unds'EqualityExpression'Unds'RelationalExpression{}(K0:SortEqualityExpression{}, K1:SortRelationalExpression{}))) [functional{}()] // functional
  axiom{}\implies{SortEqualityExpression{}} (\and{SortEqualityExpression{}} (Lbl'UndsEqlsEqlsUndsUnds'C-SYNTAX'Unds'EqualityExpression'Unds'EqualityExpression'Unds'RelationalExpression{}(X0:SortEqualityExpression{}, X1:SortRelationalExpression{}), Lbl'UndsEqlsEqlsUndsUnds'C-SYNTAX'Unds'EqualityExpression'Unds'EqualityExpression'Unds'RelationalExpression{}(Y0:SortEqualityExpression{}, Y1:SortRelationalExpression{})), Lbl'UndsEqlsEqlsUndsUnds'C-SYNTAX'Unds'EqualityExpression'Unds'EqualityExpression'Unds'RelationalExpression{}(\and{SortEqualityExpression{}} (X0:SortEqualityExpression{}, Y0:SortEqualityExpression{}), \and{SortRelationalExpression{}} (X1:SortRelationalExpression{}, Y1:SortRelationalExpression{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortEnumerator{}, \equals{SortEnumerator{}, R} (Val:SortEnumerator{}, Lbl'UndsEqlsUndsUnds'C-SYNTAX'Unds'Enumerator'Unds'Id'Unds'Int{}(K0:SortId{}, K1:SortInt{}))) [functional{}()] // functional
  axiom{}\implies{SortEnumerator{}} (\and{SortEnumerator{}} (Lbl'UndsEqlsUndsUnds'C-SYNTAX'Unds'Enumerator'Unds'Id'Unds'Int{}(X0:SortId{}, X1:SortInt{}), Lbl'UndsEqlsUndsUnds'C-SYNTAX'Unds'Enumerator'Unds'Id'Unds'Int{}(Y0:SortId{}, Y1:SortInt{})), Lbl'UndsEqlsUndsUnds'C-SYNTAX'Unds'Enumerator'Unds'Id'Unds'Int{}(\and{SortId{}} (X0:SortId{}, Y0:SortId{}), \and{SortInt{}} (X1:SortInt{}, Y1:SortInt{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortInitdeclarator{}, \equals{SortInitdeclarator{}, R} (Val:SortInitdeclarator{}, Lbl'UndsEqlsUndsUnds'C-SYNTAX'Unds'Initdeclarator'Unds'Declarator'Unds'Initializer{}(K0:SortDeclarator{}, K1:SortInitializer{}))) [functional{}()] // functional
  axiom{}\implies{SortInitdeclarator{}} (\and{SortInitdeclarator{}} (Lbl'UndsEqlsUndsUnds'C-SYNTAX'Unds'Initdeclarator'Unds'Declarator'Unds'Initializer{}(X0:SortDeclarator{}, X1:SortInitializer{}), Lbl'UndsEqlsUndsUnds'C-SYNTAX'Unds'Initdeclarator'Unds'Declarator'Unds'Initializer{}(Y0:SortDeclarator{}, Y1:SortInitializer{})), Lbl'UndsEqlsUndsUnds'C-SYNTAX'Unds'Initdeclarator'Unds'Declarator'Unds'Initializer{}(\and{SortDeclarator{}} (X0:SortDeclarator{}, Y0:SortDeclarator{}), \and{SortInitializer{}} (X1:SortInitializer{}, Y1:SortInitializer{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortBool{}, \equals{SortBool{}, R} (Val:SortBool{}, Lbl'Unds-GT-Eqls'Int'Unds'{}(K0:SortInt{}, K1:SortInt{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortBool{}, \equals{SortBool{}, R} (Val:SortBool{}, Lbl'Unds-GT-Eqls'String'UndsUnds'STRING-COMMON'Unds'Bool'Unds'String'Unds'String{}(K0:SortString{}, K1:SortString{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortRelationalExpression{}, \equals{SortRelationalExpression{}, R} (Val:SortRelationalExpression{}, Lbl'Unds-GT-EqlsUndsUnds'C-SYNTAX'Unds'RelationalExpression'Unds'RelationalExpression'Unds'ShiftExpression{}(K0:SortRelationalExpression{}, K1:SortShiftExpression{}))) [functional{}()] // functional
  axiom{}\implies{SortRelationalExpression{}} (\and{SortRelationalExpression{}} (Lbl'Unds-GT-EqlsUndsUnds'C-SYNTAX'Unds'RelationalExpression'Unds'RelationalExpression'Unds'ShiftExpression{}(X0:SortRelationalExpression{}, X1:SortShiftExpression{}), Lbl'Unds-GT-EqlsUndsUnds'C-SYNTAX'Unds'RelationalExpression'Unds'RelationalExpression'Unds'ShiftExpression{}(Y0:SortRelationalExpression{}, Y1:SortShiftExpression{})), Lbl'Unds-GT-EqlsUndsUnds'C-SYNTAX'Unds'RelationalExpression'Unds'RelationalExpression'Unds'ShiftExpression{}(\and{SortRelationalExpression{}} (X0:SortRelationalExpression{}, Y0:SortRelationalExpression{}), \and{SortShiftExpression{}} (X1:SortShiftExpression{}, Y1:SortShiftExpression{}))) [constructor{}()] // no confusion same constructor
  axiom{}\not{SortRelationalExpression{}} (\and{SortRelationalExpression{}} (Lbl'Unds-GT-EqlsUndsUnds'C-SYNTAX'Unds'RelationalExpression'Unds'RelationalExpression'Unds'ShiftExpression{}(X0:SortRelationalExpression{}, X1:SortShiftExpression{}), Lbl'Unds-GT-UndsUnds'C-SYNTAX'Unds'RelationalExpression'Unds'RelationalExpression'Unds'ShiftExpression{}(Y0:SortRelationalExpression{}, Y1:SortShiftExpression{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortShiftExpression{}, \equals{SortShiftExpression{}, R} (Val:SortShiftExpression{}, Lbl'Unds-GT--GT-UndsUnds'C-SYNTAX'Unds'ShiftExpression'Unds'ShiftExpression'Unds'AdditiveExpression{}(K0:SortShiftExpression{}, K1:SortAdditiveExpression{}))) [functional{}()] // functional
  axiom{}\implies{SortShiftExpression{}} (\and{SortShiftExpression{}} (Lbl'Unds-GT--GT-UndsUnds'C-SYNTAX'Unds'ShiftExpression'Unds'ShiftExpression'Unds'AdditiveExpression{}(X0:SortShiftExpression{}, X1:SortAdditiveExpression{}), Lbl'Unds-GT--GT-UndsUnds'C-SYNTAX'Unds'ShiftExpression'Unds'ShiftExpression'Unds'AdditiveExpression{}(Y0:SortShiftExpression{}, Y1:SortAdditiveExpression{})), Lbl'Unds-GT--GT-UndsUnds'C-SYNTAX'Unds'ShiftExpression'Unds'ShiftExpression'Unds'AdditiveExpression{}(\and{SortShiftExpression{}} (X0:SortShiftExpression{}, Y0:SortShiftExpression{}), \and{SortAdditiveExpression{}} (X1:SortAdditiveExpression{}, Y1:SortAdditiveExpression{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortBool{}, \equals{SortBool{}, R} (Val:SortBool{}, Lbl'Unds-GT-'Int'Unds'{}(K0:SortInt{}, K1:SortInt{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortBool{}, \equals{SortBool{}, R} (Val:SortBool{}, Lbl'Unds-GT-'String'UndsUnds'STRING-COMMON'Unds'Bool'Unds'String'Unds'String{}(K0:SortString{}, K1:SortString{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortRelationalExpression{}, \equals{SortRelationalExpression{}, R} (Val:SortRelationalExpression{}, Lbl'Unds-GT-UndsUnds'C-SYNTAX'Unds'RelationalExpression'Unds'RelationalExpression'Unds'ShiftExpression{}(K0:SortRelationalExpression{}, K1:SortShiftExpression{}))) [functional{}()] // functional
  axiom{}\implies{SortRelationalExpression{}} (\and{SortRelationalExpression{}} (Lbl'Unds-GT-UndsUnds'C-SYNTAX'Unds'RelationalExpression'Unds'RelationalExpression'Unds'ShiftExpression{}(X0:SortRelationalExpression{}, X1:SortShiftExpression{}), Lbl'Unds-GT-UndsUnds'C-SYNTAX'Unds'RelationalExpression'Unds'RelationalExpression'Unds'ShiftExpression{}(Y0:SortRelationalExpression{}, Y1:SortShiftExpression{})), Lbl'Unds-GT-UndsUnds'C-SYNTAX'Unds'RelationalExpression'Unds'RelationalExpression'Unds'ShiftExpression{}(\and{SortRelationalExpression{}} (X0:SortRelationalExpression{}, Y0:SortRelationalExpression{}), \and{SortShiftExpression{}} (X1:SortShiftExpression{}, Y1:SortShiftExpression{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortConditionalExpression{}, \equals{SortConditionalExpression{}, R} (Val:SortConditionalExpression{}, Lbl'UndsQuesUndsColnUndsUnds'C-SYNTAX'Unds'ConditionalExpression'Unds'LogicalOforExpression'Unds'Expression'Unds'ConditionalExpression{}(K0:SortLogicalOforExpression{}, K1:SortExpression{}, K2:SortConditionalExpression{}))) [functional{}()] // functional
  axiom{}\implies{SortConditionalExpression{}} (\and{SortConditionalExpression{}} (Lbl'UndsQuesUndsColnUndsUnds'C-SYNTAX'Unds'ConditionalExpression'Unds'LogicalOforExpression'Unds'Expression'Unds'ConditionalExpression{}(X0:SortLogicalOforExpression{}, X1:SortExpression{}, X2:SortConditionalExpression{}), Lbl'UndsQuesUndsColnUndsUnds'C-SYNTAX'Unds'ConditionalExpression'Unds'LogicalOforExpression'Unds'Expression'Unds'ConditionalExpression{}(Y0:SortLogicalOforExpression{}, Y1:SortExpression{}, Y2:SortConditionalExpression{})), Lbl'UndsQuesUndsColnUndsUnds'C-SYNTAX'Unds'ConditionalExpression'Unds'LogicalOforExpression'Unds'Expression'Unds'ConditionalExpression{}(\and{SortLogicalOforExpression{}} (X0:SortLogicalOforExpression{}, Y0:SortLogicalOforExpression{}), \and{SortExpression{}} (X1:SortExpression{}, Y1:SortExpression{}), \and{SortConditionalExpression{}} (X2:SortConditionalExpression{}, Y2:SortConditionalExpression{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \equals{SortList{}, R} (Lbl'Unds'List'Unds'{}(Lbl'Unds'List'Unds'{}(K1:SortList{},K2:SortList{}),K3:SortList{}),Lbl'Unds'List'Unds'{}(K1:SortList{},Lbl'Unds'List'Unds'{}(K2:SortList{},K3:SortList{}))) [assoc{}()] // associativity
  axiom{R}\equals{SortList{}, R} (Lbl'Unds'List'Unds'{}(K:SortList{},Lbl'Stop'List{}()),K:SortList{}) [unit{}()] // right unit
  axiom{R}\equals{SortList{}, R} (Lbl'Unds'List'Unds'{}(Lbl'Stop'List{}(),K:SortList{}),K:SortList{}) [unit{}()] // left unit
  axiom{R} \exists{R} (Val:SortList{}, \equals{SortList{}, R} (Val:SortList{}, Lbl'Unds'List'Unds'{}(K0:SortList{}, K1:SortList{}))) [functional{}()] // functional
  axiom{R} \equals{SortMap{}, R} (Lbl'Unds'Map'Unds'{}(Lbl'Unds'Map'Unds'{}(K1:SortMap{},K2:SortMap{}),K3:SortMap{}),Lbl'Unds'Map'Unds'{}(K1:SortMap{},Lbl'Unds'Map'Unds'{}(K2:SortMap{},K3:SortMap{}))) [assoc{}()] // associativity
  axiom{R} \equals{SortMap{}, R} (Lbl'Unds'Map'Unds'{}(K1:SortMap{},K2:SortMap{}),Lbl'Unds'Map'Unds'{}(K2:SortMap{},K1:SortMap{})) [comm{}()] // commutativity
  axiom{R}\equals{SortMap{}, R} (Lbl'Unds'Map'Unds'{}(K:SortMap{},Lbl'Stop'Map{}()),K:SortMap{}) [unit{}()] // right unit
  axiom{R}\equals{SortMap{}, R} (Lbl'Unds'Map'Unds'{}(Lbl'Stop'Map{}(),K:SortMap{}),K:SortMap{}) [unit{}()] // left unit
  axiom{R} \equals{SortSet{}, R} (Lbl'Unds'Set'Unds'{}(Lbl'Unds'Set'Unds'{}(K1:SortSet{},K2:SortSet{}),K3:SortSet{}),Lbl'Unds'Set'Unds'{}(K1:SortSet{},Lbl'Unds'Set'Unds'{}(K2:SortSet{},K3:SortSet{}))) [assoc{}()] // associativity
  axiom{R} \equals{SortSet{}, R} (Lbl'Unds'Set'Unds'{}(K1:SortSet{},K2:SortSet{}),Lbl'Unds'Set'Unds'{}(K2:SortSet{},K1:SortSet{})) [comm{}()] // commutativity
  axiom{R} \equals{SortSet{}, R} (Lbl'Unds'Set'Unds'{}(K:SortSet{},K:SortSet{}),K:SortSet{}) [idem{}()] // idempotency
  axiom{R}\equals{SortSet{}, R} (Lbl'Unds'Set'Unds'{}(K:SortSet{},Lbl'Stop'Set{}()),K:SortSet{}) [unit{}()] // right unit
  axiom{R}\equals{SortSet{}, R} (Lbl'Unds'Set'Unds'{}(Lbl'Stop'Set{}(),K:SortSet{}),K:SortSet{}) [unit{}()] // left unit
  axiom{R} \exists{R} (Val:SortSet{}, \equals{SortSet{}, R} (Val:SortSet{}, Lbl'Unds'Set'Unds'{}(K0:SortSet{}, K1:SortSet{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortDirectAbstractDeclarator{}, \equals{SortDirectAbstractDeclarator{}, R} (Val:SortDirectAbstractDeclarator{}, Lbl'UndsLSqBRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator{}(K0:SortDirectAbstractDeclarator{}))) [functional{}()] // functional
  axiom{}\implies{SortDirectAbstractDeclarator{}} (\and{SortDirectAbstractDeclarator{}} (Lbl'UndsLSqBRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator{}(X0:SortDirectAbstractDeclarator{}), Lbl'UndsLSqBRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator{}(Y0:SortDirectAbstractDeclarator{})), Lbl'UndsLSqBRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator{}(\and{SortDirectAbstractDeclarator{}} (X0:SortDirectAbstractDeclarator{}, Y0:SortDirectAbstractDeclarator{}))) [constructor{}()] // no confusion same constructor
  axiom{}\not{SortDirectAbstractDeclarator{}} (\and{SortDirectAbstractDeclarator{}} (Lbl'UndsLSqBRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator{}(X0:SortDirectAbstractDeclarator{}), Lbl'UndsLSqBUndsRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator'Unds'ConstantExpression{}(Y0:SortDirectAbstractDeclarator{}, Y1:SortConstantExpression{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortDirectDeclarator{}, \equals{SortDirectDeclarator{}, R} (Val:SortDirectDeclarator{}, Lbl'UndsLSqBRSqBUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'DirectDeclarator{}(K0:SortDirectDeclarator{}))) [functional{}()] // functional
  axiom{}\implies{SortDirectDeclarator{}} (\and{SortDirectDeclarator{}} (Lbl'UndsLSqBRSqBUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'DirectDeclarator{}(X0:SortDirectDeclarator{}), Lbl'UndsLSqBRSqBUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'DirectDeclarator{}(Y0:SortDirectDeclarator{})), Lbl'UndsLSqBRSqBUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'DirectDeclarator{}(\and{SortDirectDeclarator{}} (X0:SortDirectDeclarator{}, Y0:SortDirectDeclarator{}))) [constructor{}()] // no confusion same constructor
  axiom{}\not{SortDirectDeclarator{}} (\and{SortDirectDeclarator{}} (Lbl'UndsLSqBRSqBUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'DirectDeclarator{}(X0:SortDirectDeclarator{}), Lbl'UndsLSqBUndsRSqBUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'DirectDeclarator'Unds'ConstantExpression{}(Y0:SortDirectDeclarator{}, Y1:SortConstantExpression{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortMap{}, \equals{SortMap{}, R} (Val:SortMap{}, Lbl'UndsLSqBUnds-LT-'-undef'RSqB'{}(K0:SortMap{}, K1:SortKItem{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortDirectAbstractDeclarator{}, \equals{SortDirectAbstractDeclarator{}, R} (Val:SortDirectAbstractDeclarator{}, Lbl'UndsLSqBUndsRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator'Unds'ConstantExpression{}(K0:SortDirectAbstractDeclarator{}, K1:SortConstantExpression{}))) [functional{}()] // functional
  axiom{}\implies{SortDirectAbstractDeclarator{}} (\and{SortDirectAbstractDeclarator{}} (Lbl'UndsLSqBUndsRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator'Unds'ConstantExpression{}(X0:SortDirectAbstractDeclarator{}, X1:SortConstantExpression{}), Lbl'UndsLSqBUndsRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator'Unds'ConstantExpression{}(Y0:SortDirectAbstractDeclarator{}, Y1:SortConstantExpression{})), Lbl'UndsLSqBUndsRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator'Unds'ConstantExpression{}(\and{SortDirectAbstractDeclarator{}} (X0:SortDirectAbstractDeclarator{}, Y0:SortDirectAbstractDeclarator{}), \and{SortConstantExpression{}} (X1:SortConstantExpression{}, Y1:SortConstantExpression{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortDirectDeclarator{}, \equals{SortDirectDeclarator{}, R} (Val:SortDirectDeclarator{}, Lbl'UndsLSqBUndsRSqBUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'DirectDeclarator'Unds'ConstantExpression{}(K0:SortDirectDeclarator{}, K1:SortConstantExpression{}))) [functional{}()] // functional
  axiom{}\implies{SortDirectDeclarator{}} (\and{SortDirectDeclarator{}} (Lbl'UndsLSqBUndsRSqBUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'DirectDeclarator'Unds'ConstantExpression{}(X0:SortDirectDeclarator{}, X1:SortConstantExpression{}), Lbl'UndsLSqBUndsRSqBUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'DirectDeclarator'Unds'ConstantExpression{}(Y0:SortDirectDeclarator{}, Y1:SortConstantExpression{})), Lbl'UndsLSqBUndsRSqBUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'DirectDeclarator'Unds'ConstantExpression{}(\and{SortDirectDeclarator{}} (X0:SortDirectDeclarator{}, Y0:SortDirectDeclarator{}), \and{SortConstantExpression{}} (X1:SortConstantExpression{}, Y1:SortConstantExpression{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortPostfixExpression{}, \equals{SortPostfixExpression{}, R} (Val:SortPostfixExpression{}, Lbl'UndsLSqBUndsRSqBUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression'Unds'Expression{}(K0:SortPostfixExpression{}, K1:SortExpression{}))) [functional{}()] // functional
  axiom{}\implies{SortPostfixExpression{}} (\and{SortPostfixExpression{}} (Lbl'UndsLSqBUndsRSqBUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression'Unds'Expression{}(X0:SortPostfixExpression{}, X1:SortExpression{}), Lbl'UndsLSqBUndsRSqBUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression'Unds'Expression{}(Y0:SortPostfixExpression{}, Y1:SortExpression{})), Lbl'UndsLSqBUndsRSqBUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression'Unds'Expression{}(\and{SortPostfixExpression{}} (X0:SortPostfixExpression{}, Y0:SortPostfixExpression{}), \and{SortExpression{}} (X1:SortExpression{}, Y1:SortExpression{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortKItem{}, \equals{SortKItem{}, R} (Val:SortKItem{}, Lbl'UndsLSqBUndsRSqB'orDefault'UndsUnds'MAP'Unds'KItem'Unds'Map'Unds'KItem'Unds'KItem{}(K0:SortMap{}, K1:SortKItem{}, K2:SortKItem{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortExclusiveOforExpression{}, \equals{SortExclusiveOforExpression{}, R} (Val:SortExclusiveOforExpression{}, Lbl'UndsXor-UndsUnds'C-SYNTAX'Unds'ExclusiveOforExpression'Unds'ExclusiveOforExpression'Unds'AndExpression{}(K0:SortExclusiveOforExpression{}, K1:SortAndExpression{}))) [functional{}()] // functional
  axiom{}\implies{SortExclusiveOforExpression{}} (\and{SortExclusiveOforExpression{}} (Lbl'UndsXor-UndsUnds'C-SYNTAX'Unds'ExclusiveOforExpression'Unds'ExclusiveOforExpression'Unds'AndExpression{}(X0:SortExclusiveOforExpression{}, X1:SortAndExpression{}), Lbl'UndsXor-UndsUnds'C-SYNTAX'Unds'ExclusiveOforExpression'Unds'ExclusiveOforExpression'Unds'AndExpression{}(Y0:SortExclusiveOforExpression{}, Y1:SortAndExpression{})), Lbl'UndsXor-UndsUnds'C-SYNTAX'Unds'ExclusiveOforExpression'Unds'ExclusiveOforExpression'Unds'AndExpression{}(\and{SortExclusiveOforExpression{}} (X0:SortExclusiveOforExpression{}, Y0:SortExclusiveOforExpression{}), \and{SortAndExpression{}} (X1:SortAndExpression{}, Y1:SortAndExpression{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortDeclaration{}, \equals{SortDeclaration{}, R} (Val:SortDeclaration{}, Lbl'UndsUndsSClnUnds'C-SYNTAX'Unds'Declaration'Unds'ListDeclarationSpecifier'Unds'ListInitDeclarator{}(K0:SortListDeclarationSpecifier{}, K1:SortListInitDeclarator{}))) [functional{}()] // functional
  axiom{}\implies{SortDeclaration{}} (\and{SortDeclaration{}} (Lbl'UndsUndsSClnUnds'C-SYNTAX'Unds'Declaration'Unds'ListDeclarationSpecifier'Unds'ListInitDeclarator{}(X0:SortListDeclarationSpecifier{}, X1:SortListInitDeclarator{}), Lbl'UndsUndsSClnUnds'C-SYNTAX'Unds'Declaration'Unds'ListDeclarationSpecifier'Unds'ListInitDeclarator{}(Y0:SortListDeclarationSpecifier{}, Y1:SortListInitDeclarator{})), Lbl'UndsUndsSClnUnds'C-SYNTAX'Unds'Declaration'Unds'ListDeclarationSpecifier'Unds'ListInitDeclarator{}(\and{SortListDeclarationSpecifier{}} (X0:SortListDeclarationSpecifier{}, Y0:SortListDeclarationSpecifier{}), \and{SortListInitDeclarator{}} (X1:SortListInitDeclarator{}, Y1:SortListInitDeclarator{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortAbstractDeclarator{}, \equals{SortAbstractDeclarator{}, R} (Val:SortAbstractDeclarator{}, Lbl'UndsUndsUnds'C-SYNTAX'Unds'AbstractDeclarator'Unds'Pointer'Unds'DirectAbstractDeclarator{}(K0:SortPointer{}, K1:SortDirectAbstractDeclarator{}))) [functional{}()] // functional
  axiom{}\implies{SortAbstractDeclarator{}} (\and{SortAbstractDeclarator{}} (Lbl'UndsUndsUnds'C-SYNTAX'Unds'AbstractDeclarator'Unds'Pointer'Unds'DirectAbstractDeclarator{}(X0:SortPointer{}, X1:SortDirectAbstractDeclarator{}), Lbl'UndsUndsUnds'C-SYNTAX'Unds'AbstractDeclarator'Unds'Pointer'Unds'DirectAbstractDeclarator{}(Y0:SortPointer{}, Y1:SortDirectAbstractDeclarator{})), Lbl'UndsUndsUnds'C-SYNTAX'Unds'AbstractDeclarator'Unds'Pointer'Unds'DirectAbstractDeclarator{}(\and{SortPointer{}} (X0:SortPointer{}, Y0:SortPointer{}), \and{SortDirectAbstractDeclarator{}} (X1:SortDirectAbstractDeclarator{}, Y1:SortDirectAbstractDeclarator{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortDeclarator{}, \equals{SortDeclarator{}, R} (Val:SortDeclarator{}, Lbl'UndsUndsUnds'C-SYNTAX'Unds'Declarator'Unds'Pointer'Unds'DirectDeclarator{}(K0:SortPointer{}, K1:SortDirectDeclarator{}))) [functional{}()] // functional
  axiom{}\implies{SortDeclarator{}} (\and{SortDeclarator{}} (Lbl'UndsUndsUnds'C-SYNTAX'Unds'Declarator'Unds'Pointer'Unds'DirectDeclarator{}(X0:SortPointer{}, X1:SortDirectDeclarator{}), Lbl'UndsUndsUnds'C-SYNTAX'Unds'Declarator'Unds'Pointer'Unds'DirectDeclarator{}(Y0:SortPointer{}, Y1:SortDirectDeclarator{})), Lbl'UndsUndsUnds'C-SYNTAX'Unds'Declarator'Unds'Pointer'Unds'DirectDeclarator{}(\and{SortPointer{}} (X0:SortPointer{}, Y0:SortPointer{}), \and{SortDirectDeclarator{}} (X1:SortDirectDeclarator{}, Y1:SortDirectDeclarator{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortIds{}, \equals{SortIds{}, R} (Val:SortIds{}, Lbl'UndsUndsUnds'C-SYNTAX'Unds'Ids'Unds'Id'Unds'Ids{}(K0:SortId{}, K1:SortIds{}))) [functional{}()] // functional
  axiom{}\implies{SortIds{}} (\and{SortIds{}} (Lbl'UndsUndsUnds'C-SYNTAX'Unds'Ids'Unds'Id'Unds'Ids{}(X0:SortId{}, X1:SortIds{}), Lbl'UndsUndsUnds'C-SYNTAX'Unds'Ids'Unds'Id'Unds'Ids{}(Y0:SortId{}, Y1:SortIds{})), Lbl'UndsUndsUnds'C-SYNTAX'Unds'Ids'Unds'Id'Unds'Ids{}(\and{SortId{}} (X0:SortId{}, Y0:SortId{}), \and{SortIds{}} (X1:SortIds{}, Y1:SortIds{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortListDeclarationSpecifier{}, \equals{SortListDeclarationSpecifier{}, R} (Val:SortListDeclarationSpecifier{}, Lbl'UndsUndsUnds'C-SYNTAX'Unds'ListDeclarationSpecifier'Unds'DeclarationSpecifier'Unds'ListDeclarationSpecifier{}(K0:SortDeclarationSpecifier{}, K1:SortListDeclarationSpecifier{}))) [functional{}()] // functional
  axiom{}\implies{SortListDeclarationSpecifier{}} (\and{SortListDeclarationSpecifier{}} (Lbl'UndsUndsUnds'C-SYNTAX'Unds'ListDeclarationSpecifier'Unds'DeclarationSpecifier'Unds'ListDeclarationSpecifier{}(X0:SortDeclarationSpecifier{}, X1:SortListDeclarationSpecifier{}), Lbl'UndsUndsUnds'C-SYNTAX'Unds'ListDeclarationSpecifier'Unds'DeclarationSpecifier'Unds'ListDeclarationSpecifier{}(Y0:SortDeclarationSpecifier{}, Y1:SortListDeclarationSpecifier{})), Lbl'UndsUndsUnds'C-SYNTAX'Unds'ListDeclarationSpecifier'Unds'DeclarationSpecifier'Unds'ListDeclarationSpecifier{}(\and{SortDeclarationSpecifier{}} (X0:SortDeclarationSpecifier{}, Y0:SortDeclarationSpecifier{}), \and{SortListDeclarationSpecifier{}} (X1:SortListDeclarationSpecifier{}, Y1:SortListDeclarationSpecifier{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortListDeclaration{}, \equals{SortListDeclaration{}, R} (Val:SortListDeclaration{}, Lbl'UndsUndsUnds'C-SYNTAX'Unds'ListDeclaration'Unds'Declaration'Unds'ListDeclaration{}(K0:SortDeclaration{}, K1:SortListDeclaration{}))) [functional{}()] // functional
  axiom{}\implies{SortListDeclaration{}} (\and{SortListDeclaration{}} (Lbl'UndsUndsUnds'C-SYNTAX'Unds'ListDeclaration'Unds'Declaration'Unds'ListDeclaration{}(X0:SortDeclaration{}, X1:SortListDeclaration{}), Lbl'UndsUndsUnds'C-SYNTAX'Unds'ListDeclaration'Unds'Declaration'Unds'ListDeclaration{}(Y0:SortDeclaration{}, Y1:SortListDeclaration{})), Lbl'UndsUndsUnds'C-SYNTAX'Unds'ListDeclaration'Unds'Declaration'Unds'ListDeclaration{}(\and{SortDeclaration{}} (X0:SortDeclaration{}, Y0:SortDeclaration{}), \and{SortListDeclaration{}} (X1:SortListDeclaration{}, Y1:SortListDeclaration{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortListExternalDeclaration{}, \equals{SortListExternalDeclaration{}, R} (Val:SortListExternalDeclaration{}, Lbl'UndsUndsUnds'C-SYNTAX'Unds'ListExternalDeclaration'Unds'ExternalDeclaration'Unds'ListExternalDeclaration{}(K0:SortExternalDeclaration{}, K1:SortListExternalDeclaration{}))) [functional{}()] // functional
  axiom{}\implies{SortListExternalDeclaration{}} (\and{SortListExternalDeclaration{}} (Lbl'UndsUndsUnds'C-SYNTAX'Unds'ListExternalDeclaration'Unds'ExternalDeclaration'Unds'ListExternalDeclaration{}(X0:SortExternalDeclaration{}, X1:SortListExternalDeclaration{}), Lbl'UndsUndsUnds'C-SYNTAX'Unds'ListExternalDeclaration'Unds'ExternalDeclaration'Unds'ListExternalDeclaration{}(Y0:SortExternalDeclaration{}, Y1:SortListExternalDeclaration{})), Lbl'UndsUndsUnds'C-SYNTAX'Unds'ListExternalDeclaration'Unds'ExternalDeclaration'Unds'ListExternalDeclaration{}(\and{SortExternalDeclaration{}} (X0:SortExternalDeclaration{}, Y0:SortExternalDeclaration{}), \and{SortListExternalDeclaration{}} (X1:SortListExternalDeclaration{}, Y1:SortListExternalDeclaration{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortListSpecifierQualifier{}, \equals{SortListSpecifierQualifier{}, R} (Val:SortListSpecifierQualifier{}, Lbl'UndsUndsUnds'C-SYNTAX'Unds'ListSpecifierQualifier'Unds'SpecifierQualifier'Unds'ListSpecifierQualifier{}(K0:SortSpecifierQualifier{}, K1:SortListSpecifierQualifier{}))) [functional{}()] // functional
  axiom{}\implies{SortListSpecifierQualifier{}} (\and{SortListSpecifierQualifier{}} (Lbl'UndsUndsUnds'C-SYNTAX'Unds'ListSpecifierQualifier'Unds'SpecifierQualifier'Unds'ListSpecifierQualifier{}(X0:SortSpecifierQualifier{}, X1:SortListSpecifierQualifier{}), Lbl'UndsUndsUnds'C-SYNTAX'Unds'ListSpecifierQualifier'Unds'SpecifierQualifier'Unds'ListSpecifierQualifier{}(Y0:SortSpecifierQualifier{}, Y1:SortListSpecifierQualifier{})), Lbl'UndsUndsUnds'C-SYNTAX'Unds'ListSpecifierQualifier'Unds'SpecifierQualifier'Unds'ListSpecifierQualifier{}(\and{SortSpecifierQualifier{}} (X0:SortSpecifierQualifier{}, Y0:SortSpecifierQualifier{}), \and{SortListSpecifierQualifier{}} (X1:SortListSpecifierQualifier{}, Y1:SortListSpecifierQualifier{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortListStatement{}, \equals{SortListStatement{}, R} (Val:SortListStatement{}, Lbl'UndsUndsUnds'C-SYNTAX'Unds'ListStatement'Unds'Statement'Unds'ListStatement{}(K0:SortStatement{}, K1:SortListStatement{}))) [functional{}()] // functional
  axiom{}\implies{SortListStatement{}} (\and{SortListStatement{}} (Lbl'UndsUndsUnds'C-SYNTAX'Unds'ListStatement'Unds'Statement'Unds'ListStatement{}(X0:SortStatement{}, X1:SortListStatement{}), Lbl'UndsUndsUnds'C-SYNTAX'Unds'ListStatement'Unds'Statement'Unds'ListStatement{}(Y0:SortStatement{}, Y1:SortListStatement{})), Lbl'UndsUndsUnds'C-SYNTAX'Unds'ListStatement'Unds'Statement'Unds'ListStatement{}(\and{SortStatement{}} (X0:SortStatement{}, Y0:SortStatement{}), \and{SortListStatement{}} (X1:SortListStatement{}, Y1:SortListStatement{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortListTypeQualifier{}, \equals{SortListTypeQualifier{}, R} (Val:SortListTypeQualifier{}, Lbl'UndsUndsUnds'C-SYNTAX'Unds'ListTypeQualifier'Unds'TypeQualifier'Unds'ListTypeQualifier{}(K0:SortTypeQualifier{}, K1:SortListTypeQualifier{}))) [functional{}()] // functional
  axiom{}\implies{SortListTypeQualifier{}} (\and{SortListTypeQualifier{}} (Lbl'UndsUndsUnds'C-SYNTAX'Unds'ListTypeQualifier'Unds'TypeQualifier'Unds'ListTypeQualifier{}(X0:SortTypeQualifier{}, X1:SortListTypeQualifier{}), Lbl'UndsUndsUnds'C-SYNTAX'Unds'ListTypeQualifier'Unds'TypeQualifier'Unds'ListTypeQualifier{}(Y0:SortTypeQualifier{}, Y1:SortListTypeQualifier{})), Lbl'UndsUndsUnds'C-SYNTAX'Unds'ListTypeQualifier'Unds'TypeQualifier'Unds'ListTypeQualifier{}(\and{SortTypeQualifier{}} (X0:SortTypeQualifier{}, Y0:SortTypeQualifier{}), \and{SortListTypeQualifier{}} (X1:SortListTypeQualifier{}, Y1:SortListTypeQualifier{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortParameterDeclaration{}, \equals{SortParameterDeclaration{}, R} (Val:SortParameterDeclaration{}, Lbl'UndsUndsUnds'C-SYNTAX'Unds'ParameterDeclaration'Unds'ListDeclarationSpecifier'Unds'AbstractDeclarator{}(K0:SortListDeclarationSpecifier{}, K1:SortAbstractDeclarator{}))) [functional{}()] // functional
  axiom{}\implies{SortParameterDeclaration{}} (\and{SortParameterDeclaration{}} (Lbl'UndsUndsUnds'C-SYNTAX'Unds'ParameterDeclaration'Unds'ListDeclarationSpecifier'Unds'AbstractDeclarator{}(X0:SortListDeclarationSpecifier{}, X1:SortAbstractDeclarator{}), Lbl'UndsUndsUnds'C-SYNTAX'Unds'ParameterDeclaration'Unds'ListDeclarationSpecifier'Unds'AbstractDeclarator{}(Y0:SortListDeclarationSpecifier{}, Y1:SortAbstractDeclarator{})), Lbl'UndsUndsUnds'C-SYNTAX'Unds'ParameterDeclaration'Unds'ListDeclarationSpecifier'Unds'AbstractDeclarator{}(\and{SortListDeclarationSpecifier{}} (X0:SortListDeclarationSpecifier{}, Y0:SortListDeclarationSpecifier{}), \and{SortAbstractDeclarator{}} (X1:SortAbstractDeclarator{}, Y1:SortAbstractDeclarator{}))) [constructor{}()] // no confusion same constructor
  axiom{}\not{SortParameterDeclaration{}} (\and{SortParameterDeclaration{}} (Lbl'UndsUndsUnds'C-SYNTAX'Unds'ParameterDeclaration'Unds'ListDeclarationSpecifier'Unds'AbstractDeclarator{}(X0:SortListDeclarationSpecifier{}, X1:SortAbstractDeclarator{}), Lbl'UndsUndsUnds'C-SYNTAX'Unds'ParameterDeclaration'Unds'ListDeclarationSpecifier'Unds'Declarator{}(Y0:SortListDeclarationSpecifier{}, Y1:SortDeclarator{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortParameterDeclaration{}, \equals{SortParameterDeclaration{}, R} (Val:SortParameterDeclaration{}, Lbl'UndsUndsUnds'C-SYNTAX'Unds'ParameterDeclaration'Unds'ListDeclarationSpecifier'Unds'Declarator{}(K0:SortListDeclarationSpecifier{}, K1:SortDeclarator{}))) [functional{}()] // functional
  axiom{}\implies{SortParameterDeclaration{}} (\and{SortParameterDeclaration{}} (Lbl'UndsUndsUnds'C-SYNTAX'Unds'ParameterDeclaration'Unds'ListDeclarationSpecifier'Unds'Declarator{}(X0:SortListDeclarationSpecifier{}, X1:SortDeclarator{}), Lbl'UndsUndsUnds'C-SYNTAX'Unds'ParameterDeclaration'Unds'ListDeclarationSpecifier'Unds'Declarator{}(Y0:SortListDeclarationSpecifier{}, Y1:SortDeclarator{})), Lbl'UndsUndsUnds'C-SYNTAX'Unds'ParameterDeclaration'Unds'ListDeclarationSpecifier'Unds'Declarator{}(\and{SortListDeclarationSpecifier{}} (X0:SortListDeclarationSpecifier{}, Y0:SortListDeclarationSpecifier{}), \and{SortDeclarator{}} (X1:SortDeclarator{}, Y1:SortDeclarator{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortStructDeclaration{}, \equals{SortStructDeclaration{}, R} (Val:SortStructDeclaration{}, Lbl'UndsUndsUnds'C-SYNTAX'Unds'StructDeclaration'Unds'ListSpecifierQualifier'Unds'StructDeclaratorList{}(K0:SortListSpecifierQualifier{}, K1:SortStructDeclaratorList{}))) [functional{}()] // functional
  axiom{}\implies{SortStructDeclaration{}} (\and{SortStructDeclaration{}} (Lbl'UndsUndsUnds'C-SYNTAX'Unds'StructDeclaration'Unds'ListSpecifierQualifier'Unds'StructDeclaratorList{}(X0:SortListSpecifierQualifier{}, X1:SortStructDeclaratorList{}), Lbl'UndsUndsUnds'C-SYNTAX'Unds'StructDeclaration'Unds'ListSpecifierQualifier'Unds'StructDeclaratorList{}(Y0:SortListSpecifierQualifier{}, Y1:SortStructDeclaratorList{})), Lbl'UndsUndsUnds'C-SYNTAX'Unds'StructDeclaration'Unds'ListSpecifierQualifier'Unds'StructDeclaratorList{}(\and{SortListSpecifierQualifier{}} (X0:SortListSpecifierQualifier{}, Y0:SortListSpecifierQualifier{}), \and{SortStructDeclaratorList{}} (X1:SortStructDeclaratorList{}, Y1:SortStructDeclaratorList{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortStructOrFunionSpecifier{}, \equals{SortStructOrFunionSpecifier{}, R} (Val:SortStructOrFunionSpecifier{}, Lbl'UndsUndsUnds'C-SYNTAX'Unds'StructOrFunionSpecifier'Unds'StructOrUnion'Unds'Id{}(K0:SortStructOrUnion{}, K1:SortId{}))) [functional{}()] // functional
  axiom{}\implies{SortStructOrFunionSpecifier{}} (\and{SortStructOrFunionSpecifier{}} (Lbl'UndsUndsUnds'C-SYNTAX'Unds'StructOrFunionSpecifier'Unds'StructOrUnion'Unds'Id{}(X0:SortStructOrUnion{}, X1:SortId{}), Lbl'UndsUndsUnds'C-SYNTAX'Unds'StructOrFunionSpecifier'Unds'StructOrUnion'Unds'Id{}(Y0:SortStructOrUnion{}, Y1:SortId{})), Lbl'UndsUndsUnds'C-SYNTAX'Unds'StructOrFunionSpecifier'Unds'StructOrUnion'Unds'Id{}(\and{SortStructOrUnion{}} (X0:SortStructOrUnion{}, Y0:SortStructOrUnion{}), \and{SortId{}} (X1:SortId{}, Y1:SortId{}))) [constructor{}()] // no confusion same constructor
  axiom{}\not{SortStructOrFunionSpecifier{}} (\and{SortStructOrFunionSpecifier{}} (Lbl'UndsUndsUnds'C-SYNTAX'Unds'StructOrFunionSpecifier'Unds'StructOrUnion'Unds'Id{}(X0:SortStructOrUnion{}, X1:SortId{}), Lbl'UndsUndsLBraUndsSClnRBraUnds'C-SYNTAX'Unds'StructOrFunionSpecifier'Unds'StructOrUnion'Unds'Id'Unds'ListStructDeclaration{}(Y0:SortStructOrUnion{}, Y1:SortId{}, Y2:SortListStructDeclaration{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortStructOrFunionSpecifier{}} (\and{SortStructOrFunionSpecifier{}} (Lbl'UndsUndsUnds'C-SYNTAX'Unds'StructOrFunionSpecifier'Unds'StructOrUnion'Unds'Id{}(X0:SortStructOrUnion{}, X1:SortId{}), Lbl'UndsUndsLBraRBraUnds'C-SYNTAX'Unds'StructOrFunionSpecifier'Unds'StructOrUnion'Unds'Id{}(Y0:SortStructOrUnion{}, Y1:SortId{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortStructOrFunionSpecifier{}} (\and{SortStructOrFunionSpecifier{}} (Lbl'UndsUndsUnds'C-SYNTAX'Unds'StructOrFunionSpecifier'Unds'StructOrUnion'Unds'Id{}(X0:SortStructOrUnion{}, X1:SortId{}), Lbl'UndsLBraUndsSClnRBraUnds'C-SYNTAX'Unds'StructOrFunionSpecifier'Unds'StructOrUnion'Unds'ListStructDeclaration{}(Y0:SortStructOrUnion{}, Y1:SortListStructDeclaration{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortTypeName{}, \equals{SortTypeName{}, R} (Val:SortTypeName{}, Lbl'UndsUndsUnds'C-SYNTAX'Unds'TypeName'Unds'ListSpecifierQualifier'Unds'AbstractDeclarator{}(K0:SortListSpecifierQualifier{}, K1:SortAbstractDeclarator{}))) [functional{}()] // functional
  axiom{}\implies{SortTypeName{}} (\and{SortTypeName{}} (Lbl'UndsUndsUnds'C-SYNTAX'Unds'TypeName'Unds'ListSpecifierQualifier'Unds'AbstractDeclarator{}(X0:SortListSpecifierQualifier{}, X1:SortAbstractDeclarator{}), Lbl'UndsUndsUnds'C-SYNTAX'Unds'TypeName'Unds'ListSpecifierQualifier'Unds'AbstractDeclarator{}(Y0:SortListSpecifierQualifier{}, Y1:SortAbstractDeclarator{})), Lbl'UndsUndsUnds'C-SYNTAX'Unds'TypeName'Unds'ListSpecifierQualifier'Unds'AbstractDeclarator{}(\and{SortListSpecifierQualifier{}} (X0:SortListSpecifierQualifier{}, Y0:SortListSpecifierQualifier{}), \and{SortAbstractDeclarator{}} (X1:SortAbstractDeclarator{}, Y1:SortAbstractDeclarator{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortUnaryExpression{}, \equals{SortUnaryExpression{}, R} (Val:SortUnaryExpression{}, Lbl'UndsUndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'UnaryOperator'Unds'CastExpression{}(K0:SortUnaryOperator{}, K1:SortCastExpression{}))) [functional{}()] // functional
  axiom{}\implies{SortUnaryExpression{}} (\and{SortUnaryExpression{}} (Lbl'UndsUndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'UnaryOperator'Unds'CastExpression{}(X0:SortUnaryOperator{}, X1:SortCastExpression{}), Lbl'UndsUndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'UnaryOperator'Unds'CastExpression{}(Y0:SortUnaryOperator{}, Y1:SortCastExpression{})), Lbl'UndsUndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'UnaryOperator'Unds'CastExpression{}(\and{SortUnaryOperator{}} (X0:SortUnaryOperator{}, Y0:SortUnaryOperator{}), \and{SortCastExpression{}} (X1:SortCastExpression{}, Y1:SortCastExpression{}))) [constructor{}()] // no confusion same constructor
  axiom{}\not{SortUnaryExpression{}} (\and{SortUnaryExpression{}} (Lbl'UndsUndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'UnaryOperator'Unds'CastExpression{}(X0:SortUnaryOperator{}, X1:SortCastExpression{}), Lblsizeof'UndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'TypeName{}(Y0:SortTypeName{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortUnaryExpression{}} (\and{SortUnaryExpression{}} (Lbl'UndsUndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'UnaryOperator'Unds'CastExpression{}(X0:SortUnaryOperator{}, X1:SortCastExpression{}), Lblsizeof'UndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'UnaryExpression{}(Y0:SortUnaryExpression{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortAssignmentExpression{}, \equals{SortAssignmentExpression{}, R} (Val:SortAssignmentExpression{}, Lbl'UndsUndsUndsUnds'C-SYNTAX'Unds'AssignmentExpression'Unds'UnaryExpression'Unds'AssignmentOperator'Unds'AssignmentExpression{}(K0:SortUnaryExpression{}, K1:SortAssignmentOperator{}, K2:SortAssignmentExpression{}))) [functional{}()] // functional
  axiom{}\implies{SortAssignmentExpression{}} (\and{SortAssignmentExpression{}} (Lbl'UndsUndsUndsUnds'C-SYNTAX'Unds'AssignmentExpression'Unds'UnaryExpression'Unds'AssignmentOperator'Unds'AssignmentExpression{}(X0:SortUnaryExpression{}, X1:SortAssignmentOperator{}, X2:SortAssignmentExpression{}), Lbl'UndsUndsUndsUnds'C-SYNTAX'Unds'AssignmentExpression'Unds'UnaryExpression'Unds'AssignmentOperator'Unds'AssignmentExpression{}(Y0:SortUnaryExpression{}, Y1:SortAssignmentOperator{}, Y2:SortAssignmentExpression{})), Lbl'UndsUndsUndsUnds'C-SYNTAX'Unds'AssignmentExpression'Unds'UnaryExpression'Unds'AssignmentOperator'Unds'AssignmentExpression{}(\and{SortUnaryExpression{}} (X0:SortUnaryExpression{}, Y0:SortUnaryExpression{}), \and{SortAssignmentOperator{}} (X1:SortAssignmentOperator{}, Y1:SortAssignmentOperator{}), \and{SortAssignmentExpression{}} (X2:SortAssignmentExpression{}, Y2:SortAssignmentExpression{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortFunctionDefinition{}, \equals{SortFunctionDefinition{}, R} (Val:SortFunctionDefinition{}, Lbl'UndsUndsUndsUndsUnds'C-SYNTAX'Unds'FunctionDefinition'Unds'ListDeclarationSpecifier'Unds'Declarator'Unds'ListDeclaration'Unds'CompoundStatement{}(K0:SortListDeclarationSpecifier{}, K1:SortDeclarator{}, K2:SortListDeclaration{}, K3:SortCompoundStatement{}))) [functional{}()] // functional
  axiom{}\implies{SortFunctionDefinition{}} (\and{SortFunctionDefinition{}} (Lbl'UndsUndsUndsUndsUnds'C-SYNTAX'Unds'FunctionDefinition'Unds'ListDeclarationSpecifier'Unds'Declarator'Unds'ListDeclaration'Unds'CompoundStatement{}(X0:SortListDeclarationSpecifier{}, X1:SortDeclarator{}, X2:SortListDeclaration{}, X3:SortCompoundStatement{}), Lbl'UndsUndsUndsUndsUnds'C-SYNTAX'Unds'FunctionDefinition'Unds'ListDeclarationSpecifier'Unds'Declarator'Unds'ListDeclaration'Unds'CompoundStatement{}(Y0:SortListDeclarationSpecifier{}, Y1:SortDeclarator{}, Y2:SortListDeclaration{}, Y3:SortCompoundStatement{})), Lbl'UndsUndsUndsUndsUnds'C-SYNTAX'Unds'FunctionDefinition'Unds'ListDeclarationSpecifier'Unds'Declarator'Unds'ListDeclaration'Unds'CompoundStatement{}(\and{SortListDeclarationSpecifier{}} (X0:SortListDeclarationSpecifier{}, Y0:SortListDeclarationSpecifier{}), \and{SortDeclarator{}} (X1:SortDeclarator{}, Y1:SortDeclarator{}), \and{SortListDeclaration{}} (X2:SortListDeclaration{}, Y2:SortListDeclaration{}), \and{SortCompoundStatement{}} (X3:SortCompoundStatement{}, Y3:SortCompoundStatement{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortStructOrFunionSpecifier{}, \equals{SortStructOrFunionSpecifier{}, R} (Val:SortStructOrFunionSpecifier{}, Lbl'UndsUndsLBraUndsSClnRBraUnds'C-SYNTAX'Unds'StructOrFunionSpecifier'Unds'StructOrUnion'Unds'Id'Unds'ListStructDeclaration{}(K0:SortStructOrUnion{}, K1:SortId{}, K2:SortListStructDeclaration{}))) [functional{}()] // functional
  axiom{}\implies{SortStructOrFunionSpecifier{}} (\and{SortStructOrFunionSpecifier{}} (Lbl'UndsUndsLBraUndsSClnRBraUnds'C-SYNTAX'Unds'StructOrFunionSpecifier'Unds'StructOrUnion'Unds'Id'Unds'ListStructDeclaration{}(X0:SortStructOrUnion{}, X1:SortId{}, X2:SortListStructDeclaration{}), Lbl'UndsUndsLBraUndsSClnRBraUnds'C-SYNTAX'Unds'StructOrFunionSpecifier'Unds'StructOrUnion'Unds'Id'Unds'ListStructDeclaration{}(Y0:SortStructOrUnion{}, Y1:SortId{}, Y2:SortListStructDeclaration{})), Lbl'UndsUndsLBraUndsSClnRBraUnds'C-SYNTAX'Unds'StructOrFunionSpecifier'Unds'StructOrUnion'Unds'Id'Unds'ListStructDeclaration{}(\and{SortStructOrUnion{}} (X0:SortStructOrUnion{}, Y0:SortStructOrUnion{}), \and{SortId{}} (X1:SortId{}, Y1:SortId{}), \and{SortListStructDeclaration{}} (X2:SortListStructDeclaration{}, Y2:SortListStructDeclaration{}))) [constructor{}()] // no confusion same constructor
  axiom{}\not{SortStructOrFunionSpecifier{}} (\and{SortStructOrFunionSpecifier{}} (Lbl'UndsUndsLBraUndsSClnRBraUnds'C-SYNTAX'Unds'StructOrFunionSpecifier'Unds'StructOrUnion'Unds'Id'Unds'ListStructDeclaration{}(X0:SortStructOrUnion{}, X1:SortId{}, X2:SortListStructDeclaration{}), Lbl'UndsUndsLBraRBraUnds'C-SYNTAX'Unds'StructOrFunionSpecifier'Unds'StructOrUnion'Unds'Id{}(Y0:SortStructOrUnion{}, Y1:SortId{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortStructOrFunionSpecifier{}} (\and{SortStructOrFunionSpecifier{}} (Lbl'UndsUndsLBraUndsSClnRBraUnds'C-SYNTAX'Unds'StructOrFunionSpecifier'Unds'StructOrUnion'Unds'Id'Unds'ListStructDeclaration{}(X0:SortStructOrUnion{}, X1:SortId{}, X2:SortListStructDeclaration{}), Lbl'UndsLBraUndsSClnRBraUnds'C-SYNTAX'Unds'StructOrFunionSpecifier'Unds'StructOrUnion'Unds'ListStructDeclaration{}(Y0:SortStructOrUnion{}, Y1:SortListStructDeclaration{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortStructOrFunionSpecifier{}, \equals{SortStructOrFunionSpecifier{}, R} (Val:SortStructOrFunionSpecifier{}, Lbl'UndsUndsLBraRBraUnds'C-SYNTAX'Unds'StructOrFunionSpecifier'Unds'StructOrUnion'Unds'Id{}(K0:SortStructOrUnion{}, K1:SortId{}))) [functional{}()] // functional
  axiom{}\implies{SortStructOrFunionSpecifier{}} (\and{SortStructOrFunionSpecifier{}} (Lbl'UndsUndsLBraRBraUnds'C-SYNTAX'Unds'StructOrFunionSpecifier'Unds'StructOrUnion'Unds'Id{}(X0:SortStructOrUnion{}, X1:SortId{}), Lbl'UndsUndsLBraRBraUnds'C-SYNTAX'Unds'StructOrFunionSpecifier'Unds'StructOrUnion'Unds'Id{}(Y0:SortStructOrUnion{}, Y1:SortId{})), Lbl'UndsUndsLBraRBraUnds'C-SYNTAX'Unds'StructOrFunionSpecifier'Unds'StructOrUnion'Unds'Id{}(\and{SortStructOrUnion{}} (X0:SortStructOrUnion{}, Y0:SortStructOrUnion{}), \and{SortId{}} (X1:SortId{}, Y1:SortId{}))) [constructor{}()] // no confusion same constructor
  axiom{}\not{SortStructOrFunionSpecifier{}} (\and{SortStructOrFunionSpecifier{}} (Lbl'UndsUndsLBraRBraUnds'C-SYNTAX'Unds'StructOrFunionSpecifier'Unds'StructOrUnion'Unds'Id{}(X0:SortStructOrUnion{}, X1:SortId{}), Lbl'UndsLBraUndsSClnRBraUnds'C-SYNTAX'Unds'StructOrFunionSpecifier'Unds'StructOrUnion'Unds'ListStructDeclaration{}(Y0:SortStructOrUnion{}, Y1:SortListStructDeclaration{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortBool{}, \equals{SortBool{}, R} (Val:SortBool{}, Lbl'Unds'andBool'Unds'{}(K0:SortBool{}, K1:SortBool{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortBool{}, \equals{SortBool{}, R} (Val:SortBool{}, Lbl'Unds'andThenBool'Unds'{}(K0:SortBool{}, K1:SortBool{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortBool{}, \equals{SortBool{}, R} (Val:SortBool{}, Lbl'Unds'impliesBool'Unds'{}(K0:SortBool{}, K1:SortBool{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortBool{}, \equals{SortBool{}, R} (Val:SortBool{}, Lbl'Unds'in'UndsUnds'LIST'Unds'Bool'Unds'KItem'Unds'List{}(K0:SortKItem{}, K1:SortList{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortBool{}, \equals{SortBool{}, R} (Val:SortBool{}, Lbl'Unds'in'Unds'keys'LParUndsRParUnds'MAP'Unds'Bool'Unds'KItem'Unds'Map{}(K0:SortKItem{}, K1:SortMap{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortBool{}, \equals{SortBool{}, R} (Val:SortBool{}, Lbl'Unds'orBool'Unds'{}(K0:SortBool{}, K1:SortBool{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortBool{}, \equals{SortBool{}, R} (Val:SortBool{}, Lbl'Unds'orElseBool'Unds'{}(K0:SortBool{}, K1:SortBool{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortBool{}, \equals{SortBool{}, R} (Val:SortBool{}, Lbl'Unds'xorBool'Unds'{}(K0:SortBool{}, K1:SortBool{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortInt{}, \equals{SortInt{}, R} (Val:SortInt{}, Lbl'Unds'xorInt'Unds'{}(K0:SortInt{}, K1:SortInt{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortStructOrFunionSpecifier{}, \equals{SortStructOrFunionSpecifier{}, R} (Val:SortStructOrFunionSpecifier{}, Lbl'UndsLBraUndsSClnRBraUnds'C-SYNTAX'Unds'StructOrFunionSpecifier'Unds'StructOrUnion'Unds'ListStructDeclaration{}(K0:SortStructOrUnion{}, K1:SortListStructDeclaration{}))) [functional{}()] // functional
  axiom{}\implies{SortStructOrFunionSpecifier{}} (\and{SortStructOrFunionSpecifier{}} (Lbl'UndsLBraUndsSClnRBraUnds'C-SYNTAX'Unds'StructOrFunionSpecifier'Unds'StructOrUnion'Unds'ListStructDeclaration{}(X0:SortStructOrUnion{}, X1:SortListStructDeclaration{}), Lbl'UndsLBraUndsSClnRBraUnds'C-SYNTAX'Unds'StructOrFunionSpecifier'Unds'StructOrUnion'Unds'ListStructDeclaration{}(Y0:SortStructOrUnion{}, Y1:SortListStructDeclaration{})), Lbl'UndsLBraUndsSClnRBraUnds'C-SYNTAX'Unds'StructOrFunionSpecifier'Unds'StructOrUnion'Unds'ListStructDeclaration{}(\and{SortStructOrUnion{}} (X0:SortStructOrUnion{}, Y0:SortStructOrUnion{}), \and{SortListStructDeclaration{}} (X1:SortListStructDeclaration{}, Y1:SortListStructDeclaration{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortMap{}, \equals{SortMap{}, R} (Val:SortMap{}, Lbl'UndsPipe'-'-GT-Unds'{}(K0:SortKItem{}, K1:SortKItem{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortInt{}, \equals{SortInt{}, R} (Val:SortInt{}, Lbl'UndsPipe'Int'Unds'{}(K0:SortInt{}, K1:SortInt{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortSet{}, \equals{SortSet{}, R} (Val:SortSet{}, Lbl'UndsPipe'Set'UndsUnds'SET'Unds'Set'Unds'Set'Unds'Set{}(K0:SortSet{}, K1:SortSet{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortInclusiveOforExpression{}, \equals{SortInclusiveOforExpression{}, R} (Val:SortInclusiveOforExpression{}, Lbl'UndsPipeUndsUnds'C-SYNTAX'Unds'InclusiveOforExpression'Unds'InclusiveOforExpression'Unds'ExclusiveOforExpression{}(K0:SortInclusiveOforExpression{}, K1:SortExclusiveOforExpression{}))) [functional{}()] // functional
  axiom{}\implies{SortInclusiveOforExpression{}} (\and{SortInclusiveOforExpression{}} (Lbl'UndsPipeUndsUnds'C-SYNTAX'Unds'InclusiveOforExpression'Unds'InclusiveOforExpression'Unds'ExclusiveOforExpression{}(X0:SortInclusiveOforExpression{}, X1:SortExclusiveOforExpression{}), Lbl'UndsPipeUndsUnds'C-SYNTAX'Unds'InclusiveOforExpression'Unds'InclusiveOforExpression'Unds'ExclusiveOforExpression{}(Y0:SortInclusiveOforExpression{}, Y1:SortExclusiveOforExpression{})), Lbl'UndsPipeUndsUnds'C-SYNTAX'Unds'InclusiveOforExpression'Unds'InclusiveOforExpression'Unds'ExclusiveOforExpression{}(\and{SortInclusiveOforExpression{}} (X0:SortInclusiveOforExpression{}, Y0:SortInclusiveOforExpression{}), \and{SortExclusiveOforExpression{}} (X1:SortExclusiveOforExpression{}, Y1:SortExclusiveOforExpression{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortLogicalOforExpression{}, \equals{SortLogicalOforExpression{}, R} (Val:SortLogicalOforExpression{}, Lbl'UndsPipePipeUndsUnds'C-SYNTAX'Unds'LogicalOforExpression'Unds'LogicalOforExpression'Unds'LogicalOfandExpression{}(K0:SortLogicalOforExpression{}, K1:SortLogicalOfandExpression{}))) [functional{}()] // functional
  axiom{}\implies{SortLogicalOforExpression{}} (\and{SortLogicalOforExpression{}} (Lbl'UndsPipePipeUndsUnds'C-SYNTAX'Unds'LogicalOforExpression'Unds'LogicalOforExpression'Unds'LogicalOfandExpression{}(X0:SortLogicalOforExpression{}, X1:SortLogicalOfandExpression{}), Lbl'UndsPipePipeUndsUnds'C-SYNTAX'Unds'LogicalOforExpression'Unds'LogicalOforExpression'Unds'LogicalOfandExpression{}(Y0:SortLogicalOforExpression{}, Y1:SortLogicalOfandExpression{})), Lbl'UndsPipePipeUndsUnds'C-SYNTAX'Unds'LogicalOforExpression'Unds'LogicalOforExpression'Unds'LogicalOfandExpression{}(\and{SortLogicalOforExpression{}} (X0:SortLogicalOforExpression{}, Y0:SortLogicalOforExpression{}), \and{SortLogicalOfandExpression{}} (X1:SortLogicalOfandExpression{}, Y1:SortLogicalOfandExpression{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortInt{}, \equals{SortInt{}, R} (Val:SortInt{}, LblabsInt'LParUndsRParUnds'INT-COMMON'Unds'Int'Unds'Int{}(K0:SortInt{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortStorageClassSpecifier{}, \equals{SortStorageClassSpecifier{}, R} (Val:SortStorageClassSpecifier{}, Lblauto'Unds'C-SYNTAX'Unds'StorageClassSpecifier{}())) [functional{}()] // functional
  axiom{}\not{SortStorageClassSpecifier{}} (\and{SortStorageClassSpecifier{}} (Lblauto'Unds'C-SYNTAX'Unds'StorageClassSpecifier{}(), Lblextern'Unds'C-SYNTAX'Unds'StorageClassSpecifier{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortStorageClassSpecifier{}} (\and{SortStorageClassSpecifier{}} (Lblauto'Unds'C-SYNTAX'Unds'StorageClassSpecifier{}(), Lblregister'Unds'C-SYNTAX'Unds'StorageClassSpecifier{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortStorageClassSpecifier{}} (\and{SortStorageClassSpecifier{}} (Lblauto'Unds'C-SYNTAX'Unds'StorageClassSpecifier{}(), Lblstatic'Unds'C-SYNTAX'Unds'StorageClassSpecifier{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortStorageClassSpecifier{}} (\and{SortStorageClassSpecifier{}} (Lblauto'Unds'C-SYNTAX'Unds'StorageClassSpecifier{}(), Lbltypedef'Unds'C-SYNTAX'Unds'StorageClassSpecifier{}())) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortJumpStatement{}, \equals{SortJumpStatement{}, R} (Val:SortJumpStatement{}, Lblbreak'SClnUnds'C-SYNTAX'Unds'JumpStatement{}())) [functional{}()] // functional
  axiom{}\not{SortJumpStatement{}} (\and{SortJumpStatement{}} (Lblbreak'SClnUnds'C-SYNTAX'Unds'JumpStatement{}(), Lblcontinue'SClnUnds'C-SYNTAX'Unds'JumpStatement{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortJumpStatement{}} (\and{SortJumpStatement{}} (Lblbreak'SClnUnds'C-SYNTAX'Unds'JumpStatement{}(), Lblgoto'UndsSClnUnds'C-SYNTAX'Unds'JumpStatement'Unds'Id{}(Y0:SortId{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortJumpStatement{}} (\and{SortJumpStatement{}} (Lblbreak'SClnUnds'C-SYNTAX'Unds'JumpStatement{}(), Lblreturn'UndsSClnUnds'C-SYNTAX'Unds'JumpStatement'Unds'Expression{}(Y0:SortExpression{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortLabeledStatement{}, \equals{SortLabeledStatement{}, R} (Val:SortLabeledStatement{}, Lblcase'UndsColnUndsUnds'C-SYNTAX'Unds'LabeledStatement'Unds'ConstantExpression'Unds'Statement{}(K0:SortConstantExpression{}, K1:SortStatement{}))) [functional{}()] // functional
  axiom{}\implies{SortLabeledStatement{}} (\and{SortLabeledStatement{}} (Lblcase'UndsColnUndsUnds'C-SYNTAX'Unds'LabeledStatement'Unds'ConstantExpression'Unds'Statement{}(X0:SortConstantExpression{}, X1:SortStatement{}), Lblcase'UndsColnUndsUnds'C-SYNTAX'Unds'LabeledStatement'Unds'ConstantExpression'Unds'Statement{}(Y0:SortConstantExpression{}, Y1:SortStatement{})), Lblcase'UndsColnUndsUnds'C-SYNTAX'Unds'LabeledStatement'Unds'ConstantExpression'Unds'Statement{}(\and{SortConstantExpression{}} (X0:SortConstantExpression{}, Y0:SortConstantExpression{}), \and{SortStatement{}} (X1:SortStatement{}, Y1:SortStatement{}))) [constructor{}()] // no confusion same constructor
  axiom{}\not{SortLabeledStatement{}} (\and{SortLabeledStatement{}} (Lblcase'UndsColnUndsUnds'C-SYNTAX'Unds'LabeledStatement'Unds'ConstantExpression'Unds'Statement{}(X0:SortConstantExpression{}, X1:SortStatement{}), Lbldefault'ColnUndsUnds'C-SYNTAX'Unds'LabeledStatement'Unds'Statement{}(Y0:SortStatement{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortTypeSpecifier{}, \equals{SortTypeSpecifier{}, R} (Val:SortTypeSpecifier{}, Lblchar'Unds'C-SYNTAX'Unds'TypeSpecifier{}())) [functional{}()] // functional
  axiom{}\not{SortTypeSpecifier{}} (\and{SortTypeSpecifier{}} (Lblchar'Unds'C-SYNTAX'Unds'TypeSpecifier{}(), Lbldouble'Unds'C-SYNTAX'Unds'TypeSpecifier{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortTypeSpecifier{}} (\and{SortTypeSpecifier{}} (Lblchar'Unds'C-SYNTAX'Unds'TypeSpecifier{}(), Lblfloat'Unds'C-SYNTAX'Unds'TypeSpecifier{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortTypeSpecifier{}} (\and{SortTypeSpecifier{}} (Lblchar'Unds'C-SYNTAX'Unds'TypeSpecifier{}(), Lblint'Unds'C-SYNTAX'Unds'TypeSpecifier{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortTypeSpecifier{}} (\and{SortTypeSpecifier{}} (Lblchar'Unds'C-SYNTAX'Unds'TypeSpecifier{}(), Lbllong'Unds'C-SYNTAX'Unds'TypeSpecifier{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortTypeSpecifier{}} (\and{SortTypeSpecifier{}} (Lblchar'Unds'C-SYNTAX'Unds'TypeSpecifier{}(), Lblshort'Unds'C-SYNTAX'Unds'TypeSpecifier{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortTypeSpecifier{}} (\and{SortTypeSpecifier{}} (Lblchar'Unds'C-SYNTAX'Unds'TypeSpecifier{}(), Lblsigned'Unds'C-SYNTAX'Unds'TypeSpecifier{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortTypeSpecifier{}} (\and{SortTypeSpecifier{}} (Lblchar'Unds'C-SYNTAX'Unds'TypeSpecifier{}(), Lblunsigned'Unds'C-SYNTAX'Unds'TypeSpecifier{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortTypeSpecifier{}} (\and{SortTypeSpecifier{}} (Lblchar'Unds'C-SYNTAX'Unds'TypeSpecifier{}(), Lblvoid'Unds'C-SYNTAX'Unds'TypeSpecifier{}())) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortTypeQualifier{}, \equals{SortTypeQualifier{}, R} (Val:SortTypeQualifier{}, Lblconst'Unds'C-SYNTAX'Unds'TypeQualifier{}())) [functional{}()] // functional
  axiom{}\not{SortTypeQualifier{}} (\and{SortTypeQualifier{}} (Lblconst'Unds'C-SYNTAX'Unds'TypeQualifier{}(), Lblvolatile'Unds'C-SYNTAX'Unds'TypeQualifier{}())) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortJumpStatement{}, \equals{SortJumpStatement{}, R} (Val:SortJumpStatement{}, Lblcontinue'SClnUnds'C-SYNTAX'Unds'JumpStatement{}())) [functional{}()] // functional
  axiom{}\not{SortJumpStatement{}} (\and{SortJumpStatement{}} (Lblcontinue'SClnUnds'C-SYNTAX'Unds'JumpStatement{}(), Lblgoto'UndsSClnUnds'C-SYNTAX'Unds'JumpStatement'Unds'Id{}(Y0:SortId{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortJumpStatement{}} (\and{SortJumpStatement{}} (Lblcontinue'SClnUnds'C-SYNTAX'Unds'JumpStatement{}(), Lblreturn'UndsSClnUnds'C-SYNTAX'Unds'JumpStatement'Unds'Expression{}(Y0:SortExpression{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortInt{}, \equals{SortInt{}, R} (Val:SortInt{}, LblcountAllOccurrences'LParUndsCommUndsRParUnds'STRING-COMMON'Unds'Int'Unds'String'Unds'String{}(K0:SortString{}, K1:SortString{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortLabeledStatement{}, \equals{SortLabeledStatement{}, R} (Val:SortLabeledStatement{}, Lbldefault'ColnUndsUnds'C-SYNTAX'Unds'LabeledStatement'Unds'Statement{}(K0:SortStatement{}))) [functional{}()] // functional
  axiom{}\implies{SortLabeledStatement{}} (\and{SortLabeledStatement{}} (Lbldefault'ColnUndsUnds'C-SYNTAX'Unds'LabeledStatement'Unds'Statement{}(X0:SortStatement{}), Lbldefault'ColnUndsUnds'C-SYNTAX'Unds'LabeledStatement'Unds'Statement{}(Y0:SortStatement{})), Lbldefault'ColnUndsUnds'C-SYNTAX'Unds'LabeledStatement'Unds'Statement{}(\and{SortStatement{}} (X0:SortStatement{}, Y0:SortStatement{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortIterationStatement{}, \equals{SortIterationStatement{}, R} (Val:SortIterationStatement{}, Lbldo'Unds'while'LParUndsRParSClnUnds'C-SYNTAX'Unds'IterationStatement'Unds'Statement'Unds'Expression{}(K0:SortStatement{}, K1:SortExpression{}))) [functional{}()] // functional
  axiom{}\implies{SortIterationStatement{}} (\and{SortIterationStatement{}} (Lbldo'Unds'while'LParUndsRParSClnUnds'C-SYNTAX'Unds'IterationStatement'Unds'Statement'Unds'Expression{}(X0:SortStatement{}, X1:SortExpression{}), Lbldo'Unds'while'LParUndsRParSClnUnds'C-SYNTAX'Unds'IterationStatement'Unds'Statement'Unds'Expression{}(Y0:SortStatement{}, Y1:SortExpression{})), Lbldo'Unds'while'LParUndsRParSClnUnds'C-SYNTAX'Unds'IterationStatement'Unds'Statement'Unds'Expression{}(\and{SortStatement{}} (X0:SortStatement{}, Y0:SortStatement{}), \and{SortExpression{}} (X1:SortExpression{}, Y1:SortExpression{}))) [constructor{}()] // no confusion same constructor
  axiom{}\not{SortIterationStatement{}} (\and{SortIterationStatement{}} (Lbldo'Unds'while'LParUndsRParSClnUnds'C-SYNTAX'Unds'IterationStatement'Unds'Statement'Unds'Expression{}(X0:SortStatement{}, X1:SortExpression{}), Lblfor'LParUndsSClnUndsSClnUndsRParUndsUnds'C-SYNTAX'Unds'IterationStatement'Unds'Expression'Unds'Expression'Unds'Expression'Unds'Statement{}(Y0:SortExpression{}, Y1:SortExpression{}, Y2:SortExpression{}, Y3:SortStatement{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortIterationStatement{}} (\and{SortIterationStatement{}} (Lbldo'Unds'while'LParUndsRParSClnUnds'C-SYNTAX'Unds'IterationStatement'Unds'Statement'Unds'Expression{}(X0:SortStatement{}, X1:SortExpression{}), Lblwhile'LParUndsRParUndsUnds'C-SYNTAX'Unds'IterationStatement'Unds'Expression'Unds'Statement{}(Y0:SortExpression{}, Y1:SortStatement{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortTypeSpecifier{}, \equals{SortTypeSpecifier{}, R} (Val:SortTypeSpecifier{}, Lbldouble'Unds'C-SYNTAX'Unds'TypeSpecifier{}())) [functional{}()] // functional
  axiom{}\not{SortTypeSpecifier{}} (\and{SortTypeSpecifier{}} (Lbldouble'Unds'C-SYNTAX'Unds'TypeSpecifier{}(), Lblfloat'Unds'C-SYNTAX'Unds'TypeSpecifier{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortTypeSpecifier{}} (\and{SortTypeSpecifier{}} (Lbldouble'Unds'C-SYNTAX'Unds'TypeSpecifier{}(), Lblint'Unds'C-SYNTAX'Unds'TypeSpecifier{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortTypeSpecifier{}} (\and{SortTypeSpecifier{}} (Lbldouble'Unds'C-SYNTAX'Unds'TypeSpecifier{}(), Lbllong'Unds'C-SYNTAX'Unds'TypeSpecifier{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortTypeSpecifier{}} (\and{SortTypeSpecifier{}} (Lbldouble'Unds'C-SYNTAX'Unds'TypeSpecifier{}(), Lblshort'Unds'C-SYNTAX'Unds'TypeSpecifier{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortTypeSpecifier{}} (\and{SortTypeSpecifier{}} (Lbldouble'Unds'C-SYNTAX'Unds'TypeSpecifier{}(), Lblsigned'Unds'C-SYNTAX'Unds'TypeSpecifier{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortTypeSpecifier{}} (\and{SortTypeSpecifier{}} (Lbldouble'Unds'C-SYNTAX'Unds'TypeSpecifier{}(), Lblunsigned'Unds'C-SYNTAX'Unds'TypeSpecifier{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortTypeSpecifier{}} (\and{SortTypeSpecifier{}} (Lbldouble'Unds'C-SYNTAX'Unds'TypeSpecifier{}(), Lblvoid'Unds'C-SYNTAX'Unds'TypeSpecifier{}())) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortEnumOfspecifier{}, \equals{SortEnumOfspecifier{}, R} (Val:SortEnumOfspecifier{}, Lblenum'UndsUnds'C-SYNTAX'Unds'EnumOfspecifier'Unds'Id{}(K0:SortId{}))) [functional{}()] // functional
  axiom{}\implies{SortEnumOfspecifier{}} (\and{SortEnumOfspecifier{}} (Lblenum'UndsUnds'C-SYNTAX'Unds'EnumOfspecifier'Unds'Id{}(X0:SortId{}), Lblenum'UndsUnds'C-SYNTAX'Unds'EnumOfspecifier'Unds'Id{}(Y0:SortId{})), Lblenum'UndsUnds'C-SYNTAX'Unds'EnumOfspecifier'Unds'Id{}(\and{SortId{}} (X0:SortId{}, Y0:SortId{}))) [constructor{}()] // no confusion same constructor
  axiom{}\not{SortEnumOfspecifier{}} (\and{SortEnumOfspecifier{}} (Lblenum'UndsUnds'C-SYNTAX'Unds'EnumOfspecifier'Unds'Id{}(X0:SortId{}), Lblenum'UndsLBraUndsRBraUnds'C-SYNTAX'Unds'EnumOfspecifier'Unds'Id'Unds'EnumeratorList{}(Y0:SortId{}, Y1:SortEnumeratorList{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortEnumOfspecifier{}} (\and{SortEnumOfspecifier{}} (Lblenum'UndsUnds'C-SYNTAX'Unds'EnumOfspecifier'Unds'Id{}(X0:SortId{}), Lblenum'LBraUndsRBraUnds'C-SYNTAX'Unds'EnumOfspecifier'Unds'EnumeratorList{}(Y0:SortEnumeratorList{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortEnumOfspecifier{}, \equals{SortEnumOfspecifier{}, R} (Val:SortEnumOfspecifier{}, Lblenum'UndsLBraUndsRBraUnds'C-SYNTAX'Unds'EnumOfspecifier'Unds'Id'Unds'EnumeratorList{}(K0:SortId{}, K1:SortEnumeratorList{}))) [functional{}()] // functional
  axiom{}\implies{SortEnumOfspecifier{}} (\and{SortEnumOfspecifier{}} (Lblenum'UndsLBraUndsRBraUnds'C-SYNTAX'Unds'EnumOfspecifier'Unds'Id'Unds'EnumeratorList{}(X0:SortId{}, X1:SortEnumeratorList{}), Lblenum'UndsLBraUndsRBraUnds'C-SYNTAX'Unds'EnumOfspecifier'Unds'Id'Unds'EnumeratorList{}(Y0:SortId{}, Y1:SortEnumeratorList{})), Lblenum'UndsLBraUndsRBraUnds'C-SYNTAX'Unds'EnumOfspecifier'Unds'Id'Unds'EnumeratorList{}(\and{SortId{}} (X0:SortId{}, Y0:SortId{}), \and{SortEnumeratorList{}} (X1:SortEnumeratorList{}, Y1:SortEnumeratorList{}))) [constructor{}()] // no confusion same constructor
  axiom{}\not{SortEnumOfspecifier{}} (\and{SortEnumOfspecifier{}} (Lblenum'UndsLBraUndsRBraUnds'C-SYNTAX'Unds'EnumOfspecifier'Unds'Id'Unds'EnumeratorList{}(X0:SortId{}, X1:SortEnumeratorList{}), Lblenum'LBraUndsRBraUnds'C-SYNTAX'Unds'EnumOfspecifier'Unds'EnumeratorList{}(Y0:SortEnumeratorList{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortEnumOfspecifier{}, \equals{SortEnumOfspecifier{}, R} (Val:SortEnumOfspecifier{}, Lblenum'LBraUndsRBraUnds'C-SYNTAX'Unds'EnumOfspecifier'Unds'EnumeratorList{}(K0:SortEnumeratorList{}))) [functional{}()] // functional
  axiom{}\implies{SortEnumOfspecifier{}} (\and{SortEnumOfspecifier{}} (Lblenum'LBraUndsRBraUnds'C-SYNTAX'Unds'EnumOfspecifier'Unds'EnumeratorList{}(X0:SortEnumeratorList{}), Lblenum'LBraUndsRBraUnds'C-SYNTAX'Unds'EnumOfspecifier'Unds'EnumeratorList{}(Y0:SortEnumeratorList{})), Lblenum'LBraUndsRBraUnds'C-SYNTAX'Unds'EnumOfspecifier'Unds'EnumeratorList{}(\and{SortEnumeratorList{}} (X0:SortEnumeratorList{}, Y0:SortEnumeratorList{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortStorageClassSpecifier{}, \equals{SortStorageClassSpecifier{}, R} (Val:SortStorageClassSpecifier{}, Lblextern'Unds'C-SYNTAX'Unds'StorageClassSpecifier{}())) [functional{}()] // functional
  axiom{}\not{SortStorageClassSpecifier{}} (\and{SortStorageClassSpecifier{}} (Lblextern'Unds'C-SYNTAX'Unds'StorageClassSpecifier{}(), Lblregister'Unds'C-SYNTAX'Unds'StorageClassSpecifier{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortStorageClassSpecifier{}} (\and{SortStorageClassSpecifier{}} (Lblextern'Unds'C-SYNTAX'Unds'StorageClassSpecifier{}(), Lblstatic'Unds'C-SYNTAX'Unds'StorageClassSpecifier{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortStorageClassSpecifier{}} (\and{SortStorageClassSpecifier{}} (Lblextern'Unds'C-SYNTAX'Unds'StorageClassSpecifier{}(), Lbltypedef'Unds'C-SYNTAX'Unds'StorageClassSpecifier{}())) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortTypeSpecifier{}, \equals{SortTypeSpecifier{}, R} (Val:SortTypeSpecifier{}, Lblfloat'Unds'C-SYNTAX'Unds'TypeSpecifier{}())) [functional{}()] // functional
  axiom{}\not{SortTypeSpecifier{}} (\and{SortTypeSpecifier{}} (Lblfloat'Unds'C-SYNTAX'Unds'TypeSpecifier{}(), Lblint'Unds'C-SYNTAX'Unds'TypeSpecifier{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortTypeSpecifier{}} (\and{SortTypeSpecifier{}} (Lblfloat'Unds'C-SYNTAX'Unds'TypeSpecifier{}(), Lbllong'Unds'C-SYNTAX'Unds'TypeSpecifier{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortTypeSpecifier{}} (\and{SortTypeSpecifier{}} (Lblfloat'Unds'C-SYNTAX'Unds'TypeSpecifier{}(), Lblshort'Unds'C-SYNTAX'Unds'TypeSpecifier{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortTypeSpecifier{}} (\and{SortTypeSpecifier{}} (Lblfloat'Unds'C-SYNTAX'Unds'TypeSpecifier{}(), Lblsigned'Unds'C-SYNTAX'Unds'TypeSpecifier{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortTypeSpecifier{}} (\and{SortTypeSpecifier{}} (Lblfloat'Unds'C-SYNTAX'Unds'TypeSpecifier{}(), Lblunsigned'Unds'C-SYNTAX'Unds'TypeSpecifier{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortTypeSpecifier{}} (\and{SortTypeSpecifier{}} (Lblfloat'Unds'C-SYNTAX'Unds'TypeSpecifier{}(), Lblvoid'Unds'C-SYNTAX'Unds'TypeSpecifier{}())) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortIterationStatement{}, \equals{SortIterationStatement{}, R} (Val:SortIterationStatement{}, Lblfor'LParUndsSClnUndsSClnUndsRParUndsUnds'C-SYNTAX'Unds'IterationStatement'Unds'Expression'Unds'Expression'Unds'Expression'Unds'Statement{}(K0:SortExpression{}, K1:SortExpression{}, K2:SortExpression{}, K3:SortStatement{}))) [functional{}()] // functional
  axiom{}\implies{SortIterationStatement{}} (\and{SortIterationStatement{}} (Lblfor'LParUndsSClnUndsSClnUndsRParUndsUnds'C-SYNTAX'Unds'IterationStatement'Unds'Expression'Unds'Expression'Unds'Expression'Unds'Statement{}(X0:SortExpression{}, X1:SortExpression{}, X2:SortExpression{}, X3:SortStatement{}), Lblfor'LParUndsSClnUndsSClnUndsRParUndsUnds'C-SYNTAX'Unds'IterationStatement'Unds'Expression'Unds'Expression'Unds'Expression'Unds'Statement{}(Y0:SortExpression{}, Y1:SortExpression{}, Y2:SortExpression{}, Y3:SortStatement{})), Lblfor'LParUndsSClnUndsSClnUndsRParUndsUnds'C-SYNTAX'Unds'IterationStatement'Unds'Expression'Unds'Expression'Unds'Expression'Unds'Statement{}(\and{SortExpression{}} (X0:SortExpression{}, Y0:SortExpression{}), \and{SortExpression{}} (X1:SortExpression{}, Y1:SortExpression{}), \and{SortExpression{}} (X2:SortExpression{}, Y2:SortExpression{}), \and{SortStatement{}} (X3:SortStatement{}, Y3:SortStatement{}))) [constructor{}()] // no confusion same constructor
  axiom{}\not{SortIterationStatement{}} (\and{SortIterationStatement{}} (Lblfor'LParUndsSClnUndsSClnUndsRParUndsUnds'C-SYNTAX'Unds'IterationStatement'Unds'Expression'Unds'Expression'Unds'Expression'Unds'Statement{}(X0:SortExpression{}, X1:SortExpression{}, X2:SortExpression{}, X3:SortStatement{}), Lblwhile'LParUndsRParUndsUnds'C-SYNTAX'Unds'IterationStatement'Unds'Expression'Unds'Statement{}(Y0:SortExpression{}, Y1:SortStatement{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortId{}, \equals{SortId{}, R} (Val:SortId{}, LblfreshId'LParUndsRParUnds'ID-COMMON'Unds'Id'Unds'Int{}(K0:SortInt{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortInt{}, \equals{SortInt{}, R} (Val:SortInt{}, LblfreshInt'LParUndsRParUnds'INT'Unds'Int'Unds'Int{}(K0:SortInt{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortJumpStatement{}, \equals{SortJumpStatement{}, R} (Val:SortJumpStatement{}, Lblgoto'UndsSClnUnds'C-SYNTAX'Unds'JumpStatement'Unds'Id{}(K0:SortId{}))) [functional{}()] // functional
  axiom{}\implies{SortJumpStatement{}} (\and{SortJumpStatement{}} (Lblgoto'UndsSClnUnds'C-SYNTAX'Unds'JumpStatement'Unds'Id{}(X0:SortId{}), Lblgoto'UndsSClnUnds'C-SYNTAX'Unds'JumpStatement'Unds'Id{}(Y0:SortId{})), Lblgoto'UndsSClnUnds'C-SYNTAX'Unds'JumpStatement'Unds'Id{}(\and{SortId{}} (X0:SortId{}, Y0:SortId{}))) [constructor{}()] // no confusion same constructor
  axiom{}\not{SortJumpStatement{}} (\and{SortJumpStatement{}} (Lblgoto'UndsSClnUnds'C-SYNTAX'Unds'JumpStatement'Unds'Id{}(X0:SortId{}), Lblreturn'UndsSClnUnds'C-SYNTAX'Unds'JumpStatement'Unds'Expression{}(Y0:SortExpression{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortSelectionStatement{}, \equals{SortSelectionStatement{}, R} (Val:SortSelectionStatement{}, Lblif'LParUndsRParUndsUnds'C-SYNTAX'Unds'SelectionStatement'Unds'Expression'Unds'Statement{}(K0:SortExpression{}, K1:SortStatement{}))) [functional{}()] // functional
  axiom{}\implies{SortSelectionStatement{}} (\and{SortSelectionStatement{}} (Lblif'LParUndsRParUndsUnds'C-SYNTAX'Unds'SelectionStatement'Unds'Expression'Unds'Statement{}(X0:SortExpression{}, X1:SortStatement{}), Lblif'LParUndsRParUndsUnds'C-SYNTAX'Unds'SelectionStatement'Unds'Expression'Unds'Statement{}(Y0:SortExpression{}, Y1:SortStatement{})), Lblif'LParUndsRParUndsUnds'C-SYNTAX'Unds'SelectionStatement'Unds'Expression'Unds'Statement{}(\and{SortExpression{}} (X0:SortExpression{}, Y0:SortExpression{}), \and{SortStatement{}} (X1:SortStatement{}, Y1:SortStatement{}))) [constructor{}()] // no confusion same constructor
  axiom{}\not{SortSelectionStatement{}} (\and{SortSelectionStatement{}} (Lblif'LParUndsRParUndsUnds'C-SYNTAX'Unds'SelectionStatement'Unds'Expression'Unds'Statement{}(X0:SortExpression{}, X1:SortStatement{}), Lblif'LParUndsRParUnds'else'UndsUnds'C-SYNTAX'Unds'SelectionStatement'Unds'Expression'Unds'Statement'Unds'Statement{}(Y0:SortExpression{}, Y1:SortStatement{}, Y2:SortStatement{}))) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortSelectionStatement{}} (\and{SortSelectionStatement{}} (Lblif'LParUndsRParUndsUnds'C-SYNTAX'Unds'SelectionStatement'Unds'Expression'Unds'Statement{}(X0:SortExpression{}, X1:SortStatement{}), Lblswitch'LParUndsRParUndsUnds'C-SYNTAX'Unds'SelectionStatement'Unds'Expression'Unds'Statement{}(Y0:SortExpression{}, Y1:SortStatement{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortSelectionStatement{}, \equals{SortSelectionStatement{}, R} (Val:SortSelectionStatement{}, Lblif'LParUndsRParUnds'else'UndsUnds'C-SYNTAX'Unds'SelectionStatement'Unds'Expression'Unds'Statement'Unds'Statement{}(K0:SortExpression{}, K1:SortStatement{}, K2:SortStatement{}))) [functional{}()] // functional
  axiom{}\implies{SortSelectionStatement{}} (\and{SortSelectionStatement{}} (Lblif'LParUndsRParUnds'else'UndsUnds'C-SYNTAX'Unds'SelectionStatement'Unds'Expression'Unds'Statement'Unds'Statement{}(X0:SortExpression{}, X1:SortStatement{}, X2:SortStatement{}), Lblif'LParUndsRParUnds'else'UndsUnds'C-SYNTAX'Unds'SelectionStatement'Unds'Expression'Unds'Statement'Unds'Statement{}(Y0:SortExpression{}, Y1:SortStatement{}, Y2:SortStatement{})), Lblif'LParUndsRParUnds'else'UndsUnds'C-SYNTAX'Unds'SelectionStatement'Unds'Expression'Unds'Statement'Unds'Statement{}(\and{SortExpression{}} (X0:SortExpression{}, Y0:SortExpression{}), \and{SortStatement{}} (X1:SortStatement{}, Y1:SortStatement{}), \and{SortStatement{}} (X2:SortStatement{}, Y2:SortStatement{}))) [constructor{}()] // no confusion same constructor
  axiom{}\not{SortSelectionStatement{}} (\and{SortSelectionStatement{}} (Lblif'LParUndsRParUnds'else'UndsUnds'C-SYNTAX'Unds'SelectionStatement'Unds'Expression'Unds'Statement'Unds'Statement{}(X0:SortExpression{}, X1:SortStatement{}, X2:SortStatement{}), Lblswitch'LParUndsRParUndsUnds'C-SYNTAX'Unds'SelectionStatement'Unds'Expression'Unds'Statement{}(Y0:SortExpression{}, Y1:SortStatement{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortTypeSpecifier{}, \equals{SortTypeSpecifier{}, R} (Val:SortTypeSpecifier{}, Lblint'Unds'C-SYNTAX'Unds'TypeSpecifier{}())) [functional{}()] // functional
  axiom{}\not{SortTypeSpecifier{}} (\and{SortTypeSpecifier{}} (Lblint'Unds'C-SYNTAX'Unds'TypeSpecifier{}(), Lbllong'Unds'C-SYNTAX'Unds'TypeSpecifier{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortTypeSpecifier{}} (\and{SortTypeSpecifier{}} (Lblint'Unds'C-SYNTAX'Unds'TypeSpecifier{}(), Lblshort'Unds'C-SYNTAX'Unds'TypeSpecifier{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortTypeSpecifier{}} (\and{SortTypeSpecifier{}} (Lblint'Unds'C-SYNTAX'Unds'TypeSpecifier{}(), Lblsigned'Unds'C-SYNTAX'Unds'TypeSpecifier{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortTypeSpecifier{}} (\and{SortTypeSpecifier{}} (Lblint'Unds'C-SYNTAX'Unds'TypeSpecifier{}(), Lblunsigned'Unds'C-SYNTAX'Unds'TypeSpecifier{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortTypeSpecifier{}} (\and{SortTypeSpecifier{}} (Lblint'Unds'C-SYNTAX'Unds'TypeSpecifier{}(), Lblvoid'Unds'C-SYNTAX'Unds'TypeSpecifier{}())) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortSet{}, \equals{SortSet{}, R} (Val:SortSet{}, LblintersectSet'LParUndsCommUndsRParUnds'SET'Unds'Set'Unds'Set'Unds'Set{}(K0:SortSet{}, K1:SortSet{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortSet{}, \equals{SortSet{}, R} (Val:SortSet{}, Lblkeys'LParUndsRParUnds'MAP'Unds'Set'Unds'Map{}(K0:SortMap{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortInt{}, \equals{SortInt{}, R} (Val:SortInt{}, LbllengthString'LParUndsRParUnds'STRING-COMMON'Unds'Int'Unds'String{}(K0:SortString{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortTypeSpecifier{}, \equals{SortTypeSpecifier{}, R} (Val:SortTypeSpecifier{}, Lbllong'Unds'C-SYNTAX'Unds'TypeSpecifier{}())) [functional{}()] // functional
  axiom{}\not{SortTypeSpecifier{}} (\and{SortTypeSpecifier{}} (Lbllong'Unds'C-SYNTAX'Unds'TypeSpecifier{}(), Lblshort'Unds'C-SYNTAX'Unds'TypeSpecifier{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortTypeSpecifier{}} (\and{SortTypeSpecifier{}} (Lbllong'Unds'C-SYNTAX'Unds'TypeSpecifier{}(), Lblsigned'Unds'C-SYNTAX'Unds'TypeSpecifier{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortTypeSpecifier{}} (\and{SortTypeSpecifier{}} (Lbllong'Unds'C-SYNTAX'Unds'TypeSpecifier{}(), Lblunsigned'Unds'C-SYNTAX'Unds'TypeSpecifier{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortTypeSpecifier{}} (\and{SortTypeSpecifier{}} (Lbllong'Unds'C-SYNTAX'Unds'TypeSpecifier{}(), Lblvoid'Unds'C-SYNTAX'Unds'TypeSpecifier{}())) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortInt{}, \equals{SortInt{}, R} (Val:SortInt{}, LblmaxInt'LParUndsCommUndsRParUnds'INT-COMMON'Unds'Int'Unds'Int'Unds'Int{}(K0:SortInt{}, K1:SortInt{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortInt{}, \equals{SortInt{}, R} (Val:SortInt{}, LblminInt'LParUndsCommUndsRParUnds'INT-COMMON'Unds'Int'Unds'Int'Unds'Int{}(K0:SortInt{}, K1:SortInt{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortGeneratedCounterCellOpt{}, \equals{SortGeneratedCounterCellOpt{}, R} (Val:SortGeneratedCounterCellOpt{}, LblnoGeneratedCounterCell{}())) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortKCellOpt{}, \equals{SortKCellOpt{}, R} (Val:SortKCellOpt{}, LblnoKCell{}())) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortOslCellOpt{}, \equals{SortOslCellOpt{}, R} (Val:SortOslCellOpt{}, LblnoOslCell{}())) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortTCellOpt{}, \equals{SortTCellOpt{}, R} (Val:SortTCellOpt{}, LblnoTCell{}())) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortBool{}, \equals{SortBool{}, R} (Val:SortBool{}, LblnotBool'Unds'{}(K0:SortBool{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortStorageClassSpecifier{}, \equals{SortStorageClassSpecifier{}, R} (Val:SortStorageClassSpecifier{}, Lblregister'Unds'C-SYNTAX'Unds'StorageClassSpecifier{}())) [functional{}()] // functional
  axiom{}\not{SortStorageClassSpecifier{}} (\and{SortStorageClassSpecifier{}} (Lblregister'Unds'C-SYNTAX'Unds'StorageClassSpecifier{}(), Lblstatic'Unds'C-SYNTAX'Unds'StorageClassSpecifier{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortStorageClassSpecifier{}} (\and{SortStorageClassSpecifier{}} (Lblregister'Unds'C-SYNTAX'Unds'StorageClassSpecifier{}(), Lbltypedef'Unds'C-SYNTAX'Unds'StorageClassSpecifier{}())) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortMap{}, \equals{SortMap{}, R} (Val:SortMap{}, LblremoveAll'LParUndsCommUndsRParUnds'MAP'Unds'Map'Unds'Map'Unds'Set{}(K0:SortMap{}, K1:SortSet{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortString{}, \equals{SortString{}, R} (Val:SortString{}, LblreplaceAll'LParUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'String'Unds'String'Unds'String'Unds'String{}(K0:SortString{}, K1:SortString{}, K2:SortString{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortString{}, \equals{SortString{}, R} (Val:SortString{}, LblreplaceFirst'LParUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'String'Unds'String'Unds'String'Unds'String{}(K0:SortString{}, K1:SortString{}, K2:SortString{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortJumpStatement{}, \equals{SortJumpStatement{}, R} (Val:SortJumpStatement{}, Lblreturn'UndsSClnUnds'C-SYNTAX'Unds'JumpStatement'Unds'Expression{}(K0:SortExpression{}))) [functional{}()] // functional
  axiom{}\implies{SortJumpStatement{}} (\and{SortJumpStatement{}} (Lblreturn'UndsSClnUnds'C-SYNTAX'Unds'JumpStatement'Unds'Expression{}(X0:SortExpression{}), Lblreturn'UndsSClnUnds'C-SYNTAX'Unds'JumpStatement'Unds'Expression{}(Y0:SortExpression{})), Lblreturn'UndsSClnUnds'C-SYNTAX'Unds'JumpStatement'Unds'Expression{}(\and{SortExpression{}} (X0:SortExpression{}, Y0:SortExpression{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortTypeSpecifier{}, \equals{SortTypeSpecifier{}, R} (Val:SortTypeSpecifier{}, Lblshort'Unds'C-SYNTAX'Unds'TypeSpecifier{}())) [functional{}()] // functional
  axiom{}\not{SortTypeSpecifier{}} (\and{SortTypeSpecifier{}} (Lblshort'Unds'C-SYNTAX'Unds'TypeSpecifier{}(), Lblsigned'Unds'C-SYNTAX'Unds'TypeSpecifier{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortTypeSpecifier{}} (\and{SortTypeSpecifier{}} (Lblshort'Unds'C-SYNTAX'Unds'TypeSpecifier{}(), Lblunsigned'Unds'C-SYNTAX'Unds'TypeSpecifier{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortTypeSpecifier{}} (\and{SortTypeSpecifier{}} (Lblshort'Unds'C-SYNTAX'Unds'TypeSpecifier{}(), Lblvoid'Unds'C-SYNTAX'Unds'TypeSpecifier{}())) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortTypeSpecifier{}, \equals{SortTypeSpecifier{}, R} (Val:SortTypeSpecifier{}, Lblsigned'Unds'C-SYNTAX'Unds'TypeSpecifier{}())) [functional{}()] // functional
  axiom{}\not{SortTypeSpecifier{}} (\and{SortTypeSpecifier{}} (Lblsigned'Unds'C-SYNTAX'Unds'TypeSpecifier{}(), Lblunsigned'Unds'C-SYNTAX'Unds'TypeSpecifier{}())) [constructor{}()] // no confusion different constructors
  axiom{}\not{SortTypeSpecifier{}} (\and{SortTypeSpecifier{}} (Lblsigned'Unds'C-SYNTAX'Unds'TypeSpecifier{}(), Lblvoid'Unds'C-SYNTAX'Unds'TypeSpecifier{}())) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortInt{}, \equals{SortInt{}, R} (Val:SortInt{}, Lblsize'LParUndsRParUnds'LIST'Unds'Int'Unds'List{}(K0:SortList{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortInt{}, \equals{SortInt{}, R} (Val:SortInt{}, Lblsize'LParUndsRParUnds'MAP'Unds'Int'Unds'Map{}(K0:SortMap{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortInt{}, \equals{SortInt{}, R} (Val:SortInt{}, Lblsize'LParUndsRParUnds'SET'Unds'Int'Unds'Set{}(K0:SortSet{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortUnaryExpression{}, \equals{SortUnaryExpression{}, R} (Val:SortUnaryExpression{}, Lblsizeof'UndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'TypeName{}(K0:SortTypeName{}))) [functional{}()] // functional
  axiom{}\implies{SortUnaryExpression{}} (\and{SortUnaryExpression{}} (Lblsizeof'UndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'TypeName{}(X0:SortTypeName{}), Lblsizeof'UndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'TypeName{}(Y0:SortTypeName{})), Lblsizeof'UndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'TypeName{}(\and{SortTypeName{}} (X0:SortTypeName{}, Y0:SortTypeName{}))) [constructor{}()] // no confusion same constructor
  axiom{}\not{SortUnaryExpression{}} (\and{SortUnaryExpression{}} (Lblsizeof'UndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'TypeName{}(X0:SortTypeName{}), Lblsizeof'UndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'UnaryExpression{}(Y0:SortUnaryExpression{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortUnaryExpression{}, \equals{SortUnaryExpression{}, R} (Val:SortUnaryExpression{}, Lblsizeof'UndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'UnaryExpression{}(K0:SortUnaryExpression{}))) [functional{}()] // functional
  axiom{}\implies{SortUnaryExpression{}} (\and{SortUnaryExpression{}} (Lblsizeof'UndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'UnaryExpression{}(X0:SortUnaryExpression{}), Lblsizeof'UndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'UnaryExpression{}(Y0:SortUnaryExpression{})), Lblsizeof'UndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'UnaryExpression{}(\and{SortUnaryExpression{}} (X0:SortUnaryExpression{}, Y0:SortUnaryExpression{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortStorageClassSpecifier{}, \equals{SortStorageClassSpecifier{}, R} (Val:SortStorageClassSpecifier{}, Lblstatic'Unds'C-SYNTAX'Unds'StorageClassSpecifier{}())) [functional{}()] // functional
  axiom{}\not{SortStorageClassSpecifier{}} (\and{SortStorageClassSpecifier{}} (Lblstatic'Unds'C-SYNTAX'Unds'StorageClassSpecifier{}(), Lbltypedef'Unds'C-SYNTAX'Unds'StorageClassSpecifier{}())) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortStructOrUnion{}, \equals{SortStructOrUnion{}, R} (Val:SortStructOrUnion{}, Lblstruct'Unds'C-SYNTAX'Unds'StructOrUnion{}())) [functional{}()] // functional
  axiom{}\not{SortStructOrUnion{}} (\and{SortStructOrUnion{}} (Lblstruct'Unds'C-SYNTAX'Unds'StructOrUnion{}(), Lblunion'Unds'C-SYNTAX'Unds'StructOrUnion{}())) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortString{}, \equals{SortString{}, R} (Val:SortString{}, LblsubstrString'LParUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'String'Unds'String'Unds'Int'Unds'Int{}(K0:SortString{}, K1:SortInt{}, K2:SortInt{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortSelectionStatement{}, \equals{SortSelectionStatement{}, R} (Val:SortSelectionStatement{}, Lblswitch'LParUndsRParUndsUnds'C-SYNTAX'Unds'SelectionStatement'Unds'Expression'Unds'Statement{}(K0:SortExpression{}, K1:SortStatement{}))) [functional{}()] // functional
  axiom{}\implies{SortSelectionStatement{}} (\and{SortSelectionStatement{}} (Lblswitch'LParUndsRParUndsUnds'C-SYNTAX'Unds'SelectionStatement'Unds'Expression'Unds'Statement{}(X0:SortExpression{}, X1:SortStatement{}), Lblswitch'LParUndsRParUndsUnds'C-SYNTAX'Unds'SelectionStatement'Unds'Expression'Unds'Statement{}(Y0:SortExpression{}, Y1:SortStatement{})), Lblswitch'LParUndsRParUndsUnds'C-SYNTAX'Unds'SelectionStatement'Unds'Expression'Unds'Statement{}(\and{SortExpression{}} (X0:SortExpression{}, Y0:SortExpression{}), \and{SortStatement{}} (X1:SortStatement{}, Y1:SortStatement{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortStorageClassSpecifier{}, \equals{SortStorageClassSpecifier{}, R} (Val:SortStorageClassSpecifier{}, Lbltypedef'Unds'C-SYNTAX'Unds'StorageClassSpecifier{}())) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortStructOrUnion{}, \equals{SortStructOrUnion{}, R} (Val:SortStructOrUnion{}, Lblunion'Unds'C-SYNTAX'Unds'StructOrUnion{}())) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortTypeSpecifier{}, \equals{SortTypeSpecifier{}, R} (Val:SortTypeSpecifier{}, Lblunsigned'Unds'C-SYNTAX'Unds'TypeSpecifier{}())) [functional{}()] // functional
  axiom{}\not{SortTypeSpecifier{}} (\and{SortTypeSpecifier{}} (Lblunsigned'Unds'C-SYNTAX'Unds'TypeSpecifier{}(), Lblvoid'Unds'C-SYNTAX'Unds'TypeSpecifier{}())) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortMap{}, \equals{SortMap{}, R} (Val:SortMap{}, LblupdateMap'LParUndsCommUndsRParUnds'MAP'Unds'Map'Unds'Map'Unds'Map{}(K0:SortMap{}, K1:SortMap{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortTypeSpecifier{}, \equals{SortTypeSpecifier{}, R} (Val:SortTypeSpecifier{}, Lblvoid'Unds'C-SYNTAX'Unds'TypeSpecifier{}())) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortTypeQualifier{}, \equals{SortTypeQualifier{}, R} (Val:SortTypeQualifier{}, Lblvolatile'Unds'C-SYNTAX'Unds'TypeQualifier{}())) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortIterationStatement{}, \equals{SortIterationStatement{}, R} (Val:SortIterationStatement{}, Lblwhile'LParUndsRParUndsUnds'C-SYNTAX'Unds'IterationStatement'Unds'Expression'Unds'Statement{}(K0:SortExpression{}, K1:SortStatement{}))) [functional{}()] // functional
  axiom{}\implies{SortIterationStatement{}} (\and{SortIterationStatement{}} (Lblwhile'LParUndsRParUndsUnds'C-SYNTAX'Unds'IterationStatement'Unds'Expression'Unds'Statement{}(X0:SortExpression{}, X1:SortStatement{}), Lblwhile'LParUndsRParUndsUnds'C-SYNTAX'Unds'IterationStatement'Unds'Expression'Unds'Statement{}(Y0:SortExpression{}, Y1:SortStatement{})), Lblwhile'LParUndsRParUndsUnds'C-SYNTAX'Unds'IterationStatement'Unds'Expression'Unds'Statement{}(\and{SortExpression{}} (X0:SortExpression{}, Y0:SortExpression{}), \and{SortStatement{}} (X1:SortStatement{}, Y1:SortStatement{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortInitializer{}, \equals{SortInitializer{}, R} (Val:SortInitializer{}, Lbl'LBraUndsCommRBraUnds'C-SYNTAX'Unds'Initializer'Unds'InitializerList{}(K0:SortInitializerList{}))) [functional{}()] // functional
  axiom{}\implies{SortInitializer{}} (\and{SortInitializer{}} (Lbl'LBraUndsCommRBraUnds'C-SYNTAX'Unds'Initializer'Unds'InitializerList{}(X0:SortInitializerList{}), Lbl'LBraUndsCommRBraUnds'C-SYNTAX'Unds'Initializer'Unds'InitializerList{}(Y0:SortInitializerList{})), Lbl'LBraUndsCommRBraUnds'C-SYNTAX'Unds'Initializer'Unds'InitializerList{}(\and{SortInitializerList{}} (X0:SortInitializerList{}, Y0:SortInitializerList{}))) [constructor{}()] // no confusion same constructor
  axiom{}\not{SortInitializer{}} (\and{SortInitializer{}} (Lbl'LBraUndsCommRBraUnds'C-SYNTAX'Unds'Initializer'Unds'InitializerList{}(X0:SortInitializerList{}), Lbl'LBraUndsRBraUnds'C-SYNTAX'Unds'Initializer'Unds'InitializerList{}(Y0:SortInitializerList{}))) [constructor{}()] // no confusion different constructors
  axiom{R} \exists{R} (Val:SortCompoundStatement{}, \equals{SortCompoundStatement{}, R} (Val:SortCompoundStatement{}, Lbl'LBraUndsUndsRBraUnds'C-SYNTAX'Unds'CompoundStatement'Unds'ListDeclaration'Unds'ListStatement{}(K0:SortListDeclaration{}, K1:SortListStatement{}))) [functional{}()] // functional
  axiom{}\implies{SortCompoundStatement{}} (\and{SortCompoundStatement{}} (Lbl'LBraUndsUndsRBraUnds'C-SYNTAX'Unds'CompoundStatement'Unds'ListDeclaration'Unds'ListStatement{}(X0:SortListDeclaration{}, X1:SortListStatement{}), Lbl'LBraUndsUndsRBraUnds'C-SYNTAX'Unds'CompoundStatement'Unds'ListDeclaration'Unds'ListStatement{}(Y0:SortListDeclaration{}, Y1:SortListStatement{})), Lbl'LBraUndsUndsRBraUnds'C-SYNTAX'Unds'CompoundStatement'Unds'ListDeclaration'Unds'ListStatement{}(\and{SortListDeclaration{}} (X0:SortListDeclaration{}, Y0:SortListDeclaration{}), \and{SortListStatement{}} (X1:SortListStatement{}, Y1:SortListStatement{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortInitializer{}, \equals{SortInitializer{}, R} (Val:SortInitializer{}, Lbl'LBraUndsRBraUnds'C-SYNTAX'Unds'Initializer'Unds'InitializerList{}(K0:SortInitializerList{}))) [functional{}()] // functional
  axiom{}\implies{SortInitializer{}} (\and{SortInitializer{}} (Lbl'LBraUndsRBraUnds'C-SYNTAX'Unds'Initializer'Unds'InitializerList{}(X0:SortInitializerList{}), Lbl'LBraUndsRBraUnds'C-SYNTAX'Unds'Initializer'Unds'InitializerList{}(Y0:SortInitializerList{})), Lbl'LBraUndsRBraUnds'C-SYNTAX'Unds'Initializer'Unds'InitializerList{}(\and{SortInitializerList{}} (X0:SortInitializerList{}, Y0:SortInitializerList{}))) [constructor{}()] // no confusion same constructor
  axiom{R} \exists{R} (Val:SortAssignmentOperator{}, \equals{SortAssignmentOperator{}, R} (Val:SortAssignmentOperator{}, Lbl'PipeEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}())) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortInt{}, \equals{SortInt{}, R} (Val:SortInt{}, Lbl'Tild'Int'Unds'{}(K0:SortInt{}))) [functional{}()] // functional
  axiom{R} \exists{R} (Val:SortUnaryOperator{}, \equals{SortUnaryOperator{}, R} (Val:SortUnaryOperator{}, Lbl'TildUnds'C-SYNTAX'Unds'UnaryOperator{}())) [functional{}()] // functional
  axiom{} \or{SortTypedefOfname{}} (\exists{SortTypedefOfname{}} (Val:SortId{}, inj{SortId{}, SortTypedefOfname{}} (Val:SortId{})), \bottom{SortTypedefOfname{}}()) [constructor{}()] // no junk
  axiom{} \or{SortListInitDeclarator{}} (Lbl'Stop'List'LBraQuotUndsCommUndsUnds'C-SYNTAX'Unds'ListInitDeclarator'Unds'Initdeclarator'Unds'ListInitDeclarator'QuotRBraUnds'ListInitDeclarator{}(), \or{SortListInitDeclarator{}} (\exists{SortListInitDeclarator{}} (X0:SortInitdeclarator{}, \exists{SortListInitDeclarator{}} (X1:SortListInitDeclarator{}, Lbl'UndsCommUndsUnds'C-SYNTAX'Unds'ListInitDeclarator'Unds'Initdeclarator'Unds'ListInitDeclarator{}(X0:SortInitdeclarator{}, X1:SortListInitDeclarator{}))), \bottom{SortListInitDeclarator{}}())) [constructor{}()] // no junk
  axiom{} \or{SortPostfixExpression{}} (\exists{SortPostfixExpression{}} (X0:SortPostfixExpression{}, \exists{SortPostfixExpression{}} (X1:SortListAssignmentExpression{}, Lbl'UndsLParUndsRParUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression'Unds'ListAssignmentExpression{}(X0:SortPostfixExpression{}, X1:SortListAssignmentExpression{}))), \or{SortPostfixExpression{}} (\exists{SortPostfixExpression{}} (X0:SortPostfixExpression{}, Lbl'UndsPlusPlusUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression{}(X0:SortPostfixExpression{})), \or{SortPostfixExpression{}} (\exists{SortPostfixExpression{}} (X0:SortPostfixExpression{}, Lbl'Unds'--'Unds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression{}(X0:SortPostfixExpression{})), \or{SortPostfixExpression{}} (\exists{SortPostfixExpression{}} (X0:SortPostfixExpression{}, \exists{SortPostfixExpression{}} (X1:SortId{}, Lbl'Unds'-'-GT-UndsUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression'Unds'Id{}(X0:SortPostfixExpression{}, X1:SortId{}))), \or{SortPostfixExpression{}} (\exists{SortPostfixExpression{}} (X0:SortPostfixExpression{}, \exists{SortPostfixExpression{}} (X1:SortId{}, Lbl'UndsStopUndsUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression'Unds'Id{}(X0:SortPostfixExpression{}, X1:SortId{}))), \or{SortPostfixExpression{}} (\exists{SortPostfixExpression{}} (X0:SortPostfixExpression{}, \exists{SortPostfixExpression{}} (X1:SortExpression{}, Lbl'UndsLSqBUndsRSqBUnds'C-SYNTAX'Unds'PostfixExpression'Unds'PostfixExpression'Unds'Expression{}(X0:SortPostfixExpression{}, X1:SortExpression{}))), \or{SortPostfixExpression{}} (\exists{SortPostfixExpression{}} (Val:SortString{}, inj{SortString{}, SortPostfixExpression{}} (Val:SortString{})), \or{SortPostfixExpression{}} (\exists{SortPostfixExpression{}} (Val:SortPrimaryExpression{}, inj{SortPrimaryExpression{}, SortPostfixExpression{}} (Val:SortPrimaryExpression{})), \or{SortPostfixExpression{}} (\exists{SortPostfixExpression{}} (Val:SortId{}, inj{SortId{}, SortPostfixExpression{}} (Val:SortId{})), \or{SortPostfixExpression{}} (\exists{SortPostfixExpression{}} (Val:SortConstant{}, inj{SortConstant{}, SortPostfixExpression{}} (Val:SortConstant{})), \or{SortPostfixExpression{}} (\exists{SortPostfixExpression{}} (Val:SortInt{}, inj{SortInt{}, SortPostfixExpression{}} (Val:SortInt{})), \or{SortPostfixExpression{}} (\exists{SortPostfixExpression{}} (Val:SortFloat{}, inj{SortFloat{}, SortPostfixExpression{}} (Val:SortFloat{})), \or{SortPostfixExpression{}} (\exists{SortPostfixExpression{}} (Val:SortEnumerationConstant{}, inj{SortEnumerationConstant{}, SortPostfixExpression{}} (Val:SortEnumerationConstant{})), \bottom{SortPostfixExpression{}}()))))))))))))) [constructor{}()] // no junk
  axiom{} \or{SortRelationalExpression{}} (\exists{SortRelationalExpression{}} (X0:SortRelationalExpression{}, \exists{SortRelationalExpression{}} (X1:SortShiftExpression{}, Lbl'Unds-LT-EqlsUndsUnds'C-SYNTAX'Unds'RelationalExpression'Unds'RelationalExpression'Unds'ShiftExpression{}(X0:SortRelationalExpression{}, X1:SortShiftExpression{}))), \or{SortRelationalExpression{}} (\exists{SortRelationalExpression{}} (X0:SortRelationalExpression{}, \exists{SortRelationalExpression{}} (X1:SortShiftExpression{}, Lbl'Unds-LT-UndsUnds'C-SYNTAX'Unds'RelationalExpression'Unds'RelationalExpression'Unds'ShiftExpression{}(X0:SortRelationalExpression{}, X1:SortShiftExpression{}))), \or{SortRelationalExpression{}} (\exists{SortRelationalExpression{}} (X0:SortRelationalExpression{}, \exists{SortRelationalExpression{}} (X1:SortShiftExpression{}, Lbl'Unds-GT-EqlsUndsUnds'C-SYNTAX'Unds'RelationalExpression'Unds'RelationalExpression'Unds'ShiftExpression{}(X0:SortRelationalExpression{}, X1:SortShiftExpression{}))), \or{SortRelationalExpression{}} (\exists{SortRelationalExpression{}} (X0:SortRelationalExpression{}, \exists{SortRelationalExpression{}} (X1:SortShiftExpression{}, Lbl'Unds-GT-UndsUnds'C-SYNTAX'Unds'RelationalExpression'Unds'RelationalExpression'Unds'ShiftExpression{}(X0:SortRelationalExpression{}, X1:SortShiftExpression{}))), \or{SortRelationalExpression{}} (\exists{SortRelationalExpression{}} (Val:SortPostfixExpression{}, inj{SortPostfixExpression{}, SortRelationalExpression{}} (Val:SortPostfixExpression{})), \or{SortRelationalExpression{}} (\exists{SortRelationalExpression{}} (Val:SortString{}, inj{SortString{}, SortRelationalExpression{}} (Val:SortString{})), \or{SortRelationalExpression{}} (\exists{SortRelationalExpression{}} (Val:SortPrimaryExpression{}, inj{SortPrimaryExpression{}, SortRelationalExpression{}} (Val:SortPrimaryExpression{})), \or{SortRelationalExpression{}} (\exists{SortRelationalExpression{}} (Val:SortUnaryExpression{}, inj{SortUnaryExpression{}, SortRelationalExpression{}} (Val:SortUnaryExpression{})), \or{SortRelationalExpression{}} (\exists{SortRelationalExpression{}} (Val:SortId{}, inj{SortId{}, SortRelationalExpression{}} (Val:SortId{})), \or{SortRelationalExpression{}} (\exists{SortRelationalExpression{}} (Val:SortConstant{}, inj{SortConstant{}, SortRelationalExpression{}} (Val:SortConstant{})), \or{SortRelationalExpression{}} (\exists{SortRelationalExpression{}} (Val:SortMultiplicativeExpression{}, inj{SortMultiplicativeExpression{}, SortRelationalExpression{}} (Val:SortMultiplicativeExpression{})), \or{SortRelationalExpression{}} (\exists{SortRelationalExpression{}} (Val:SortInt{}, inj{SortInt{}, SortRelationalExpression{}} (Val:SortInt{})), \or{SortRelationalExpression{}} (\exists{SortRelationalExpression{}} (Val:SortFloat{}, inj{SortFloat{}, SortRelationalExpression{}} (Val:SortFloat{})), \or{SortRelationalExpression{}} (\exists{SortRelationalExpression{}} (Val:SortCastExpression{}, inj{SortCastExpression{}, SortRelationalExpression{}} (Val:SortCastExpression{})), \or{SortRelationalExpression{}} (\exists{SortRelationalExpression{}} (Val:SortAdditiveExpression{}, inj{SortAdditiveExpression{}, SortRelationalExpression{}} (Val:SortAdditiveExpression{})), \or{SortRelationalExpression{}} (\exists{SortRelationalExpression{}} (Val:SortEnumerationConstant{}, inj{SortEnumerationConstant{}, SortRelationalExpression{}} (Val:SortEnumerationConstant{})), \or{SortRelationalExpression{}} (\exists{SortRelationalExpression{}} (Val:SortShiftExpression{}, inj{SortShiftExpression{}, SortRelationalExpression{}} (Val:SortShiftExpression{})), \bottom{SortRelationalExpression{}}()))))))))))))))))) [constructor{}()] // no junk
  axiom{} \or{SortKItem{}} (\exists{SortKItem{}} (X0:SortInt{}, \exists{SortKItem{}} (X1:SortString{}, \exists{SortKItem{}} (X2:SortString{}, Lbl'Hash'systemResult{}(X0:SortInt{}, X1:SortString{}, X2:SortString{})))), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortTypedefOfname{}, inj{SortTypedefOfname{}, SortKItem{}} (Val:SortTypedefOfname{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortListInitDeclarator{}, inj{SortListInitDeclarator{}, SortKItem{}} (Val:SortListInitDeclarator{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortPostfixExpression{}, inj{SortPostfixExpression{}, SortKItem{}} (Val:SortPostfixExpression{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortRelationalExpression{}, inj{SortRelationalExpression{}, SortKItem{}} (Val:SortRelationalExpression{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortUnaryOperator{}, inj{SortUnaryOperator{}, SortKItem{}} (Val:SortUnaryOperator{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortEqualityExpression{}, inj{SortEqualityExpression{}, SortKItem{}} (Val:SortEqualityExpression{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortStorageClassSpecifier{}, inj{SortStorageClassSpecifier{}, SortKItem{}} (Val:SortStorageClassSpecifier{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortSpecifierQualifier{}, inj{SortSpecifierQualifier{}, SortKItem{}} (Val:SortSpecifierQualifier{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortExpression{}, inj{SortExpression{}, SortKItem{}} (Val:SortExpression{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortList{}, inj{SortList{}, SortKItem{}} (Val:SortList{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortCompoundStatement{}, inj{SortCompoundStatement{}, SortKItem{}} (Val:SortCompoundStatement{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortAndExpression{}, inj{SortAndExpression{}, SortKItem{}} (Val:SortAndExpression{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortAbstractDeclarator{}, inj{SortAbstractDeclarator{}, SortKItem{}} (Val:SortAbstractDeclarator{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortParameterDeclaration{}, inj{SortParameterDeclaration{}, SortKItem{}} (Val:SortParameterDeclaration{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortTCellOpt{}, inj{SortTCellOpt{}, SortKItem{}} (Val:SortTCellOpt{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortIterationStatement{}, inj{SortIterationStatement{}, SortKItem{}} (Val:SortIterationStatement{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortStructDeclaratorList{}, inj{SortStructDeclaratorList{}, SortKItem{}} (Val:SortStructDeclaratorList{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortTCellFragment{}, inj{SortTCellFragment{}, SortKItem{}} (Val:SortTCellFragment{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortString{}, inj{SortString{}, SortKItem{}} (Val:SortString{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortPrimaryExpression{}, inj{SortPrimaryExpression{}, SortKItem{}} (Val:SortPrimaryExpression{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortTypeName{}, inj{SortTypeName{}, SortKItem{}} (Val:SortTypeName{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortStructOrFunionSpecifier{}, inj{SortStructOrFunionSpecifier{}, SortKItem{}} (Val:SortStructOrFunionSpecifier{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortIOInt{}, inj{SortIOInt{}, SortKItem{}} (Val:SortIOInt{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortTCell{}, inj{SortTCell{}, SortKItem{}} (Val:SortTCell{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortIds{}, inj{SortIds{}, SortKItem{}} (Val:SortIds{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortAssignmentOperator{}, inj{SortAssignmentOperator{}, SortKItem{}} (Val:SortAssignmentOperator{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortStatement{}, inj{SortStatement{}, SortKItem{}} (Val:SortStatement{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortListExternalDeclaration{}, inj{SortListExternalDeclaration{}, SortKItem{}} (Val:SortListExternalDeclaration{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortDeclarator{}, inj{SortDeclarator{}, SortKItem{}} (Val:SortDeclarator{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortUnaryExpression{}, inj{SortUnaryExpression{}, SortKItem{}} (Val:SortUnaryExpression{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortEnumerator{}, inj{SortEnumerator{}, SortKItem{}} (Val:SortEnumerator{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortJumpStatement{}, inj{SortJumpStatement{}, SortKItem{}} (Val:SortJumpStatement{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortGeneratedCounterCellOpt{}, inj{SortGeneratedCounterCellOpt{}, SortKItem{}} (Val:SortGeneratedCounterCellOpt{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortListStatement{}, inj{SortListStatement{}, SortKItem{}} (Val:SortListStatement{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortEnumOfspecifier{}, inj{SortEnumOfspecifier{}, SortKItem{}} (Val:SortEnumOfspecifier{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortGeneratedCounterCell{}, inj{SortGeneratedCounterCell{}, SortKItem{}} (Val:SortGeneratedCounterCell{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortLabeledStatement{}, inj{SortLabeledStatement{}, SortKItem{}} (Val:SortLabeledStatement{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortId{}, inj{SortId{}, SortKItem{}} (Val:SortId{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortDeclarationSpecifier{}, inj{SortDeclarationSpecifier{}, SortKItem{}} (Val:SortDeclarationSpecifier{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortStream{}, inj{SortStream{}, SortKItem{}} (Val:SortStream{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortBool{}, inj{SortBool{}, SortKItem{}} (Val:SortBool{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortParameterTypeList{}, inj{SortParameterTypeList{}, SortKItem{}} (Val:SortParameterTypeList{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortLogicalOfandExpression{}, inj{SortLogicalOfandExpression{}, SortKItem{}} (Val:SortLogicalOfandExpression{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortKCell{}, inj{SortKCell{}, SortKItem{}} (Val:SortKCell{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortTypeQualifier{}, inj{SortTypeQualifier{}, SortKItem{}} (Val:SortTypeQualifier{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortIOFile{}, inj{SortIOFile{}, SortKItem{}} (Val:SortIOFile{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortListTypeQualifier{}, inj{SortListTypeQualifier{}, SortKItem{}} (Val:SortListTypeQualifier{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortExpressionStatement{}, inj{SortExpressionStatement{}, SortKItem{}} (Val:SortExpressionStatement{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortSelectionStatement{}, inj{SortSelectionStatement{}, SortKItem{}} (Val:SortSelectionStatement{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortOslCell{}, inj{SortOslCell{}, SortKItem{}} (Val:SortOslCell{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortMap{}, inj{SortMap{}, SortKItem{}} (Val:SortMap{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortDirectDeclarator{}, inj{SortDirectDeclarator{}, SortKItem{}} (Val:SortDirectDeclarator{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortConstant{}, inj{SortConstant{}, SortKItem{}} (Val:SortConstant{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortListStructDeclaration{}, inj{SortListStructDeclaration{}, SortKItem{}} (Val:SortListStructDeclaration{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortListDeclarationSpecifier{}, inj{SortListDeclarationSpecifier{}, SortKItem{}} (Val:SortListDeclarationSpecifier{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortStructDeclaration{}, inj{SortStructDeclaration{}, SortKItem{}} (Val:SortStructDeclaration{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortStructOrUnion{}, inj{SortStructOrUnion{}, SortKItem{}} (Val:SortStructOrUnion{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortTypeSpecifier{}, inj{SortTypeSpecifier{}, SortKItem{}} (Val:SortTypeSpecifier{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortListSpecifierQualifier{}, inj{SortListSpecifierQualifier{}, SortKItem{}} (Val:SortListSpecifierQualifier{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortInitializer{}, inj{SortInitializer{}, SortKItem{}} (Val:SortInitializer{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortInitializerList{}, inj{SortInitializerList{}, SortKItem{}} (Val:SortInitializerList{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortKCellOpt{}, inj{SortKCellOpt{}, SortKItem{}} (Val:SortKCellOpt{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortAssignmentExpression{}, inj{SortAssignmentExpression{}, SortKItem{}} (Val:SortAssignmentExpression{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortPointer{}, inj{SortPointer{}, SortKItem{}} (Val:SortPointer{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortParameterList{}, inj{SortParameterList{}, SortKItem{}} (Val:SortParameterList{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortConstantExpression{}, inj{SortConstantExpression{}, SortKItem{}} (Val:SortConstantExpression{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortDirectAbstractDeclarator{}, inj{SortDirectAbstractDeclarator{}, SortKItem{}} (Val:SortDirectAbstractDeclarator{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortMultiplicativeExpression{}, inj{SortMultiplicativeExpression{}, SortKItem{}} (Val:SortMultiplicativeExpression{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortInt{}, inj{SortInt{}, SortKItem{}} (Val:SortInt{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortFloat{}, inj{SortFloat{}, SortKItem{}} (Val:SortFloat{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortLogicalOforExpression{}, inj{SortLogicalOforExpression{}, SortKItem{}} (Val:SortLogicalOforExpression{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortEnumeratorList{}, inj{SortEnumeratorList{}, SortKItem{}} (Val:SortEnumeratorList{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortTranslationUnit{}, inj{SortTranslationUnit{}, SortKItem{}} (Val:SortTranslationUnit{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortDeclaration{}, inj{SortDeclaration{}, SortKItem{}} (Val:SortDeclaration{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortCastExpression{}, inj{SortCastExpression{}, SortKItem{}} (Val:SortCastExpression{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortGeneratedTopCell{}, inj{SortGeneratedTopCell{}, SortKItem{}} (Val:SortGeneratedTopCell{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortExclusiveOforExpression{}, inj{SortExclusiveOforExpression{}, SortKItem{}} (Val:SortExclusiveOforExpression{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortSet{}, inj{SortSet{}, SortKItem{}} (Val:SortSet{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortInitdeclarator{}, inj{SortInitdeclarator{}, SortKItem{}} (Val:SortInitdeclarator{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortAdditiveExpression{}, inj{SortAdditiveExpression{}, SortKItem{}} (Val:SortAdditiveExpression{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortInclusiveOforExpression{}, inj{SortInclusiveOforExpression{}, SortKItem{}} (Val:SortInclusiveOforExpression{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortListDeclaration{}, inj{SortListDeclaration{}, SortKItem{}} (Val:SortListDeclaration{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortConditionalExpression{}, inj{SortConditionalExpression{}, SortKItem{}} (Val:SortConditionalExpression{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortListAssignmentExpression{}, inj{SortListAssignmentExpression{}, SortKItem{}} (Val:SortListAssignmentExpression{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortIOString{}, inj{SortIOString{}, SortKItem{}} (Val:SortIOString{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortExternalDeclaration{}, inj{SortExternalDeclaration{}, SortKItem{}} (Val:SortExternalDeclaration{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortFunctionDefinition{}, inj{SortFunctionDefinition{}, SortKItem{}} (Val:SortFunctionDefinition{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortGeneratedTopCellFragment{}, inj{SortGeneratedTopCellFragment{}, SortKItem{}} (Val:SortGeneratedTopCellFragment{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortStructDeclarator{}, inj{SortStructDeclarator{}, SortKItem{}} (Val:SortStructDeclarator{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortIOError{}, inj{SortIOError{}, SortKItem{}} (Val:SortIOError{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortEnumerationConstant{}, inj{SortEnumerationConstant{}, SortKItem{}} (Val:SortEnumerationConstant{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortOslCellOpt{}, inj{SortOslCellOpt{}, SortKItem{}} (Val:SortOslCellOpt{})), \or{SortKItem{}} (\exists{SortKItem{}} (Val:SortShiftExpression{}, inj{SortShiftExpression{}, SortKItem{}} (Val:SortShiftExpression{})), \bottom{SortKItem{}}())))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) [constructor{}()] // no junk
  axiom{} \or{SortUnaryOperator{}} (Lbl'BangUnds'C-SYNTAX'Unds'UnaryOperator{}(), \or{SortUnaryOperator{}} (Lbl'And-Unds'C-SYNTAX'Unds'UnaryOperator{}(), \or{SortUnaryOperator{}} (Lbl'StarUnds'C-SYNTAX'Unds'UnaryOperator{}(), \or{SortUnaryOperator{}} (Lbl'PlusUnds'C-SYNTAX'Unds'UnaryOperator{}(), \or{SortUnaryOperator{}} (Lbl-'Unds'C-SYNTAX'Unds'UnaryOperator{}(), \or{SortUnaryOperator{}} (Lbl'TildUnds'C-SYNTAX'Unds'UnaryOperator{}(), \bottom{SortUnaryOperator{}}())))))) [constructor{}()] // no junk
  axiom{} \or{SortEqualityExpression{}} (\exists{SortEqualityExpression{}} (X0:SortEqualityExpression{}, \exists{SortEqualityExpression{}} (X1:SortRelationalExpression{}, Lbl'UndsBangEqlsUndsUnds'C-SYNTAX'Unds'EqualityExpression'Unds'EqualityExpression'Unds'RelationalExpression{}(X0:SortEqualityExpression{}, X1:SortRelationalExpression{}))), \or{SortEqualityExpression{}} (\exists{SortEqualityExpression{}} (X0:SortEqualityExpression{}, \exists{SortEqualityExpression{}} (X1:SortRelationalExpression{}, Lbl'UndsEqlsEqlsUndsUnds'C-SYNTAX'Unds'EqualityExpression'Unds'EqualityExpression'Unds'RelationalExpression{}(X0:SortEqualityExpression{}, X1:SortRelationalExpression{}))), \or{SortEqualityExpression{}} (\exists{SortEqualityExpression{}} (Val:SortPostfixExpression{}, inj{SortPostfixExpression{}, SortEqualityExpression{}} (Val:SortPostfixExpression{})), \or{SortEqualityExpression{}} (\exists{SortEqualityExpression{}} (Val:SortRelationalExpression{}, inj{SortRelationalExpression{}, SortEqualityExpression{}} (Val:SortRelationalExpression{})), \or{SortEqualityExpression{}} (\exists{SortEqualityExpression{}} (Val:SortString{}, inj{SortString{}, SortEqualityExpression{}} (Val:SortString{})), \or{SortEqualityExpression{}} (\exists{SortEqualityExpression{}} (Val:SortPrimaryExpression{}, inj{SortPrimaryExpression{}, SortEqualityExpression{}} (Val:SortPrimaryExpression{})), \or{SortEqualityExpression{}} (\exists{SortEqualityExpression{}} (Val:SortUnaryExpression{}, inj{SortUnaryExpression{}, SortEqualityExpression{}} (Val:SortUnaryExpression{})), \or{SortEqualityExpression{}} (\exists{SortEqualityExpression{}} (Val:SortId{}, inj{SortId{}, SortEqualityExpression{}} (Val:SortId{})), \or{SortEqualityExpression{}} (\exists{SortEqualityExpression{}} (Val:SortConstant{}, inj{SortConstant{}, SortEqualityExpression{}} (Val:SortConstant{})), \or{SortEqualityExpression{}} (\exists{SortEqualityExpression{}} (Val:SortMultiplicativeExpression{}, inj{SortMultiplicativeExpression{}, SortEqualityExpression{}} (Val:SortMultiplicativeExpression{})), \or{SortEqualityExpression{}} (\exists{SortEqualityExpression{}} (Val:SortInt{}, inj{SortInt{}, SortEqualityExpression{}} (Val:SortInt{})), \or{SortEqualityExpression{}} (\exists{SortEqualityExpression{}} (Val:SortFloat{}, inj{SortFloat{}, SortEqualityExpression{}} (Val:SortFloat{})), \or{SortEqualityExpression{}} (\exists{SortEqualityExpression{}} (Val:SortCastExpression{}, inj{SortCastExpression{}, SortEqualityExpression{}} (Val:SortCastExpression{})), \or{SortEqualityExpression{}} (\exists{SortEqualityExpression{}} (Val:SortAdditiveExpression{}, inj{SortAdditiveExpression{}, SortEqualityExpression{}} (Val:SortAdditiveExpression{})), \or{SortEqualityExpression{}} (\exists{SortEqualityExpression{}} (Val:SortEnumerationConstant{}, inj{SortEnumerationConstant{}, SortEqualityExpression{}} (Val:SortEnumerationConstant{})), \or{SortEqualityExpression{}} (\exists{SortEqualityExpression{}} (Val:SortShiftExpression{}, inj{SortShiftExpression{}, SortEqualityExpression{}} (Val:SortShiftExpression{})), \bottom{SortEqualityExpression{}}())))))))))))))))) [constructor{}()] // no junk
  axiom{} \or{SortStorageClassSpecifier{}} (Lblauto'Unds'C-SYNTAX'Unds'StorageClassSpecifier{}(), \or{SortStorageClassSpecifier{}} (Lblextern'Unds'C-SYNTAX'Unds'StorageClassSpecifier{}(), \or{SortStorageClassSpecifier{}} (Lblregister'Unds'C-SYNTAX'Unds'StorageClassSpecifier{}(), \or{SortStorageClassSpecifier{}} (Lblstatic'Unds'C-SYNTAX'Unds'StorageClassSpecifier{}(), \or{SortStorageClassSpecifier{}} (Lbltypedef'Unds'C-SYNTAX'Unds'StorageClassSpecifier{}(), \bottom{SortStorageClassSpecifier{}}()))))) [constructor{}()] // no junk
  axiom{} \or{SortSpecifierQualifier{}} (\exists{SortSpecifierQualifier{}} (Val:SortStructOrFunionSpecifier{}, inj{SortStructOrFunionSpecifier{}, SortSpecifierQualifier{}} (Val:SortStructOrFunionSpecifier{})), \or{SortSpecifierQualifier{}} (\exists{SortSpecifierQualifier{}} (Val:SortEnumOfspecifier{}, inj{SortEnumOfspecifier{}, SortSpecifierQualifier{}} (Val:SortEnumOfspecifier{})), \or{SortSpecifierQualifier{}} (\exists{SortSpecifierQualifier{}} (Val:SortTypeQualifier{}, inj{SortTypeQualifier{}, SortSpecifierQualifier{}} (Val:SortTypeQualifier{})), \or{SortSpecifierQualifier{}} (\exists{SortSpecifierQualifier{}} (Val:SortTypeSpecifier{}, inj{SortTypeSpecifier{}, SortSpecifierQualifier{}} (Val:SortTypeSpecifier{})), \bottom{SortSpecifierQualifier{}}())))) [constructor{}()] // no junk
  axiom{} \or{SortExpression{}} (\exists{SortExpression{}} (X0:SortExpression{}, \exists{SortExpression{}} (X1:SortAssignmentExpression{}, Lbl'UndsCommUndsUnds'C-SYNTAX'Unds'Expression'Unds'Expression'Unds'AssignmentExpression{}(X0:SortExpression{}, X1:SortAssignmentExpression{}))), \or{SortExpression{}} (\exists{SortExpression{}} (Val:SortPostfixExpression{}, inj{SortPostfixExpression{}, SortExpression{}} (Val:SortPostfixExpression{})), \or{SortExpression{}} (\exists{SortExpression{}} (Val:SortRelationalExpression{}, inj{SortRelationalExpression{}, SortExpression{}} (Val:SortRelationalExpression{})), \or{SortExpression{}} (\exists{SortExpression{}} (Val:SortEqualityExpression{}, inj{SortEqualityExpression{}, SortExpression{}} (Val:SortEqualityExpression{})), \or{SortExpression{}} (\exists{SortExpression{}} (Val:SortAndExpression{}, inj{SortAndExpression{}, SortExpression{}} (Val:SortAndExpression{})), \or{SortExpression{}} (\exists{SortExpression{}} (Val:SortString{}, inj{SortString{}, SortExpression{}} (Val:SortString{})), \or{SortExpression{}} (\exists{SortExpression{}} (Val:SortPrimaryExpression{}, inj{SortPrimaryExpression{}, SortExpression{}} (Val:SortPrimaryExpression{})), \or{SortExpression{}} (\exists{SortExpression{}} (Val:SortUnaryExpression{}, inj{SortUnaryExpression{}, SortExpression{}} (Val:SortUnaryExpression{})), \or{SortExpression{}} (\exists{SortExpression{}} (Val:SortId{}, inj{SortId{}, SortExpression{}} (Val:SortId{})), \or{SortExpression{}} (\exists{SortExpression{}} (Val:SortLogicalOfandExpression{}, inj{SortLogicalOfandExpression{}, SortExpression{}} (Val:SortLogicalOfandExpression{})), \or{SortExpression{}} (\exists{SortExpression{}} (Val:SortConstant{}, inj{SortConstant{}, SortExpression{}} (Val:SortConstant{})), \or{SortExpression{}} (\exists{SortExpression{}} (Val:SortAssignmentExpression{}, inj{SortAssignmentExpression{}, SortExpression{}} (Val:SortAssignmentExpression{})), \or{SortExpression{}} (\exists{SortExpression{}} (Val:SortMultiplicativeExpression{}, inj{SortMultiplicativeExpression{}, SortExpression{}} (Val:SortMultiplicativeExpression{})), \or{SortExpression{}} (\exists{SortExpression{}} (Val:SortInt{}, inj{SortInt{}, SortExpression{}} (Val:SortInt{})), \or{SortExpression{}} (\exists{SortExpression{}} (Val:SortFloat{}, inj{SortFloat{}, SortExpression{}} (Val:SortFloat{})), \or{SortExpression{}} (\exists{SortExpression{}} (Val:SortLogicalOforExpression{}, inj{SortLogicalOforExpression{}, SortExpression{}} (Val:SortLogicalOforExpression{})), \or{SortExpression{}} (\exists{SortExpression{}} (Val:SortCastExpression{}, inj{SortCastExpression{}, SortExpression{}} (Val:SortCastExpression{})), \or{SortExpression{}} (\exists{SortExpression{}} (Val:SortExclusiveOforExpression{}, inj{SortExclusiveOforExpression{}, SortExpression{}} (Val:SortExclusiveOforExpression{})), \or{SortExpression{}} (\exists{SortExpression{}} (Val:SortAdditiveExpression{}, inj{SortAdditiveExpression{}, SortExpression{}} (Val:SortAdditiveExpression{})), \or{SortExpression{}} (\exists{SortExpression{}} (Val:SortInclusiveOforExpression{}, inj{SortInclusiveOforExpression{}, SortExpression{}} (Val:SortInclusiveOforExpression{})), \or{SortExpression{}} (\exists{SortExpression{}} (Val:SortConditionalExpression{}, inj{SortConditionalExpression{}, SortExpression{}} (Val:SortConditionalExpression{})), \or{SortExpression{}} (\exists{SortExpression{}} (Val:SortEnumerationConstant{}, inj{SortEnumerationConstant{}, SortExpression{}} (Val:SortEnumerationConstant{})), \or{SortExpression{}} (\exists{SortExpression{}} (Val:SortShiftExpression{}, inj{SortShiftExpression{}, SortExpression{}} (Val:SortShiftExpression{})), \bottom{SortExpression{}}()))))))))))))))))))))))) [constructor{}()] // no junk
  axiom{} \bottom{SortList{}}() [constructor{}()] // no junk
  axiom{} \or{SortCompoundStatement{}} (\exists{SortCompoundStatement{}} (X0:SortListDeclaration{}, \exists{SortCompoundStatement{}} (X1:SortListStatement{}, Lbl'LBraUndsUndsRBraUnds'C-SYNTAX'Unds'CompoundStatement'Unds'ListDeclaration'Unds'ListStatement{}(X0:SortListDeclaration{}, X1:SortListStatement{}))), \bottom{SortCompoundStatement{}}()) [constructor{}()] // no junk
  axiom{} \or{SortAndExpression{}} (\exists{SortAndExpression{}} (X0:SortAndExpression{}, \exists{SortAndExpression{}} (X1:SortEqualityExpression{}, Lbl'UndsAnd-UndsUnds'C-SYNTAX'Unds'AndExpression'Unds'AndExpression'Unds'EqualityExpression{}(X0:SortAndExpression{}, X1:SortEqualityExpression{}))), \or{SortAndExpression{}} (\exists{SortAndExpression{}} (Val:SortPostfixExpression{}, inj{SortPostfixExpression{}, SortAndExpression{}} (Val:SortPostfixExpression{})), \or{SortAndExpression{}} (\exists{SortAndExpression{}} (Val:SortRelationalExpression{}, inj{SortRelationalExpression{}, SortAndExpression{}} (Val:SortRelationalExpression{})), \or{SortAndExpression{}} (\exists{SortAndExpression{}} (Val:SortEqualityExpression{}, inj{SortEqualityExpression{}, SortAndExpression{}} (Val:SortEqualityExpression{})), \or{SortAndExpression{}} (\exists{SortAndExpression{}} (Val:SortString{}, inj{SortString{}, SortAndExpression{}} (Val:SortString{})), \or{SortAndExpression{}} (\exists{SortAndExpression{}} (Val:SortPrimaryExpression{}, inj{SortPrimaryExpression{}, SortAndExpression{}} (Val:SortPrimaryExpression{})), \or{SortAndExpression{}} (\exists{SortAndExpression{}} (Val:SortUnaryExpression{}, inj{SortUnaryExpression{}, SortAndExpression{}} (Val:SortUnaryExpression{})), \or{SortAndExpression{}} (\exists{SortAndExpression{}} (Val:SortId{}, inj{SortId{}, SortAndExpression{}} (Val:SortId{})), \or{SortAndExpression{}} (\exists{SortAndExpression{}} (Val:SortConstant{}, inj{SortConstant{}, SortAndExpression{}} (Val:SortConstant{})), \or{SortAndExpression{}} (\exists{SortAndExpression{}} (Val:SortMultiplicativeExpression{}, inj{SortMultiplicativeExpression{}, SortAndExpression{}} (Val:SortMultiplicativeExpression{})), \or{SortAndExpression{}} (\exists{SortAndExpression{}} (Val:SortInt{}, inj{SortInt{}, SortAndExpression{}} (Val:SortInt{})), \or{SortAndExpression{}} (\exists{SortAndExpression{}} (Val:SortFloat{}, inj{SortFloat{}, SortAndExpression{}} (Val:SortFloat{})), \or{SortAndExpression{}} (\exists{SortAndExpression{}} (Val:SortCastExpression{}, inj{SortCastExpression{}, SortAndExpression{}} (Val:SortCastExpression{})), \or{SortAndExpression{}} (\exists{SortAndExpression{}} (Val:SortAdditiveExpression{}, inj{SortAdditiveExpression{}, SortAndExpression{}} (Val:SortAdditiveExpression{})), \or{SortAndExpression{}} (\exists{SortAndExpression{}} (Val:SortEnumerationConstant{}, inj{SortEnumerationConstant{}, SortAndExpression{}} (Val:SortEnumerationConstant{})), \or{SortAndExpression{}} (\exists{SortAndExpression{}} (Val:SortShiftExpression{}, inj{SortShiftExpression{}, SortAndExpression{}} (Val:SortShiftExpression{})), \bottom{SortAndExpression{}}())))))))))))))))) [constructor{}()] // no junk
  axiom{} \or{SortAbstractDeclarator{}} (\exists{SortAbstractDeclarator{}} (X0:SortPointer{}, \exists{SortAbstractDeclarator{}} (X1:SortDirectAbstractDeclarator{}, Lbl'UndsUndsUnds'C-SYNTAX'Unds'AbstractDeclarator'Unds'Pointer'Unds'DirectAbstractDeclarator{}(X0:SortPointer{}, X1:SortDirectAbstractDeclarator{}))), \or{SortAbstractDeclarator{}} (\exists{SortAbstractDeclarator{}} (Val:SortPointer{}, inj{SortPointer{}, SortAbstractDeclarator{}} (Val:SortPointer{})), \or{SortAbstractDeclarator{}} (\exists{SortAbstractDeclarator{}} (Val:SortDirectAbstractDeclarator{}, inj{SortDirectAbstractDeclarator{}, SortAbstractDeclarator{}} (Val:SortDirectAbstractDeclarator{})), \bottom{SortAbstractDeclarator{}}()))) [constructor{}()] // no junk
  axiom{} \or{SortParameterDeclaration{}} (\exists{SortParameterDeclaration{}} (X0:SortListDeclarationSpecifier{}, \exists{SortParameterDeclaration{}} (X1:SortAbstractDeclarator{}, Lbl'UndsUndsUnds'C-SYNTAX'Unds'ParameterDeclaration'Unds'ListDeclarationSpecifier'Unds'AbstractDeclarator{}(X0:SortListDeclarationSpecifier{}, X1:SortAbstractDeclarator{}))), \or{SortParameterDeclaration{}} (\exists{SortParameterDeclaration{}} (X0:SortListDeclarationSpecifier{}, \exists{SortParameterDeclaration{}} (X1:SortDeclarator{}, Lbl'UndsUndsUnds'C-SYNTAX'Unds'ParameterDeclaration'Unds'ListDeclarationSpecifier'Unds'Declarator{}(X0:SortListDeclarationSpecifier{}, X1:SortDeclarator{}))), \or{SortParameterDeclaration{}} (\exists{SortParameterDeclaration{}} (Val:SortListDeclarationSpecifier{}, inj{SortListDeclarationSpecifier{}, SortParameterDeclaration{}} (Val:SortListDeclarationSpecifier{})), \bottom{SortParameterDeclaration{}}()))) [constructor{}()] // no junk
  axiom{} \or{SortTCellOpt{}} (LblnoTCell{}(), \or{SortTCellOpt{}} (\exists{SortTCellOpt{}} (Val:SortTCell{}, inj{SortTCell{}, SortTCellOpt{}} (Val:SortTCell{})), \bottom{SortTCellOpt{}}())) [constructor{}()] // no junk
  axiom{} \or{SortIterationStatement{}} (\exists{SortIterationStatement{}} (X0:SortStatement{}, \exists{SortIterationStatement{}} (X1:SortExpression{}, Lbldo'Unds'while'LParUndsRParSClnUnds'C-SYNTAX'Unds'IterationStatement'Unds'Statement'Unds'Expression{}(X0:SortStatement{}, X1:SortExpression{}))), \or{SortIterationStatement{}} (\exists{SortIterationStatement{}} (X0:SortExpression{}, \exists{SortIterationStatement{}} (X1:SortExpression{}, \exists{SortIterationStatement{}} (X2:SortExpression{}, \exists{SortIterationStatement{}} (X3:SortStatement{}, Lblfor'LParUndsSClnUndsSClnUndsRParUndsUnds'C-SYNTAX'Unds'IterationStatement'Unds'Expression'Unds'Expression'Unds'Expression'Unds'Statement{}(X0:SortExpression{}, X1:SortExpression{}, X2:SortExpression{}, X3:SortStatement{}))))), \or{SortIterationStatement{}} (\exists{SortIterationStatement{}} (X0:SortExpression{}, \exists{SortIterationStatement{}} (X1:SortStatement{}, Lblwhile'LParUndsRParUndsUnds'C-SYNTAX'Unds'IterationStatement'Unds'Expression'Unds'Statement{}(X0:SortExpression{}, X1:SortStatement{}))), \bottom{SortIterationStatement{}}()))) [constructor{}()] // no junk
  axiom{} \or{SortStructDeclaratorList{}} (\exists{SortStructDeclaratorList{}} (X0:SortStructDeclaratorList{}, \exists{SortStructDeclaratorList{}} (X1:SortStructDeclarator{}, Lbl'UndsCommUndsUnds'C-SYNTAX'Unds'StructDeclaratorList'Unds'StructDeclaratorList'Unds'StructDeclarator{}(X0:SortStructDeclaratorList{}, X1:SortStructDeclarator{}))), \or{SortStructDeclaratorList{}} (\exists{SortStructDeclaratorList{}} (Val:SortDeclarator{}, inj{SortDeclarator{}, SortStructDeclaratorList{}} (Val:SortDeclarator{})), \or{SortStructDeclaratorList{}} (\exists{SortStructDeclaratorList{}} (Val:SortId{}, inj{SortId{}, SortStructDeclaratorList{}} (Val:SortId{})), \or{SortStructDeclaratorList{}} (\exists{SortStructDeclaratorList{}} (Val:SortDirectDeclarator{}, inj{SortDirectDeclarator{}, SortStructDeclaratorList{}} (Val:SortDirectDeclarator{})), \or{SortStructDeclaratorList{}} (\exists{SortStructDeclaratorList{}} (Val:SortStructDeclarator{}, inj{SortStructDeclarator{}, SortStructDeclaratorList{}} (Val:SortStructDeclarator{})), \bottom{SortStructDeclaratorList{}}()))))) [constructor{}()] // no junk
  axiom{} \or{SortTCellFragment{}} (\exists{SortTCellFragment{}} (X0:SortKCellOpt{}, \exists{SortTCellFragment{}} (X1:SortOslCellOpt{}, Lbl'-LT-'T'-GT-'-fragment{}(X0:SortKCellOpt{}, X1:SortOslCellOpt{}))), \bottom{SortTCellFragment{}}()) [constructor{}()] // no junk
  axiom{} \or{SortString{}} (\top{SortString{}}(), \bottom{SortString{}}()) [constructor{}()] // no junk (TODO: fix bug with \dv)
  axiom{} \or{SortPrimaryExpression{}} (\exists{SortPrimaryExpression{}} (X0:SortExpression{}, Lbl'LParUndsRParUnds'C-SYNTAX'Unds'PrimaryExpression'Unds'Expression{}(X0:SortExpression{})), \or{SortPrimaryExpression{}} (\exists{SortPrimaryExpression{}} (Val:SortString{}, inj{SortString{}, SortPrimaryExpression{}} (Val:SortString{})), \or{SortPrimaryExpression{}} (\exists{SortPrimaryExpression{}} (Val:SortId{}, inj{SortId{}, SortPrimaryExpression{}} (Val:SortId{})), \or{SortPrimaryExpression{}} (\exists{SortPrimaryExpression{}} (Val:SortConstant{}, inj{SortConstant{}, SortPrimaryExpression{}} (Val:SortConstant{})), \or{SortPrimaryExpression{}} (\exists{SortPrimaryExpression{}} (Val:SortInt{}, inj{SortInt{}, SortPrimaryExpression{}} (Val:SortInt{})), \or{SortPrimaryExpression{}} (\exists{SortPrimaryExpression{}} (Val:SortFloat{}, inj{SortFloat{}, SortPrimaryExpression{}} (Val:SortFloat{})), \or{SortPrimaryExpression{}} (\exists{SortPrimaryExpression{}} (Val:SortEnumerationConstant{}, inj{SortEnumerationConstant{}, SortPrimaryExpression{}} (Val:SortEnumerationConstant{})), \bottom{SortPrimaryExpression{}}()))))))) [constructor{}()] // no junk
  axiom{} \or{SortTypeName{}} (\exists{SortTypeName{}} (X0:SortListSpecifierQualifier{}, \exists{SortTypeName{}} (X1:SortAbstractDeclarator{}, Lbl'UndsUndsUnds'C-SYNTAX'Unds'TypeName'Unds'ListSpecifierQualifier'Unds'AbstractDeclarator{}(X0:SortListSpecifierQualifier{}, X1:SortAbstractDeclarator{}))), \or{SortTypeName{}} (\exists{SortTypeName{}} (Val:SortListSpecifierQualifier{}, inj{SortListSpecifierQualifier{}, SortTypeName{}} (Val:SortListSpecifierQualifier{})), \bottom{SortTypeName{}}())) [constructor{}()] // no junk
  axiom{} \or{SortKConfigVar{}} (\top{SortKConfigVar{}}(), \bottom{SortKConfigVar{}}()) [constructor{}()] // no junk (TODO: fix bug with \dv)
  axiom{} \or{SortStructOrFunionSpecifier{}} (\exists{SortStructOrFunionSpecifier{}} (X0:SortStructOrUnion{}, \exists{SortStructOrFunionSpecifier{}} (X1:SortId{}, Lbl'UndsUndsUnds'C-SYNTAX'Unds'StructOrFunionSpecifier'Unds'StructOrUnion'Unds'Id{}(X0:SortStructOrUnion{}, X1:SortId{}))), \or{SortStructOrFunionSpecifier{}} (\exists{SortStructOrFunionSpecifier{}} (X0:SortStructOrUnion{}, \exists{SortStructOrFunionSpecifier{}} (X1:SortId{}, \exists{SortStructOrFunionSpecifier{}} (X2:SortListStructDeclaration{}, Lbl'UndsUndsLBraUndsSClnRBraUnds'C-SYNTAX'Unds'StructOrFunionSpecifier'Unds'StructOrUnion'Unds'Id'Unds'ListStructDeclaration{}(X0:SortStructOrUnion{}, X1:SortId{}, X2:SortListStructDeclaration{})))), \or{SortStructOrFunionSpecifier{}} (\exists{SortStructOrFunionSpecifier{}} (X0:SortStructOrUnion{}, \exists{SortStructOrFunionSpecifier{}} (X1:SortId{}, Lbl'UndsUndsLBraRBraUnds'C-SYNTAX'Unds'StructOrFunionSpecifier'Unds'StructOrUnion'Unds'Id{}(X0:SortStructOrUnion{}, X1:SortId{}))), \or{SortStructOrFunionSpecifier{}} (\exists{SortStructOrFunionSpecifier{}} (X0:SortStructOrUnion{}, \exists{SortStructOrFunionSpecifier{}} (X1:SortListStructDeclaration{}, Lbl'UndsLBraUndsSClnRBraUnds'C-SYNTAX'Unds'StructOrFunionSpecifier'Unds'StructOrUnion'Unds'ListStructDeclaration{}(X0:SortStructOrUnion{}, X1:SortListStructDeclaration{}))), \bottom{SortStructOrFunionSpecifier{}}())))) [constructor{}()] // no junk
  axiom{} \or{SortIOInt{}} (\exists{SortIOInt{}} (Val:SortInt{}, inj{SortInt{}, SortIOInt{}} (Val:SortInt{})), \or{SortIOInt{}} (\exists{SortIOInt{}} (Val:SortIOError{}, inj{SortIOError{}, SortIOInt{}} (Val:SortIOError{})), \bottom{SortIOInt{}}())) [constructor{}()] // no junk
  axiom{} \or{SortTCell{}} (\exists{SortTCell{}} (X0:SortKCell{}, \exists{SortTCell{}} (X1:SortOslCell{}, Lbl'-LT-'T'-GT-'{}(X0:SortKCell{}, X1:SortOslCell{}))), \bottom{SortTCell{}}()) [constructor{}()] // no junk
  axiom{} \or{SortIds{}} (Lbl'Stop'List'LBraQuotUndsUndsUnds'C-SYNTAX'Unds'Ids'Unds'Id'Unds'Ids'QuotRBraUnds'Ids{}(), \or{SortIds{}} (\exists{SortIds{}} (X0:SortId{}, \exists{SortIds{}} (X1:SortIds{}, Lbl'UndsUndsUnds'C-SYNTAX'Unds'Ids'Unds'Id'Unds'Ids{}(X0:SortId{}, X1:SortIds{}))), \bottom{SortIds{}}())) [constructor{}()] // no junk
  axiom{} \or{SortAssignmentOperator{}} (Lbl'PercEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}(), \or{SortAssignmentOperator{}} (Lbl'And-EqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}(), \or{SortAssignmentOperator{}} (Lbl'StarEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}(), \or{SortAssignmentOperator{}} (Lbl'PlusEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}(), \or{SortAssignmentOperator{}} (Lbl'SlshEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}(), \or{SortAssignmentOperator{}} (Lbl'EqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}(), \or{SortAssignmentOperator{}} (LblOf'EqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}(), \or{SortAssignmentOperator{}} (Lbl'Xor-EqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}(), \or{SortAssignmentOperator{}} (Lbl'PipeEqlsUnds'C-SYNTAX'Unds'AssignmentOperator{}(), \bottom{SortAssignmentOperator{}}()))))))))) [constructor{}()] // no junk
  axiom{} \or{SortStatement{}} (\exists{SortStatement{}} (Val:SortCompoundStatement{}, inj{SortCompoundStatement{}, SortStatement{}} (Val:SortCompoundStatement{})), \or{SortStatement{}} (\exists{SortStatement{}} (Val:SortIterationStatement{}, inj{SortIterationStatement{}, SortStatement{}} (Val:SortIterationStatement{})), \or{SortStatement{}} (\exists{SortStatement{}} (Val:SortJumpStatement{}, inj{SortJumpStatement{}, SortStatement{}} (Val:SortJumpStatement{})), \or{SortStatement{}} (\exists{SortStatement{}} (Val:SortLabeledStatement{}, inj{SortLabeledStatement{}, SortStatement{}} (Val:SortLabeledStatement{})), \or{SortStatement{}} (\exists{SortStatement{}} (Val:SortExpressionStatement{}, inj{SortExpressionStatement{}, SortStatement{}} (Val:SortExpressionStatement{})), \or{SortStatement{}} (\exists{SortStatement{}} (Val:SortSelectionStatement{}, inj{SortSelectionStatement{}, SortStatement{}} (Val:SortSelectionStatement{})), \bottom{SortStatement{}}())))))) [constructor{}()] // no junk
  axiom{} \or{SortListExternalDeclaration{}} (Lbl'Stop'List'LBraQuotUndsUndsUnds'C-SYNTAX'Unds'ListExternalDeclaration'Unds'ExternalDeclaration'Unds'ListExternalDeclaration'QuotRBraUnds'ListExternalDeclaration{}(), \or{SortListExternalDeclaration{}} (\exists{SortListExternalDeclaration{}} (X0:SortExternalDeclaration{}, \exists{SortListExternalDeclaration{}} (X1:SortListExternalDeclaration{}, Lbl'UndsUndsUnds'C-SYNTAX'Unds'ListExternalDeclaration'Unds'ExternalDeclaration'Unds'ListExternalDeclaration{}(X0:SortExternalDeclaration{}, X1:SortListExternalDeclaration{}))), \bottom{SortListExternalDeclaration{}}())) [constructor{}()] // no junk
  axiom{} \or{SortDeclarator{}} (\exists{SortDeclarator{}} (X0:SortPointer{}, \exists{SortDeclarator{}} (X1:SortDirectDeclarator{}, Lbl'UndsUndsUnds'C-SYNTAX'Unds'Declarator'Unds'Pointer'Unds'DirectDeclarator{}(X0:SortPointer{}, X1:SortDirectDeclarator{}))), \or{SortDeclarator{}} (\exists{SortDeclarator{}} (Val:SortId{}, inj{SortId{}, SortDeclarator{}} (Val:SortId{})), \or{SortDeclarator{}} (\exists{SortDeclarator{}} (Val:SortDirectDeclarator{}, inj{SortDirectDeclarator{}, SortDeclarator{}} (Val:SortDirectDeclarator{})), \bottom{SortDeclarator{}}()))) [constructor{}()] // no junk
  axiom{} \or{SortUnaryExpression{}} (\exists{SortUnaryExpression{}} (X0:SortUnaryExpression{}, Lbl'PlusPlusUndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'UnaryExpression{}(X0:SortUnaryExpression{})), \or{SortUnaryExpression{}} (\exists{SortUnaryExpression{}} (X0:SortUnaryExpression{}, Lbl--'UndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'UnaryExpression{}(X0:SortUnaryExpression{})), \or{SortUnaryExpression{}} (\exists{SortUnaryExpression{}} (X0:SortUnaryOperator{}, \exists{SortUnaryExpression{}} (X1:SortCastExpression{}, Lbl'UndsUndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'UnaryOperator'Unds'CastExpression{}(X0:SortUnaryOperator{}, X1:SortCastExpression{}))), \or{SortUnaryExpression{}} (\exists{SortUnaryExpression{}} (X0:SortTypeName{}, Lblsizeof'UndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'TypeName{}(X0:SortTypeName{})), \or{SortUnaryExpression{}} (\exists{SortUnaryExpression{}} (X0:SortUnaryExpression{}, Lblsizeof'UndsUnds'C-SYNTAX'Unds'UnaryExpression'Unds'UnaryExpression{}(X0:SortUnaryExpression{})), \or{SortUnaryExpression{}} (\exists{SortUnaryExpression{}} (Val:SortPostfixExpression{}, inj{SortPostfixExpression{}, SortUnaryExpression{}} (Val:SortPostfixExpression{})), \or{SortUnaryExpression{}} (\exists{SortUnaryExpression{}} (Val:SortString{}, inj{SortString{}, SortUnaryExpression{}} (Val:SortString{})), \or{SortUnaryExpression{}} (\exists{SortUnaryExpression{}} (Val:SortPrimaryExpression{}, inj{SortPrimaryExpression{}, SortUnaryExpression{}} (Val:SortPrimaryExpression{})), \or{SortUnaryExpression{}} (\exists{SortUnaryExpression{}} (Val:SortId{}, inj{SortId{}, SortUnaryExpression{}} (Val:SortId{})), \or{SortUnaryExpression{}} (\exists{SortUnaryExpression{}} (Val:SortConstant{}, inj{SortConstant{}, SortUnaryExpression{}} (Val:SortConstant{})), \or{SortUnaryExpression{}} (\exists{SortUnaryExpression{}} (Val:SortInt{}, inj{SortInt{}, SortUnaryExpression{}} (Val:SortInt{})), \or{SortUnaryExpression{}} (\exists{SortUnaryExpression{}} (Val:SortFloat{}, inj{SortFloat{}, SortUnaryExpression{}} (Val:SortFloat{})), \or{SortUnaryExpression{}} (\exists{SortUnaryExpression{}} (Val:SortEnumerationConstant{}, inj{SortEnumerationConstant{}, SortUnaryExpression{}} (Val:SortEnumerationConstant{})), \bottom{SortUnaryExpression{}}()))))))))))))) [constructor{}()] // no junk
  axiom{} \or{SortEnumerator{}} (\exists{SortEnumerator{}} (X0:SortId{}, \exists{SortEnumerator{}} (X1:SortInt{}, Lbl'UndsEqlsUndsUnds'C-SYNTAX'Unds'Enumerator'Unds'Id'Unds'Int{}(X0:SortId{}, X1:SortInt{}))), \or{SortEnumerator{}} (\exists{SortEnumerator{}} (Val:SortId{}, inj{SortId{}, SortEnumerator{}} (Val:SortId{})), \bottom{SortEnumerator{}}())) [constructor{}()] // no junk
  axiom{} \or{SortJumpStatement{}} (Lblbreak'SClnUnds'C-SYNTAX'Unds'JumpStatement{}(), \or{SortJumpStatement{}} (Lblcontinue'SClnUnds'C-SYNTAX'Unds'JumpStatement{}(), \or{SortJumpStatement{}} (\exists{SortJumpStatement{}} (X0:SortId{}, Lblgoto'UndsSClnUnds'C-SYNTAX'Unds'JumpStatement'Unds'Id{}(X0:SortId{})), \or{SortJumpStatement{}} (\exists{SortJumpStatement{}} (X0:SortExpression{}, Lblreturn'UndsSClnUnds'C-SYNTAX'Unds'JumpStatement'Unds'Expression{}(X0:SortExpression{})), \bottom{SortJumpStatement{}}())))) [constructor{}()] // no junk
  axiom{} \or{SortGeneratedCounterCellOpt{}} (LblnoGeneratedCounterCell{}(), \or{SortGeneratedCounterCellOpt{}} (\exists{SortGeneratedCounterCellOpt{}} (Val:SortGeneratedCounterCell{}, inj{SortGeneratedCounterCell{}, SortGeneratedCounterCellOpt{}} (Val:SortGeneratedCounterCell{})), \bottom{SortGeneratedCounterCellOpt{}}())) [constructor{}()] // no junk
  axiom{} \or{SortListStatement{}} (Lbl'Stop'List'LBraQuotUndsUndsUnds'C-SYNTAX'Unds'ListStatement'Unds'Statement'Unds'ListStatement'QuotRBraUnds'ListStatement{}(), \or{SortListStatement{}} (\exists{SortListStatement{}} (X0:SortStatement{}, \exists{SortListStatement{}} (X1:SortListStatement{}, Lbl'UndsUndsUnds'C-SYNTAX'Unds'ListStatement'Unds'Statement'Unds'ListStatement{}(X0:SortStatement{}, X1:SortListStatement{}))), \bottom{SortListStatement{}}())) [constructor{}()] // no junk
  axiom{} \or{SortEnumOfspecifier{}} (\exists{SortEnumOfspecifier{}} (X0:SortId{}, Lblenum'UndsUnds'C-SYNTAX'Unds'EnumOfspecifier'Unds'Id{}(X0:SortId{})), \or{SortEnumOfspecifier{}} (\exists{SortEnumOfspecifier{}} (X0:SortId{}, \exists{SortEnumOfspecifier{}} (X1:SortEnumeratorList{}, Lblenum'UndsLBraUndsRBraUnds'C-SYNTAX'Unds'EnumOfspecifier'Unds'Id'Unds'EnumeratorList{}(X0:SortId{}, X1:SortEnumeratorList{}))), \or{SortEnumOfspecifier{}} (\exists{SortEnumOfspecifier{}} (X0:SortEnumeratorList{}, Lblenum'LBraUndsRBraUnds'C-SYNTAX'Unds'EnumOfspecifier'Unds'EnumeratorList{}(X0:SortEnumeratorList{})), \bottom{SortEnumOfspecifier{}}()))) [constructor{}()] // no junk
  axiom{} \or{SortGeneratedCounterCell{}} (\exists{SortGeneratedCounterCell{}} (X0:SortInt{}, Lbl'-LT-'generatedCounter'-GT-'{}(X0:SortInt{})), \bottom{SortGeneratedCounterCell{}}()) [constructor{}()] // no junk
  axiom{} \or{SortLabeledStatement{}} (\exists{SortLabeledStatement{}} (X0:SortId{}, \exists{SortLabeledStatement{}} (X1:SortStatement{}, Lbl'UndsColnUndsUnds'C-SYNTAX'Unds'LabeledStatement'Unds'Id'Unds'Statement{}(X0:SortId{}, X1:SortStatement{}))), \or{SortLabeledStatement{}} (\exists{SortLabeledStatement{}} (X0:SortConstantExpression{}, \exists{SortLabeledStatement{}} (X1:SortStatement{}, Lblcase'UndsColnUndsUnds'C-SYNTAX'Unds'LabeledStatement'Unds'ConstantExpression'Unds'Statement{}(X0:SortConstantExpression{}, X1:SortStatement{}))), \or{SortLabeledStatement{}} (\exists{SortLabeledStatement{}} (X0:SortStatement{}, Lbldefault'ColnUndsUnds'C-SYNTAX'Unds'LabeledStatement'Unds'Statement{}(X0:SortStatement{})), \bottom{SortLabeledStatement{}}()))) [constructor{}()] // no junk
  axiom{} \or{SortId{}} (\top{SortId{}}(), \bottom{SortId{}}()) [constructor{}()] // no junk (TODO: fix bug with \dv)
  axiom{} \or{SortDeclarationSpecifier{}} (\exists{SortDeclarationSpecifier{}} (Val:SortStorageClassSpecifier{}, inj{SortStorageClassSpecifier{}, SortDeclarationSpecifier{}} (Val:SortStorageClassSpecifier{})), \or{SortDeclarationSpecifier{}} (\exists{SortDeclarationSpecifier{}} (Val:SortStructOrFunionSpecifier{}, inj{SortStructOrFunionSpecifier{}, SortDeclarationSpecifier{}} (Val:SortStructOrFunionSpecifier{})), \or{SortDeclarationSpecifier{}} (\exists{SortDeclarationSpecifier{}} (Val:SortEnumOfspecifier{}, inj{SortEnumOfspecifier{}, SortDeclarationSpecifier{}} (Val:SortEnumOfspecifier{})), \or{SortDeclarationSpecifier{}} (\exists{SortDeclarationSpecifier{}} (Val:SortTypeQualifier{}, inj{SortTypeQualifier{}, SortDeclarationSpecifier{}} (Val:SortTypeQualifier{})), \or{SortDeclarationSpecifier{}} (\exists{SortDeclarationSpecifier{}} (Val:SortTypeSpecifier{}, inj{SortTypeSpecifier{}, SortDeclarationSpecifier{}} (Val:SortTypeSpecifier{})), \bottom{SortDeclarationSpecifier{}}()))))) [constructor{}()] // no junk
  axiom{} \or{SortStream{}} (\exists{SortStream{}} (X0:SortK{}, Lbl'Hash'buffer'LParUndsRParUnds'K-IO'Unds'Stream'Unds'K{}(X0:SortK{})), \bottom{SortStream{}}()) [constructor{}()] // no junk
  axiom{} \or{SortBool{}} (\top{SortBool{}}(), \bottom{SortBool{}}()) [constructor{}()] // no junk (TODO: fix bug with \dv)
  axiom{} \or{SortParameterTypeList{}} (\exists{SortParameterTypeList{}} (X0:SortParameterList{}, Lbl'UndsCommStopStopStopUnds'C-SYNTAX'Unds'ParameterTypeList'Unds'ParameterList{}(X0:SortParameterList{})), \or{SortParameterTypeList{}} (\exists{SortParameterTypeList{}} (Val:SortParameterDeclaration{}, inj{SortParameterDeclaration{}, SortParameterTypeList{}} (Val:SortParameterDeclaration{})), \or{SortParameterTypeList{}} (\exists{SortParameterTypeList{}} (Val:SortListDeclarationSpecifier{}, inj{SortListDeclarationSpecifier{}, SortParameterTypeList{}} (Val:SortListDeclarationSpecifier{})), \or{SortParameterTypeList{}} (\exists{SortParameterTypeList{}} (Val:SortParameterList{}, inj{SortParameterList{}, SortParameterTypeList{}} (Val:SortParameterList{})), \bottom{SortParameterTypeList{}}())))) [constructor{}()] // no junk
  axiom{} \or{SortLogicalOfandExpression{}} (\exists{SortLogicalOfandExpression{}} (X0:SortLogicalOfandExpression{}, \exists{SortLogicalOfandExpression{}} (X1:SortInclusiveOforExpression{}, Lbl'UndsAnd-And-UndsUnds'C-SYNTAX'Unds'LogicalOfandExpression'Unds'LogicalOfandExpression'Unds'InclusiveOforExpression{}(X0:SortLogicalOfandExpression{}, X1:SortInclusiveOforExpression{}))), \or{SortLogicalOfandExpression{}} (\exists{SortLogicalOfandExpression{}} (Val:SortPostfixExpression{}, inj{SortPostfixExpression{}, SortLogicalOfandExpression{}} (Val:SortPostfixExpression{})), \or{SortLogicalOfandExpression{}} (\exists{SortLogicalOfandExpression{}} (Val:SortRelationalExpression{}, inj{SortRelationalExpression{}, SortLogicalOfandExpression{}} (Val:SortRelationalExpression{})), \or{SortLogicalOfandExpression{}} (\exists{SortLogicalOfandExpression{}} (Val:SortEqualityExpression{}, inj{SortEqualityExpression{}, SortLogicalOfandExpression{}} (Val:SortEqualityExpression{})), \or{SortLogicalOfandExpression{}} (\exists{SortLogicalOfandExpression{}} (Val:SortAndExpression{}, inj{SortAndExpression{}, SortLogicalOfandExpression{}} (Val:SortAndExpression{})), \or{SortLogicalOfandExpression{}} (\exists{SortLogicalOfandExpression{}} (Val:SortString{}, inj{SortString{}, SortLogicalOfandExpression{}} (Val:SortString{})), \or{SortLogicalOfandExpression{}} (\exists{SortLogicalOfandExpression{}} (Val:SortPrimaryExpression{}, inj{SortPrimaryExpression{}, SortLogicalOfandExpression{}} (Val:SortPrimaryExpression{})), \or{SortLogicalOfandExpression{}} (\exists{SortLogicalOfandExpression{}} (Val:SortUnaryExpression{}, inj{SortUnaryExpression{}, SortLogicalOfandExpression{}} (Val:SortUnaryExpression{})), \or{SortLogicalOfandExpression{}} (\exists{SortLogicalOfandExpression{}} (Val:SortId{}, inj{SortId{}, SortLogicalOfandExpression{}} (Val:SortId{})), \or{SortLogicalOfandExpression{}} (\exists{SortLogicalOfandExpression{}} (Val:SortConstant{}, inj{SortConstant{}, SortLogicalOfandExpression{}} (Val:SortConstant{})), \or{SortLogicalOfandExpression{}} (\exists{SortLogicalOfandExpression{}} (Val:SortMultiplicativeExpression{}, inj{SortMultiplicativeExpression{}, SortLogicalOfandExpression{}} (Val:SortMultiplicativeExpression{})), \or{SortLogicalOfandExpression{}} (\exists{SortLogicalOfandExpression{}} (Val:SortInt{}, inj{SortInt{}, SortLogicalOfandExpression{}} (Val:SortInt{})), \or{SortLogicalOfandExpression{}} (\exists{SortLogicalOfandExpression{}} (Val:SortFloat{}, inj{SortFloat{}, SortLogicalOfandExpression{}} (Val:SortFloat{})), \or{SortLogicalOfandExpression{}} (\exists{SortLogicalOfandExpression{}} (Val:SortCastExpression{}, inj{SortCastExpression{}, SortLogicalOfandExpression{}} (Val:SortCastExpression{})), \or{SortLogicalOfandExpression{}} (\exists{SortLogicalOfandExpression{}} (Val:SortExclusiveOforExpression{}, inj{SortExclusiveOforExpression{}, SortLogicalOfandExpression{}} (Val:SortExclusiveOforExpression{})), \or{SortLogicalOfandExpression{}} (\exists{SortLogicalOfandExpression{}} (Val:SortAdditiveExpression{}, inj{SortAdditiveExpression{}, SortLogicalOfandExpression{}} (Val:SortAdditiveExpression{})), \or{SortLogicalOfandExpression{}} (\exists{SortLogicalOfandExpression{}} (Val:SortInclusiveOforExpression{}, inj{SortInclusiveOforExpression{}, SortLogicalOfandExpression{}} (Val:SortInclusiveOforExpression{})), \or{SortLogicalOfandExpression{}} (\exists{SortLogicalOfandExpression{}} (Val:SortEnumerationConstant{}, inj{SortEnumerationConstant{}, SortLogicalOfandExpression{}} (Val:SortEnumerationConstant{})), \or{SortLogicalOfandExpression{}} (\exists{SortLogicalOfandExpression{}} (Val:SortShiftExpression{}, inj{SortShiftExpression{}, SortLogicalOfandExpression{}} (Val:SortShiftExpression{})), \bottom{SortLogicalOfandExpression{}}()))))))))))))))))))) [constructor{}()] // no junk
  axiom{} \or{SortKCell{}} (\exists{SortKCell{}} (X0:SortK{}, Lbl'-LT-'k'-GT-'{}(X0:SortK{})), \bottom{SortKCell{}}()) [constructor{}()] // no junk
  axiom{} \bottom{SortK{}}() [constructor{}()] // no junk
  axiom{} \or{SortTypeQualifier{}} (Lblconst'Unds'C-SYNTAX'Unds'TypeQualifier{}(), \or{SortTypeQualifier{}} (Lblvolatile'Unds'C-SYNTAX'Unds'TypeQualifier{}(), \bottom{SortTypeQualifier{}}())) [constructor{}()] // no junk
  axiom{} \or{SortIOFile{}} (\exists{SortIOFile{}} (X0:SortString{}, \exists{SortIOFile{}} (X1:SortInt{}, Lbl'Hash'tempFile{}(X0:SortString{}, X1:SortInt{}))), \or{SortIOFile{}} (\exists{SortIOFile{}} (Val:SortIOError{}, inj{SortIOError{}, SortIOFile{}} (Val:SortIOError{})), \bottom{SortIOFile{}}())) [constructor{}()] // no junk
  axiom{} \or{SortListTypeQualifier{}} (Lbl'Stop'List'LBraQuotUndsUndsUnds'C-SYNTAX'Unds'ListTypeQualifier'Unds'TypeQualifier'Unds'ListTypeQualifier'QuotRBraUnds'ListTypeQualifier{}(), \or{SortListTypeQualifier{}} (\exists{SortListTypeQualifier{}} (X0:SortTypeQualifier{}, \exists{SortListTypeQualifier{}} (X1:SortListTypeQualifier{}, Lbl'UndsUndsUnds'C-SYNTAX'Unds'ListTypeQualifier'Unds'TypeQualifier'Unds'ListTypeQualifier{}(X0:SortTypeQualifier{}, X1:SortListTypeQualifier{}))), \bottom{SortListTypeQualifier{}}())) [constructor{}()] // no junk
  axiom{} \or{SortExpressionStatement{}} (Lbl'SClnUnds'C-SYNTAX'Unds'ExpressionStatement{}(), \or{SortExpressionStatement{}} (\exists{SortExpressionStatement{}} (X0:SortExpression{}, Lbl'UndsSClnUnds'C-SYNTAX'Unds'ExpressionStatement'Unds'Expression{}(X0:SortExpression{})), \bottom{SortExpressionStatement{}}())) [constructor{}()] // no junk
  axiom{} \or{SortSelectionStatement{}} (\exists{SortSelectionStatement{}} (X0:SortExpression{}, \exists{SortSelectionStatement{}} (X1:SortStatement{}, Lblif'LParUndsRParUndsUnds'C-SYNTAX'Unds'SelectionStatement'Unds'Expression'Unds'Statement{}(X0:SortExpression{}, X1:SortStatement{}))), \or{SortSelectionStatement{}} (\exists{SortSelectionStatement{}} (X0:SortExpression{}, \exists{SortSelectionStatement{}} (X1:SortStatement{}, \exists{SortSelectionStatement{}} (X2:SortStatement{}, Lblif'LParUndsRParUnds'else'UndsUnds'C-SYNTAX'Unds'SelectionStatement'Unds'Expression'Unds'Statement'Unds'Statement{}(X0:SortExpression{}, X1:SortStatement{}, X2:SortStatement{})))), \or{SortSelectionStatement{}} (\exists{SortSelectionStatement{}} (X0:SortExpression{}, \exists{SortSelectionStatement{}} (X1:SortStatement{}, Lblswitch'LParUndsRParUndsUnds'C-SYNTAX'Unds'SelectionStatement'Unds'Expression'Unds'Statement{}(X0:SortExpression{}, X1:SortStatement{}))), \bottom{SortSelectionStatement{}}()))) [constructor{}()] // no junk
  axiom{} \or{SortOslCell{}} (\exists{SortOslCell{}} (X0:SortK{}, Lbl'-LT-'osl'-GT-'{}(X0:SortK{})), \bottom{SortOslCell{}}()) [constructor{}()] // no junk
  axiom{} \bottom{SortMap{}}() [constructor{}()] // no junk
  axiom{} \or{SortDirectDeclarator{}} (\exists{SortDirectDeclarator{}} (X0:SortDeclarator{}, Lbl'LParUndsRParUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'Declarator{}(X0:SortDeclarator{})), \or{SortDirectDeclarator{}} (\exists{SortDirectDeclarator{}} (X0:SortDirectDeclarator{}, \exists{SortDirectDeclarator{}} (X1:SortIds{}, Lbl'UndsLParUndsRParUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'DirectDeclarator'Unds'Ids{}(X0:SortDirectDeclarator{}, X1:SortIds{}))), \or{SortDirectDeclarator{}} (\exists{SortDirectDeclarator{}} (X0:SortDirectDeclarator{}, \exists{SortDirectDeclarator{}} (X1:SortParameterTypeList{}, Lbl'UndsLParUndsRParUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'DirectDeclarator'Unds'ParameterTypeList{}(X0:SortDirectDeclarator{}, X1:SortParameterTypeList{}))), \or{SortDirectDeclarator{}} (\exists{SortDirectDeclarator{}} (X0:SortDirectDeclarator{}, Lbl'UndsLSqBRSqBUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'DirectDeclarator{}(X0:SortDirectDeclarator{})), \or{SortDirectDeclarator{}} (\exists{SortDirectDeclarator{}} (X0:SortDirectDeclarator{}, \exists{SortDirectDeclarator{}} (X1:SortConstantExpression{}, Lbl'UndsLSqBUndsRSqBUnds'C-SYNTAX'Unds'DirectDeclarator'Unds'DirectDeclarator'Unds'ConstantExpression{}(X0:SortDirectDeclarator{}, X1:SortConstantExpression{}))), \or{SortDirectDeclarator{}} (\exists{SortDirectDeclarator{}} (Val:SortId{}, inj{SortId{}, SortDirectDeclarator{}} (Val:SortId{})), \bottom{SortDirectDeclarator{}}())))))) [constructor{}()] // no junk
  axiom{} \or{SortConstant{}} (\exists{SortConstant{}} (Val:SortId{}, inj{SortId{}, SortConstant{}} (Val:SortId{})), \or{SortConstant{}} (\exists{SortConstant{}} (Val:SortInt{}, inj{SortInt{}, SortConstant{}} (Val:SortInt{})), \or{SortConstant{}} (\exists{SortConstant{}} (Val:SortFloat{}, inj{SortFloat{}, SortConstant{}} (Val:SortFloat{})), \or{SortConstant{}} (\exists{SortConstant{}} (Val:SortEnumerationConstant{}, inj{SortEnumerationConstant{}, SortConstant{}} (Val:SortEnumerationConstant{})), \bottom{SortConstant{}}())))) [constructor{}()] // no junk
  axiom{} \or{SortListStructDeclaration{}} (Lbl'Stop'List'LBraQuotUndsSClnUndsUnds'C-SYNTAX'Unds'ListStructDeclaration'Unds'StructDeclaration'Unds'ListStructDeclaration'QuotRBraUnds'ListStructDeclaration{}(), \or{SortListStructDeclaration{}} (\exists{SortListStructDeclaration{}} (X0:SortStructDeclaration{}, \exists{SortListStructDeclaration{}} (X1:SortListStructDeclaration{}, Lbl'UndsSClnUndsUnds'C-SYNTAX'Unds'ListStructDeclaration'Unds'StructDeclaration'Unds'ListStructDeclaration{}(X0:SortStructDeclaration{}, X1:SortListStructDeclaration{}))), \bottom{SortListStructDeclaration{}}())) [constructor{}()] // no junk
  axiom{} \or{SortListDeclarationSpecifier{}} (Lbl'Stop'List'LBraQuotUndsUndsUnds'C-SYNTAX'Unds'ListDeclarationSpecifier'Unds'DeclarationSpecifier'Unds'ListDeclarationSpecifier'QuotRBraUnds'ListDeclarationSpecifier{}(), \or{SortListDeclarationSpecifier{}} (\exists{SortListDeclarationSpecifier{}} (X0:SortDeclarationSpecifier{}, \exists{SortListDeclarationSpecifier{}} (X1:SortListDeclarationSpecifier{}, Lbl'UndsUndsUnds'C-SYNTAX'Unds'ListDeclarationSpecifier'Unds'DeclarationSpecifier'Unds'ListDeclarationSpecifier{}(X0:SortDeclarationSpecifier{}, X1:SortListDeclarationSpecifier{}))), \bottom{SortListDeclarationSpecifier{}}())) [constructor{}()] // no junk
  axiom{} \or{SortStructDeclaration{}} (\exists{SortStructDeclaration{}} (X0:SortListSpecifierQualifier{}, \exists{SortStructDeclaration{}} (X1:SortStructDeclaratorList{}, Lbl'UndsUndsUnds'C-SYNTAX'Unds'StructDeclaration'Unds'ListSpecifierQualifier'Unds'StructDeclaratorList{}(X0:SortListSpecifierQualifier{}, X1:SortStructDeclaratorList{}))), \bottom{SortStructDeclaration{}}()) [constructor{}()] // no junk
  axiom{} \or{SortStructOrUnion{}} (Lblstruct'Unds'C-SYNTAX'Unds'StructOrUnion{}(), \or{SortStructOrUnion{}} (Lblunion'Unds'C-SYNTAX'Unds'StructOrUnion{}(), \bottom{SortStructOrUnion{}}())) [constructor{}()] // no junk
  axiom{} \or{SortTypeSpecifier{}} (Lblchar'Unds'C-SYNTAX'Unds'TypeSpecifier{}(), \or{SortTypeSpecifier{}} (Lbldouble'Unds'C-SYNTAX'Unds'TypeSpecifier{}(), \or{SortTypeSpecifier{}} (Lblfloat'Unds'C-SYNTAX'Unds'TypeSpecifier{}(), \or{SortTypeSpecifier{}} (Lblint'Unds'C-SYNTAX'Unds'TypeSpecifier{}(), \or{SortTypeSpecifier{}} (Lbllong'Unds'C-SYNTAX'Unds'TypeSpecifier{}(), \or{SortTypeSpecifier{}} (Lblshort'Unds'C-SYNTAX'Unds'TypeSpecifier{}(), \or{SortTypeSpecifier{}} (Lblsigned'Unds'C-SYNTAX'Unds'TypeSpecifier{}(), \or{SortTypeSpecifier{}} (Lblunsigned'Unds'C-SYNTAX'Unds'TypeSpecifier{}(), \or{SortTypeSpecifier{}} (Lblvoid'Unds'C-SYNTAX'Unds'TypeSpecifier{}(), \or{SortTypeSpecifier{}} (\exists{SortTypeSpecifier{}} (Val:SortStructOrFunionSpecifier{}, inj{SortStructOrFunionSpecifier{}, SortTypeSpecifier{}} (Val:SortStructOrFunionSpecifier{})), \or{SortTypeSpecifier{}} (\exists{SortTypeSpecifier{}} (Val:SortEnumOfspecifier{}, inj{SortEnumOfspecifier{}, SortTypeSpecifier{}} (Val:SortEnumOfspecifier{})), \bottom{SortTypeSpecifier{}}()))))))))))) [constructor{}()] // no junk
  axiom{} \or{SortListSpecifierQualifier{}} (Lbl'Stop'List'LBraQuotUndsUndsUnds'C-SYNTAX'Unds'ListSpecifierQualifier'Unds'SpecifierQualifier'Unds'ListSpecifierQualifier'QuotRBraUnds'ListSpecifierQualifier{}(), \or{SortListSpecifierQualifier{}} (\exists{SortListSpecifierQualifier{}} (X0:SortSpecifierQualifier{}, \exists{SortListSpecifierQualifier{}} (X1:SortListSpecifierQualifier{}, Lbl'UndsUndsUnds'C-SYNTAX'Unds'ListSpecifierQualifier'Unds'SpecifierQualifier'Unds'ListSpecifierQualifier{}(X0:SortSpecifierQualifier{}, X1:SortListSpecifierQualifier{}))), \bottom{SortListSpecifierQualifier{}}())) [constructor{}()] // no junk
  axiom{} \or{SortInitializer{}} (\exists{SortInitializer{}} (X0:SortInitializerList{}, Lbl'LBraUndsCommRBraUnds'C-SYNTAX'Unds'Initializer'Unds'InitializerList{}(X0:SortInitializerList{})), \or{SortInitializer{}} (\exists{SortInitializer{}} (X0:SortInitializerList{}, Lbl'LBraUndsRBraUnds'C-SYNTAX'Unds'Initializer'Unds'InitializerList{}(X0:SortInitializerList{})), \or{SortInitializer{}} (\exists{SortInitializer{}} (Val:SortPostfixExpression{}, inj{SortPostfixExpression{}, SortInitializer{}} (Val:SortPostfixExpression{})), \or{SortInitializer{}} (\exists{SortInitializer{}} (Val:SortRelationalExpression{}, inj{SortRelationalExpression{}, SortInitializer{}} (Val:SortRelationalExpression{})), \or{SortInitializer{}} (\exists{SortInitializer{}} (Val:SortEqualityExpression{}, inj{SortEqualityExpression{}, SortInitializer{}} (Val:SortEqualityExpression{})), \or{SortInitializer{}} (\exists{SortInitializer{}} (Val:SortAndExpression{}, inj{SortAndExpression{}, SortInitializer{}} (Val:SortAndExpression{})), \or{SortInitializer{}} (\exists{SortInitializer{}} (Val:SortString{}, inj{SortString{}, SortInitializer{}} (Val:SortString{})), \or{SortInitializer{}} (\exists{SortInitializer{}} (Val:SortPrimaryExpression{}, inj{SortPrimaryExpression{}, SortInitializer{}} (Val:SortPrimaryExpression{})), \or{SortInitializer{}} (\exists{SortInitializer{}} (Val:SortUnaryExpression{}, inj{SortUnaryExpression{}, SortInitializer{}} (Val:SortUnaryExpression{})), \or{SortInitializer{}} (\exists{SortInitializer{}} (Val:SortId{}, inj{SortId{}, SortInitializer{}} (Val:SortId{})), \or{SortInitializer{}} (\exists{SortInitializer{}} (Val:SortLogicalOfandExpression{}, inj{SortLogicalOfandExpression{}, SortInitializer{}} (Val:SortLogicalOfandExpression{})), \or{SortInitializer{}} (\exists{SortInitializer{}} (Val:SortConstant{}, inj{SortConstant{}, SortInitializer{}} (Val:SortConstant{})), \or{SortInitializer{}} (\exists{SortInitializer{}} (Val:SortAssignmentExpression{}, inj{SortAssignmentExpression{}, SortInitializer{}} (Val:SortAssignmentExpression{})), \or{SortInitializer{}} (\exists{SortInitializer{}} (Val:SortMultiplicativeExpression{}, inj{SortMultiplicativeExpression{}, SortInitializer{}} (Val:SortMultiplicativeExpression{})), \or{SortInitializer{}} (\exists{SortInitializer{}} (Val:SortInt{}, inj{SortInt{}, SortInitializer{}} (Val:SortInt{})), \or{SortInitializer{}} (\exists{SortInitializer{}} (Val:SortFloat{}, inj{SortFloat{}, SortInitializer{}} (Val:SortFloat{})), \or{SortInitializer{}} (\exists{SortInitializer{}} (Val:SortLogicalOforExpression{}, inj{SortLogicalOforExpression{}, SortInitializer{}} (Val:SortLogicalOforExpression{})), \or{SortInitializer{}} (\exists{SortInitializer{}} (Val:SortCastExpression{}, inj{SortCastExpression{}, SortInitializer{}} (Val:SortCastExpression{})), \or{SortInitializer{}} (\exists{SortInitializer{}} (Val:SortExclusiveOforExpression{}, inj{SortExclusiveOforExpression{}, SortInitializer{}} (Val:SortExclusiveOforExpression{})), \or{SortInitializer{}} (\exists{SortInitializer{}} (Val:SortAdditiveExpression{}, inj{SortAdditiveExpression{}, SortInitializer{}} (Val:SortAdditiveExpression{})), \or{SortInitializer{}} (\exists{SortInitializer{}} (Val:SortInclusiveOforExpression{}, inj{SortInclusiveOforExpression{}, SortInitializer{}} (Val:SortInclusiveOforExpression{})), \or{SortInitializer{}} (\exists{SortInitializer{}} (Val:SortConditionalExpression{}, inj{SortConditionalExpression{}, SortInitializer{}} (Val:SortConditionalExpression{})), \or{SortInitializer{}} (\exists{SortInitializer{}} (Val:SortEnumerationConstant{}, inj{SortEnumerationConstant{}, SortInitializer{}} (Val:SortEnumerationConstant{})), \or{SortInitializer{}} (\exists{SortInitializer{}} (Val:SortShiftExpression{}, inj{SortShiftExpression{}, SortInitializer{}} (Val:SortShiftExpression{})), \bottom{SortInitializer{}}())))))))))))))))))))))))) [constructor{}()] // no junk
  axiom{} \or{SortInitializerList{}} (\exists{SortInitializerList{}} (X0:SortInitializerList{}, \exists{SortInitializerList{}} (X1:SortInitializer{}, Lbl'UndsCommUndsUnds'C-SYNTAX'Unds'InitializerList'Unds'InitializerList'Unds'Initializer{}(X0:SortInitializerList{}, X1:SortInitializer{}))), \or{SortInitializerList{}} (\exists{SortInitializerList{}} (Val:SortPostfixExpression{}, inj{SortPostfixExpression{}, SortInitializerList{}} (Val:SortPostfixExpression{})), \or{SortInitializerList{}} (\exists{SortInitializerList{}} (Val:SortRelationalExpression{}, inj{SortRelationalExpression{}, SortInitializerList{}} (Val:SortRelationalExpression{})), \or{SortInitializerList{}} (\exists{SortInitializerList{}} (Val:SortEqualityExpression{}, inj{SortEqualityExpression{}, SortInitializerList{}} (Val:SortEqualityExpression{})), \or{SortInitializerList{}} (\exists{SortInitializerList{}} (Val:SortAndExpression{}, inj{SortAndExpression{}, SortInitializerList{}} (Val:SortAndExpression{})), \or{SortInitializerList{}} (\exists{SortInitializerList{}} (Val:SortString{}, inj{SortString{}, SortInitializerList{}} (Val:SortString{})), \or{SortInitializerList{}} (\exists{SortInitializerList{}} (Val:SortPrimaryExpression{}, inj{SortPrimaryExpression{}, SortInitializerList{}} (Val:SortPrimaryExpression{})), \or{SortInitializerList{}} (\exists{SortInitializerList{}} (Val:SortUnaryExpression{}, inj{SortUnaryExpression{}, SortInitializerList{}} (Val:SortUnaryExpression{})), \or{SortInitializerList{}} (\exists{SortInitializerList{}} (Val:SortId{}, inj{SortId{}, SortInitializerList{}} (Val:SortId{})), \or{SortInitializerList{}} (\exists{SortInitializerList{}} (Val:SortLogicalOfandExpression{}, inj{SortLogicalOfandExpression{}, SortInitializerList{}} (Val:SortLogicalOfandExpression{})), \or{SortInitializerList{}} (\exists{SortInitializerList{}} (Val:SortConstant{}, inj{SortConstant{}, SortInitializerList{}} (Val:SortConstant{})), \or{SortInitializerList{}} (\exists{SortInitializerList{}} (Val:SortInitializer{}, inj{SortInitializer{}, SortInitializerList{}} (Val:SortInitializer{})), \or{SortInitializerList{}} (\exists{SortInitializerList{}} (Val:SortAssignmentExpression{}, inj{SortAssignmentExpression{}, SortInitializerList{}} (Val:SortAssignmentExpression{})), \or{SortInitializerList{}} (\exists{SortInitializerList{}} (Val:SortMultiplicativeExpression{}, inj{SortMultiplicativeExpression{}, SortInitializerList{}} (Val:SortMultiplicativeExpression{})), \or{SortInitializerList{}} (\exists{SortInitializerList{}} (Val:SortInt{}, inj{SortInt{}, SortInitializerList{}} (Val:SortInt{})), \or{SortInitializerList{}} (\exists{SortInitializerList{}} (Val:SortFloat{}, inj{SortFloat{}, SortInitializerList{}} (Val:SortFloat{})), \or{SortInitializerList{}} (\exists{SortInitializerList{}} (Val:SortLogicalOforExpression{}, inj{SortLogicalOforExpression{}, SortInitializerList{}} (Val:SortLogicalOforExpression{})), \or{SortInitializerList{}} (\exists{SortInitializerList{}} (Val:SortCastExpression{}, inj{SortCastExpression{}, SortInitializerList{}} (Val:SortCastExpression{})), \or{SortInitializerList{}} (\exists{SortInitializerList{}} (Val:SortExclusiveOforExpression{}, inj{SortExclusiveOforExpression{}, SortInitializerList{}} (Val:SortExclusiveOforExpression{})), \or{SortInitializerList{}} (\exists{SortInitializerList{}} (Val:SortAdditiveExpression{}, inj{SortAdditiveExpression{}, SortInitializerList{}} (Val:SortAdditiveExpression{})), \or{SortInitializerList{}} (\exists{SortInitializerList{}} (Val:SortInclusiveOforExpression{}, inj{SortInclusiveOforExpression{}, SortInitializerList{}} (Val:SortInclusiveOforExpression{})), \or{SortInitializerList{}} (\exists{SortInitializerList{}} (Val:SortConditionalExpression{}, inj{SortConditionalExpression{}, SortInitializerList{}} (Val:SortConditionalExpression{})), \or{SortInitializerList{}} (\exists{SortInitializerList{}} (Val:SortEnumerationConstant{}, inj{SortEnumerationConstant{}, SortInitializerList{}} (Val:SortEnumerationConstant{})), \or{SortInitializerList{}} (\exists{SortInitializerList{}} (Val:SortShiftExpression{}, inj{SortShiftExpression{}, SortInitializerList{}} (Val:SortShiftExpression{})), \bottom{SortInitializerList{}}())))))))))))))))))))))))) [constructor{}()] // no junk
  axiom{} \or{SortKCellOpt{}} (LblnoKCell{}(), \or{SortKCellOpt{}} (\exists{SortKCellOpt{}} (Val:SortKCell{}, inj{SortKCell{}, SortKCellOpt{}} (Val:SortKCell{})), \bottom{SortKCellOpt{}}())) [constructor{}()] // no junk
  axiom{} \or{SortAssignmentExpression{}} (\exists{SortAssignmentExpression{}} (X0:SortUnaryExpression{}, \exists{SortAssignmentExpression{}} (X1:SortAssignmentOperator{}, \exists{SortAssignmentExpression{}} (X2:SortAssignmentExpression{}, Lbl'UndsUndsUndsUnds'C-SYNTAX'Unds'AssignmentExpression'Unds'UnaryExpression'Unds'AssignmentOperator'Unds'AssignmentExpression{}(X0:SortUnaryExpression{}, X1:SortAssignmentOperator{}, X2:SortAssignmentExpression{})))), \or{SortAssignmentExpression{}} (\exists{SortAssignmentExpression{}} (Val:SortPostfixExpression{}, inj{SortPostfixExpression{}, SortAssignmentExpression{}} (Val:SortPostfixExpression{})), \or{SortAssignmentExpression{}} (\exists{SortAssignmentExpression{}} (Val:SortRelationalExpression{}, inj{SortRelationalExpression{}, SortAssignmentExpression{}} (Val:SortRelationalExpression{})), \or{SortAssignmentExpression{}} (\exists{SortAssignmentExpression{}} (Val:SortEqualityExpression{}, inj{SortEqualityExpression{}, SortAssignmentExpression{}} (Val:SortEqualityExpression{})), \or{SortAssignmentExpression{}} (\exists{SortAssignmentExpression{}} (Val:SortAndExpression{}, inj{SortAndExpression{}, SortAssignmentExpression{}} (Val:SortAndExpression{})), \or{SortAssignmentExpression{}} (\exists{SortAssignmentExpression{}} (Val:SortString{}, inj{SortString{}, SortAssignmentExpression{}} (Val:SortString{})), \or{SortAssignmentExpression{}} (\exists{SortAssignmentExpression{}} (Val:SortPrimaryExpression{}, inj{SortPrimaryExpression{}, SortAssignmentExpression{}} (Val:SortPrimaryExpression{})), \or{SortAssignmentExpression{}} (\exists{SortAssignmentExpression{}} (Val:SortUnaryExpression{}, inj{SortUnaryExpression{}, SortAssignmentExpression{}} (Val:SortUnaryExpression{})), \or{SortAssignmentExpression{}} (\exists{SortAssignmentExpression{}} (Val:SortId{}, inj{SortId{}, SortAssignmentExpression{}} (Val:SortId{})), \or{SortAssignmentExpression{}} (\exists{SortAssignmentExpression{}} (Val:SortLogicalOfandExpression{}, inj{SortLogicalOfandExpression{}, SortAssignmentExpression{}} (Val:SortLogicalOfandExpression{})), \or{SortAssignmentExpression{}} (\exists{SortAssignmentExpression{}} (Val:SortConstant{}, inj{SortConstant{}, SortAssignmentExpression{}} (Val:SortConstant{})), \or{SortAssignmentExpression{}} (\exists{SortAssignmentExpression{}} (Val:SortMultiplicativeExpression{}, inj{SortMultiplicativeExpression{}, SortAssignmentExpression{}} (Val:SortMultiplicativeExpression{})), \or{SortAssignmentExpression{}} (\exists{SortAssignmentExpression{}} (Val:SortInt{}, inj{SortInt{}, SortAssignmentExpression{}} (Val:SortInt{})), \or{SortAssignmentExpression{}} (\exists{SortAssignmentExpression{}} (Val:SortFloat{}, inj{SortFloat{}, SortAssignmentExpression{}} (Val:SortFloat{})), \or{SortAssignmentExpression{}} (\exists{SortAssignmentExpression{}} (Val:SortLogicalOforExpression{}, inj{SortLogicalOforExpression{}, SortAssignmentExpression{}} (Val:SortLogicalOforExpression{})), \or{SortAssignmentExpression{}} (\exists{SortAssignmentExpression{}} (Val:SortCastExpression{}, inj{SortCastExpression{}, SortAssignmentExpression{}} (Val:SortCastExpression{})), \or{SortAssignmentExpression{}} (\exists{SortAssignmentExpression{}} (Val:SortExclusiveOforExpression{}, inj{SortExclusiveOforExpression{}, SortAssignmentExpression{}} (Val:SortExclusiveOforExpression{})), \or{SortAssignmentExpression{}} (\exists{SortAssignmentExpression{}} (Val:SortAdditiveExpression{}, inj{SortAdditiveExpression{}, SortAssignmentExpression{}} (Val:SortAdditiveExpression{})), \or{SortAssignmentExpression{}} (\exists{SortAssignmentExpression{}} (Val:SortInclusiveOforExpression{}, inj{SortInclusiveOforExpression{}, SortAssignmentExpression{}} (Val:SortInclusiveOforExpression{})), \or{SortAssignmentExpression{}} (\exists{SortAssignmentExpression{}} (Val:SortConditionalExpression{}, inj{SortConditionalExpression{}, SortAssignmentExpression{}} (Val:SortConditionalExpression{})), \or{SortAssignmentExpression{}} (\exists{SortAssignmentExpression{}} (Val:SortEnumerationConstant{}, inj{SortEnumerationConstant{}, SortAssignmentExpression{}} (Val:SortEnumerationConstant{})), \or{SortAssignmentExpression{}} (\exists{SortAssignmentExpression{}} (Val:SortShiftExpression{}, inj{SortShiftExpression{}, SortAssignmentExpression{}} (Val:SortShiftExpression{})), \bottom{SortAssignmentExpression{}}())))))))))))))))))))))) [constructor{}()] // no junk
  axiom{} \or{SortPointer{}} (\exists{SortPointer{}} (X0:SortListTypeQualifier{}, Lbl'StarUndsUnds'C-SYNTAX'Unds'Pointer'Unds'ListTypeQualifier{}(X0:SortListTypeQualifier{})), \or{SortPointer{}} (\exists{SortPointer{}} (X0:SortListTypeQualifier{}, \exists{SortPointer{}} (X1:SortPointer{}, Lbl'StarUndsUndsUnds'C-SYNTAX'Unds'Pointer'Unds'ListTypeQualifier'Unds'Pointer{}(X0:SortListTypeQualifier{}, X1:SortPointer{}))), \bottom{SortPointer{}}())) [constructor{}()] // no junk
  axiom{} \or{SortParameterList{}} (\exists{SortParameterList{}} (X0:SortParameterList{}, \exists{SortParameterList{}} (X1:SortParameterDeclaration{}, Lbl'UndsCommUndsUnds'C-SYNTAX'Unds'ParameterList'Unds'ParameterList'Unds'ParameterDeclaration{}(X0:SortParameterList{}, X1:SortParameterDeclaration{}))), \or{SortParameterList{}} (\exists{SortParameterList{}} (Val:SortParameterDeclaration{}, inj{SortParameterDeclaration{}, SortParameterList{}} (Val:SortParameterDeclaration{})), \or{SortParameterList{}} (\exists{SortParameterList{}} (Val:SortListDeclarationSpecifier{}, inj{SortListDeclarationSpecifier{}, SortParameterList{}} (Val:SortListDeclarationSpecifier{})), \bottom{SortParameterList{}}()))) [constructor{}()] // no junk
  axiom{} \or{SortConstantExpression{}} (\exists{SortConstantExpression{}} (Val:SortPostfixExpression{}, inj{SortPostfixExpression{}, SortConstantExpression{}} (Val:SortPostfixExpression{})), \or{SortConstantExpression{}} (\exists{SortConstantExpression{}} (Val:SortRelationalExpression{}, inj{SortRelationalExpression{}, SortConstantExpression{}} (Val:SortRelationalExpression{})), \or{SortConstantExpression{}} (\exists{SortConstantExpression{}} (Val:SortEqualityExpression{}, inj{SortEqualityExpression{}, SortConstantExpression{}} (Val:SortEqualityExpression{})), \or{SortConstantExpression{}} (\exists{SortConstantExpression{}} (Val:SortAndExpression{}, inj{SortAndExpression{}, SortConstantExpression{}} (Val:SortAndExpression{})), \or{SortConstantExpression{}} (\exists{SortConstantExpression{}} (Val:SortString{}, inj{SortString{}, SortConstantExpression{}} (Val:SortString{})), \or{SortConstantExpression{}} (\exists{SortConstantExpression{}} (Val:SortPrimaryExpression{}, inj{SortPrimaryExpression{}, SortConstantExpression{}} (Val:SortPrimaryExpression{})), \or{SortConstantExpression{}} (\exists{SortConstantExpression{}} (Val:SortUnaryExpression{}, inj{SortUnaryExpression{}, SortConstantExpression{}} (Val:SortUnaryExpression{})), \or{SortConstantExpression{}} (\exists{SortConstantExpression{}} (Val:SortId{}, inj{SortId{}, SortConstantExpression{}} (Val:SortId{})), \or{SortConstantExpression{}} (\exists{SortConstantExpression{}} (Val:SortLogicalOfandExpression{}, inj{SortLogicalOfandExpression{}, SortConstantExpression{}} (Val:SortLogicalOfandExpression{})), \or{SortConstantExpression{}} (\exists{SortConstantExpression{}} (Val:SortConstant{}, inj{SortConstant{}, SortConstantExpression{}} (Val:SortConstant{})), \or{SortConstantExpression{}} (\exists{SortConstantExpression{}} (Val:SortMultiplicativeExpression{}, inj{SortMultiplicativeExpression{}, SortConstantExpression{}} (Val:SortMultiplicativeExpression{})), \or{SortConstantExpression{}} (\exists{SortConstantExpression{}} (Val:SortInt{}, inj{SortInt{}, SortConstantExpression{}} (Val:SortInt{})), \or{SortConstantExpression{}} (\exists{SortConstantExpression{}} (Val:SortFloat{}, inj{SortFloat{}, SortConstantExpression{}} (Val:SortFloat{})), \or{SortConstantExpression{}} (\exists{SortConstantExpression{}} (Val:SortLogicalOforExpression{}, inj{SortLogicalOforExpression{}, SortConstantExpression{}} (Val:SortLogicalOforExpression{})), \or{SortConstantExpression{}} (\exists{SortConstantExpression{}} (Val:SortCastExpression{}, inj{SortCastExpression{}, SortConstantExpression{}} (Val:SortCastExpression{})), \or{SortConstantExpression{}} (\exists{SortConstantExpression{}} (Val:SortExclusiveOforExpression{}, inj{SortExclusiveOforExpression{}, SortConstantExpression{}} (Val:SortExclusiveOforExpression{})), \or{SortConstantExpression{}} (\exists{SortConstantExpression{}} (Val:SortAdditiveExpression{}, inj{SortAdditiveExpression{}, SortConstantExpression{}} (Val:SortAdditiveExpression{})), \or{SortConstantExpression{}} (\exists{SortConstantExpression{}} (Val:SortInclusiveOforExpression{}, inj{SortInclusiveOforExpression{}, SortConstantExpression{}} (Val:SortInclusiveOforExpression{})), \or{SortConstantExpression{}} (\exists{SortConstantExpression{}} (Val:SortConditionalExpression{}, inj{SortConditionalExpression{}, SortConstantExpression{}} (Val:SortConditionalExpression{})), \or{SortConstantExpression{}} (\exists{SortConstantExpression{}} (Val:SortEnumerationConstant{}, inj{SortEnumerationConstant{}, SortConstantExpression{}} (Val:SortEnumerationConstant{})), \or{SortConstantExpression{}} (\exists{SortConstantExpression{}} (Val:SortShiftExpression{}, inj{SortShiftExpression{}, SortConstantExpression{}} (Val:SortShiftExpression{})), \bottom{SortConstantExpression{}}()))))))))))))))))))))) [constructor{}()] // no junk
  axiom{} \or{SortDirectAbstractDeclarator{}} (Lbl'LParRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator{}(), \or{SortDirectAbstractDeclarator{}} (\exists{SortDirectAbstractDeclarator{}} (X0:SortAbstractDeclarator{}, Lbl'LParUndsRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'AbstractDeclarator{}(X0:SortAbstractDeclarator{})), \or{SortDirectAbstractDeclarator{}} (\exists{SortDirectAbstractDeclarator{}} (X0:SortParameterTypeList{}, Lbl'LParUndsRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'ParameterTypeList{}(X0:SortParameterTypeList{})), \or{SortDirectAbstractDeclarator{}} (Lbl'LSqBRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator{}(), \or{SortDirectAbstractDeclarator{}} (\exists{SortDirectAbstractDeclarator{}} (X0:SortConstantExpression{}, Lbl'LSqBUndsRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'ConstantExpression{}(X0:SortConstantExpression{})), \or{SortDirectAbstractDeclarator{}} (\exists{SortDirectAbstractDeclarator{}} (X0:SortDirectAbstractDeclarator{}, Lbl'UndsLParRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator{}(X0:SortDirectAbstractDeclarator{})), \or{SortDirectAbstractDeclarator{}} (\exists{SortDirectAbstractDeclarator{}} (X0:SortDirectAbstractDeclarator{}, \exists{SortDirectAbstractDeclarator{}} (X1:SortParameterTypeList{}, Lbl'UndsLParUndsRParUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator'Unds'ParameterTypeList{}(X0:SortDirectAbstractDeclarator{}, X1:SortParameterTypeList{}))), \or{SortDirectAbstractDeclarator{}} (\exists{SortDirectAbstractDeclarator{}} (X0:SortDirectAbstractDeclarator{}, Lbl'UndsLSqBRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator{}(X0:SortDirectAbstractDeclarator{})), \or{SortDirectAbstractDeclarator{}} (\exists{SortDirectAbstractDeclarator{}} (X0:SortDirectAbstractDeclarator{}, \exists{SortDirectAbstractDeclarator{}} (X1:SortConstantExpression{}, Lbl'UndsLSqBUndsRSqBUnds'C-SYNTAX'Unds'DirectAbstractDeclarator'Unds'DirectAbstractDeclarator'Unds'ConstantExpression{}(X0:SortDirectAbstractDeclarator{}, X1:SortConstantExpression{}))), \bottom{SortDirectAbstractDeclarator{}}()))))))))) [constructor{}()] // no junk
  axiom{} \or{SortMultiplicativeExpression{}} (\exists{SortMultiplicativeExpression{}} (X0:SortMultiplicativeExpression{}, \exists{SortMultiplicativeExpression{}} (X1:SortCastExpression{}, Lbl'UndsPercUndsUnds'C-SYNTAX'Unds'MultiplicativeExpression'Unds'MultiplicativeExpression'Unds'CastExpression{}(X0:SortMultiplicativeExpression{}, X1:SortCastExpression{}))), \or{SortMultiplicativeExpression{}} (\exists{SortMultiplicativeExpression{}} (X0:SortMultiplicativeExpression{}, \exists{SortMultiplicativeExpression{}} (X1:SortCastExpression{}, Lbl'UndsStarUndsUnds'C-SYNTAX'Unds'MultiplicativeExpression'Unds'MultiplicativeExpression'Unds'CastExpression{}(X0:SortMultiplicativeExpression{}, X1:SortCastExpression{}))), \or{SortMultiplicativeExpression{}} (\exists{SortMultiplicativeExpression{}} (X0:SortMultiplicativeExpression{}, \exists{SortMultiplicativeExpression{}} (X1:SortCastExpression{}, Lbl'UndsSlshUndsUnds'C-SYNTAX'Unds'MultiplicativeExpression'Unds'MultiplicativeExpression'Unds'CastExpression{}(X0:SortMultiplicativeExpression{}, X1:SortCastExpression{}))), \or{SortMultiplicativeExpression{}} (\exists{SortMultiplicativeExpression{}} (Val:SortPostfixExpression{}, inj{SortPostfixExpression{}, SortMultiplicativeExpression{}} (Val:SortPostfixExpression{})), \or{SortMultiplicativeExpression{}} (\exists{SortMultiplicativeExpression{}} (Val:SortString{}, inj{SortString{}, SortMultiplicativeExpression{}} (Val:SortString{})), \or{SortMultiplicativeExpression{}} (\exists{SortMultiplicativeExpression{}} (Val:SortPrimaryExpression{}, inj{SortPrimaryExpression{}, SortMultiplicativeExpression{}} (Val:SortPrimaryExpression{})), \or{SortMultiplicativeExpression{}} (\exists{SortMultiplicativeExpression{}} (Val:SortUnaryExpression{}, inj{SortUnaryExpression{}, SortMultiplicativeExpression{}} (Val:SortUnaryExpression{})), \or{SortMultiplicativeExpression{}} (\exists{SortMultiplicativeExpression{}} (Val:SortId{}, inj{SortId{}, SortMultiplicativeExpression{}} (Val:SortId{})), \or{SortMultiplicativeExpression{}} (\exists{SortMultiplicativeExpression{}} (Val:SortConstant{}, inj{SortConstant{}, SortMultiplicativeExpression{}} (Val:SortConstant{})), \or{SortMultiplicativeExpression{}} (\exists{SortMultiplicativeExpression{}} (Val:SortInt{}, inj{SortInt{}, SortMultiplicativeExpression{}} (Val:SortInt{})), \or{SortMultiplicativeExpression{}} (\exists{SortMultiplicativeExpression{}} (Val:SortFloat{}, inj{SortFloat{}, SortMultiplicativeExpression{}} (Val:SortFloat{})), \or{SortMultiplicativeExpression{}} (\exists{SortMultiplicativeExpression{}} (Val:SortCastExpression{}, inj{SortCastExpression{}, SortMultiplicativeExpression{}} (Val:SortCastExpression{})), \or{SortMultiplicativeExpression{}} (\exists{SortMultiplicativeExpression{}} (Val:SortEnumerationConstant{}, inj{SortEnumerationConstant{}, SortMultiplicativeExpression{}} (Val:SortEnumerationConstant{})), \bottom{SortMultiplicativeExpression{}}()))))))))))))) [constructor{}()] // no junk
  axiom{} \or{SortInt{}} (\top{SortInt{}}(), \bottom{SortInt{}}()) [constructor{}()] // no junk (TODO: fix bug with \dv)
  axiom{} \or{SortFloat{}} (\top{SortFloat{}}(), \bottom{SortFloat{}}()) [constructor{}()] // no junk (TODO: fix bug with \dv)
  axiom{} \or{SortLogicalOforExpression{}} (\exists{SortLogicalOforExpression{}} (X0:SortLogicalOforExpression{}, \exists{SortLogicalOforExpression{}} (X1:SortLogicalOfandExpression{}, Lbl'UndsPipePipeUndsUnds'C-SYNTAX'Unds'LogicalOforExpression'Unds'LogicalOforExpression'Unds'LogicalOfandExpression{}(X0:SortLogicalOforExpression{}, X1:SortLogicalOfandExpression{}))), \or{SortLogicalOforExpression{}} (\exists{SortLogicalOforExpression{}} (Val:SortPostfixExpression{}, inj{SortPostfixExpression{}, SortLogicalOforExpression{}} (Val:SortPostfixExpression{})), \or{SortLogicalOforExpression{}} (\exists{SortLogicalOforExpression{}} (Val:SortRelationalExpression{}, inj{SortRelationalExpression{}, SortLogicalOforExpression{}} (Val:SortRelationalExpression{})), \or{SortLogicalOforExpression{}} (\exists{SortLogicalOforExpression{}} (Val:SortEqualityExpression{}, inj{SortEqualityExpression{}, SortLogicalOforExpression{}} (Val:SortEqualityExpression{})), \or{SortLogicalOforExpression{}} (\exists{SortLogicalOforExpression{}} (Val:SortAndExpression{}, inj{SortAndExpression{}, SortLogicalOforExpression{}} (Val:SortAndExpression{})), \or{SortLogicalOforExpression{}} (\exists{SortLogicalOforExpression{}} (Val:SortString{}, inj{SortString{}, SortLogicalOforExpression{}} (Val:SortString{})), \or{SortLogicalOforExpression{}} (\exists{SortLogicalOforExpression{}} (Val:SortPrimaryExpression{}, inj{SortPrimaryExpression{}, SortLogicalOforExpression{}} (Val:SortPrimaryExpression{})), \or{SortLogicalOforExpression{}} (\exists{SortLogicalOforExpression{}} (Val:SortUnaryExpression{}, inj{SortUnaryExpression{}, SortLogicalOforExpression{}} (Val:SortUnaryExpression{})), \or{SortLogicalOforExpression{}} (\exists{SortLogicalOforExpression{}} (Val:SortId{}, inj{SortId{}, SortLogicalOforExpression{}} (Val:SortId{})), \or{SortLogicalOforExpression{}} (\exists{SortLogicalOforExpression{}} (Val:SortLogicalOfandExpression{}, inj{SortLogicalOfandExpression{}, SortLogicalOforExpression{}} (Val:SortLogicalOfandExpression{})), \or{SortLogicalOforExpression{}} (\exists{SortLogicalOforExpression{}} (Val:SortConstant{}, inj{SortConstant{}, SortLogicalOforExpression{}} (Val:SortConstant{})), \or{SortLogicalOforExpression{}} (\exists{SortLogicalOforExpression{}} (Val:SortMultiplicativeExpression{}, inj{SortMultiplicativeExpression{}, SortLogicalOforExpression{}} (Val:SortMultiplicativeExpression{})), \or{SortLogicalOforExpression{}} (\exists{SortLogicalOforExpression{}} (Val:SortInt{}, inj{SortInt{}, SortLogicalOforExpression{}} (Val:SortInt{})), \or{SortLogicalOforExpression{}} (\exists{SortLogicalOforExpression{}} (Val:SortFloat{}, inj{SortFloat{}, SortLogicalOforExpression{}} (Val:SortFloat{})), \or{SortLogicalOforExpression{}} (\exists{SortLogicalOforExpression{}} (Val:SortCastExpression{}, inj{SortCastExpression{}, SortLogicalOforExpression{}} (Val:SortCastExpression{})), \or{SortLogicalOforExpression{}} (\exists{SortLogicalOforExpression{}} (Val:SortExclusiveOforExpression{}, inj{SortExclusiveOforExpression{}, SortLogicalOforExpression{}} (Val:SortExclusiveOforExpression{})), \or{SortLogicalOforExpression{}} (\exists{SortLogicalOforExpression{}} (Val:SortAdditiveExpression{}, inj{SortAdditiveExpression{}, SortLogicalOforExpression{}} (Val:SortAdditiveExpression{})), \or{SortLogicalOforExpression{}} (\exists{SortLogicalOforExpression{}} (Val:SortInclusiveOforExpression{}, inj{SortInclusiveOforExpression{}, SortLogicalOforExpression{}} (Val:SortInclusiveOforExpression{})), \or{SortLogicalOforExpression{}} (\exists{SortLogicalOforExpression{}} (Val:SortEnumerationConstant{}, inj{SortEnumerationConstant{}, SortLogicalOforExpression{}} (Val:SortEnumerationConstant{})), \or{SortLogicalOforExpression{}} (\exists{SortLogicalOforExpression{}} (Val:SortShiftExpression{}, inj{SortShiftExpression{}, SortLogicalOforExpression{}} (Val:SortShiftExpression{})), \bottom{SortLogicalOforExpression{}}())))))))))))))))))))) [constructor{}()] // no junk
  axiom{} \or{SortEnumeratorList{}} (Lbl'Stop'List'LBraQuotUndsCommUndsUnds'C-SYNTAX'Unds'EnumeratorList'Unds'Enumerator'Unds'EnumeratorList'QuotRBraUnds'EnumeratorList{}(), \or{SortEnumeratorList{}} (\exists{SortEnumeratorList{}} (X0:SortEnumerator{}, \exists{SortEnumeratorList{}} (X1:SortEnumeratorList{}, Lbl'UndsCommUndsUnds'C-SYNTAX'Unds'EnumeratorList'Unds'Enumerator'Unds'EnumeratorList{}(X0:SortEnumerator{}, X1:SortEnumeratorList{}))), \bottom{SortEnumeratorList{}}())) [constructor{}()] // no junk
  axiom{} \or{SortTranslationUnit{}} (\exists{SortTranslationUnit{}} (Val:SortListExternalDeclaration{}, inj{SortListExternalDeclaration{}, SortTranslationUnit{}} (Val:SortListExternalDeclaration{})), \bottom{SortTranslationUnit{}}()) [constructor{}()] // no junk
  axiom{} \or{SortDeclaration{}} (\exists{SortDeclaration{}} (X0:SortListDeclarationSpecifier{}, \exists{SortDeclaration{}} (X1:SortListInitDeclarator{}, Lbl'UndsUndsSClnUnds'C-SYNTAX'Unds'Declaration'Unds'ListDeclarationSpecifier'Unds'ListInitDeclarator{}(X0:SortListDeclarationSpecifier{}, X1:SortListInitDeclarator{}))), \bottom{SortDeclaration{}}()) [constructor{}()] // no junk
  axiom{} \or{SortCastExpression{}} (\exists{SortCastExpression{}} (X0:SortTypeName{}, \exists{SortCastExpression{}} (X1:SortCastExpression{}, Lbl'LParUndsRParUndsUnds'C-SYNTAX'Unds'CastExpression'Unds'TypeName'Unds'CastExpression{}(X0:SortTypeName{}, X1:SortCastExpression{}))), \or{SortCastExpression{}} (\exists{SortCastExpression{}} (Val:SortPostfixExpression{}, inj{SortPostfixExpression{}, SortCastExpression{}} (Val:SortPostfixExpression{})), \or{SortCastExpression{}} (\exists{SortCastExpression{}} (Val:SortString{}, inj{SortString{}, SortCastExpression{}} (Val:SortString{})), \or{SortCastExpression{}} (\exists{SortCastExpression{}} (Val:SortPrimaryExpression{}, inj{SortPrimaryExpression{}, SortCastExpression{}} (Val:SortPrimaryExpression{})), \or{SortCastExpression{}} (\exists{SortCastExpression{}} (Val:SortUnaryExpression{}, inj{SortUnaryExpression{}, SortCastExpression{}} (Val:SortUnaryExpression{})), \or{SortCastExpression{}} (\exists{SortCastExpression{}} (Val:SortId{}, inj{SortId{}, SortCastExpression{}} (Val:SortId{})), \or{SortCastExpression{}} (\exists{SortCastExpression{}} (Val:SortConstant{}, inj{SortConstant{}, SortCastExpression{}} (Val:SortConstant{})), \or{SortCastExpression{}} (\exists{SortCastExpression{}} (Val:SortInt{}, inj{SortInt{}, SortCastExpression{}} (Val:SortInt{})), \or{SortCastExpression{}} (\exists{SortCastExpression{}} (Val:SortFloat{}, inj{SortFloat{}, SortCastExpression{}} (Val:SortFloat{})), \or{SortCastExpression{}} (\exists{SortCastExpression{}} (Val:SortEnumerationConstant{}, inj{SortEnumerationConstant{}, SortCastExpression{}} (Val:SortEnumerationConstant{})), \bottom{SortCastExpression{}}())))))))))) [constructor{}()] // no junk
  axiom{} \or{SortGeneratedTopCell{}} (\exists{SortGeneratedTopCell{}} (X0:SortTCell{}, \exists{SortGeneratedTopCell{}} (X1:SortGeneratedCounterCell{}, Lbl'-LT-'generatedTop'-GT-'{}(X0:SortTCell{}, X1:SortGeneratedCounterCell{}))), \bottom{SortGeneratedTopCell{}}()) [constructor{}()] // no junk
  axiom{} \or{SortExclusiveOforExpression{}} (\exists{SortExclusiveOforExpression{}} (X0:SortExclusiveOforExpression{}, \exists{SortExclusiveOforExpression{}} (X1:SortAndExpression{}, Lbl'UndsXor-UndsUnds'C-SYNTAX'Unds'ExclusiveOforExpression'Unds'ExclusiveOforExpression'Unds'AndExpression{}(X0:SortExclusiveOforExpression{}, X1:SortAndExpression{}))), \or{SortExclusiveOforExpression{}} (\exists{SortExclusiveOforExpression{}} (Val:SortPostfixExpression{}, inj{SortPostfixExpression{}, SortExclusiveOforExpression{}} (Val:SortPostfixExpression{})), \or{SortExclusiveOforExpression{}} (\exists{SortExclusiveOforExpression{}} (Val:SortRelationalExpression{}, inj{SortRelationalExpression{}, SortExclusiveOforExpression{}} (Val:SortRelationalExpression{})), \or{SortExclusiveOforExpression{}} (\exists{SortExclusiveOforExpression{}} (Val:SortEqualityExpression{}, inj{SortEqualityExpression{}, SortExclusiveOforExpression{}} (Val:SortEqualityExpression{})), \or{SortExclusiveOforExpression{}} (\exists{SortExclusiveOforExpression{}} (Val:SortAndExpression{}, inj{SortAndExpression{}, SortExclusiveOforExpression{}} (Val:SortAndExpression{})), \or{SortExclusiveOforExpression{}} (\exists{SortExclusiveOforExpression{}} (Val:SortString{}, inj{SortString{}, SortExclusiveOforExpression{}} (Val:SortString{})), \or{SortExclusiveOforExpression{}} (\exists{SortExclusiveOforExpression{}} (Val:SortPrimaryExpression{}, inj{SortPrimaryExpression{}, SortExclusiveOforExpression{}} (Val:SortPrimaryExpression{})), \or{SortExclusiveOforExpression{}} (\exists{SortExclusiveOforExpression{}} (Val:SortUnaryExpression{}, inj{SortUnaryExpression{}, SortExclusiveOforExpression{}} (Val:SortUnaryExpression{})), \or{SortExclusiveOforExpression{}} (\exists{SortExclusiveOforExpression{}} (Val:SortId{}, inj{SortId{}, SortExclusiveOforExpression{}} (Val:SortId{})), \or{SortExclusiveOforExpression{}} (\exists{SortExclusiveOforExpression{}} (Val:SortConstant{}, inj{SortConstant{}, SortExclusiveOforExpression{}} (Val:SortConstant{})), \or{SortExclusiveOforExpression{}} (\exists{SortExclusiveOforExpression{}} (Val:SortMultiplicativeExpression{}, inj{SortMultiplicativeExpression{}, SortExclusiveOforExpression{}} (Val:SortMultiplicativeExpression{})), \or{SortExclusiveOforExpression{}} (\exists{SortExclusiveOforExpression{}} (Val:SortInt{}, inj{SortInt{}, SortExclusiveOforExpression{}} (Val:SortInt{})), \or{SortExclusiveOforExpression{}} (\exists{SortExclusiveOforExpression{}} (Val:SortFloat{}, inj{SortFloat{}, SortExclusiveOforExpression{}} (Val:SortFloat{})), \or{SortExclusiveOforExpression{}} (\exists{SortExclusiveOforExpression{}} (Val:SortCastExpression{}, inj{SortCastExpression{}, SortExclusiveOforExpression{}} (Val:SortCastExpression{})), \or{SortExclusiveOforExpression{}} (\exists{SortExclusiveOforExpression{}} (Val:SortAdditiveExpression{}, inj{SortAdditiveExpression{}, SortExclusiveOforExpression{}} (Val:SortAdditiveExpression{})), \or{SortExclusiveOforExpression{}} (\exists{SortExclusiveOforExpression{}} (Val:SortEnumerationConstant{}, inj{SortEnumerationConstant{}, SortExclusiveOforExpression{}} (Val:SortEnumerationConstant{})), \or{SortExclusiveOforExpression{}} (\exists{SortExclusiveOforExpression{}} (Val:SortShiftExpression{}, inj{SortShiftExpression{}, SortExclusiveOforExpression{}} (Val:SortShiftExpression{})), \bottom{SortExclusiveOforExpression{}}()))))))))))))))))) [constructor{}()] // no junk
  axiom{} \bottom{SortSet{}}() [constructor{}()] // no junk
  axiom{} \or{SortInitdeclarator{}} (\exists{SortInitdeclarator{}} (X0:SortDeclarator{}, \exists{SortInitdeclarator{}} (X1:SortInitializer{}, Lbl'UndsEqlsUndsUnds'C-SYNTAX'Unds'Initdeclarator'Unds'Declarator'Unds'Initializer{}(X0:SortDeclarator{}, X1:SortInitializer{}))), \or{SortInitdeclarator{}} (\exists{SortInitdeclarator{}} (Val:SortDeclarator{}, inj{SortDeclarator{}, SortInitdeclarator{}} (Val:SortDeclarator{})), \or{SortInitdeclarator{}} (\exists{SortInitdeclarator{}} (Val:SortId{}, inj{SortId{}, SortInitdeclarator{}} (Val:SortId{})), \or{SortInitdeclarator{}} (\exists{SortInitdeclarator{}} (Val:SortDirectDeclarator{}, inj{SortDirectDeclarator{}, SortInitdeclarator{}} (Val:SortDirectDeclarator{})), \bottom{SortInitdeclarator{}}())))) [constructor{}()] // no junk
  axiom{} \or{SortAdditiveExpression{}} (\exists{SortAdditiveExpression{}} (X0:SortAdditiveExpression{}, \exists{SortAdditiveExpression{}} (X1:SortMultiplicativeExpression{}, Lbl'UndsPlusUndsUnds'C-SYNTAX'Unds'AdditiveExpression'Unds'AdditiveExpression'Unds'MultiplicativeExpression{}(X0:SortAdditiveExpression{}, X1:SortMultiplicativeExpression{}))), \or{SortAdditiveExpression{}} (\exists{SortAdditiveExpression{}} (X0:SortAdditiveExpression{}, \exists{SortAdditiveExpression{}} (X1:SortMultiplicativeExpression{}, Lbl'Unds'-'UndsUnds'C-SYNTAX'Unds'AdditiveExpression'Unds'AdditiveExpression'Unds'MultiplicativeExpression{}(X0:SortAdditiveExpression{}, X1:SortMultiplicativeExpression{}))), \or{SortAdditiveExpression{}} (\exists{SortAdditiveExpression{}} (Val:SortPostfixExpression{}, inj{SortPostfixExpression{}, SortAdditiveExpression{}} (Val:SortPostfixExpression{})), \or{SortAdditiveExpression{}} (\exists{SortAdditiveExpression{}} (Val:SortString{}, inj{SortString{}, SortAdditiveExpression{}} (Val:SortString{})), \or{SortAdditiveExpression{}} (\exists{SortAdditiveExpression{}} (Val:SortPrimaryExpression{}, inj{SortPrimaryExpression{}, SortAdditiveExpression{}} (Val:SortPrimaryExpression{})), \or{SortAdditiveExpression{}} (\exists{SortAdditiveExpression{}} (Val:SortUnaryExpression{}, inj{SortUnaryExpression{}, SortAdditiveExpression{}} (Val:SortUnaryExpression{})), \or{SortAdditiveExpression{}} (\exists{SortAdditiveExpression{}} (Val:SortId{}, inj{SortId{}, SortAdditiveExpression{}} (Val:SortId{})), \or{SortAdditiveExpression{}} (\exists{SortAdditiveExpression{}} (Val:SortConstant{}, inj{SortConstant{}, SortAdditiveExpression{}} (Val:SortConstant{})), \or{SortAdditiveExpression{}} (\exists{SortAdditiveExpression{}} (Val:SortMultiplicativeExpression{}, inj{SortMultiplicativeExpression{}, SortAdditiveExpression{}} (Val:SortMultiplicativeExpression{})), \or{SortAdditiveExpression{}} (\exists{SortAdditiveExpression{}} (Val:SortInt{}, inj{SortInt{}, SortAdditiveExpression{}} (Val:SortInt{})), \or{SortAdditiveExpression{}} (\exists{SortAdditiveExpression{}} (Val:SortFloat{}, inj{SortFloat{}, SortAdditiveExpression{}} (Val:SortFloat{})), \or{SortAdditiveExpression{}} (\exists{SortAdditiveExpression{}} (Val:SortCastExpression{}, inj{SortCastExpression{}, SortAdditiveExpression{}} (Val:SortCastExpression{})), \or{SortAdditiveExpression{}} (\exists{SortAdditiveExpression{}} (Val:SortEnumerationConstant{}, inj{SortEnumerationConstant{}, SortAdditiveExpression{}} (Val:SortEnumerationConstant{})), \bottom{SortAdditiveExpression{}}()))))))))))))) [constructor{}()] // no junk
  axiom{} \or{SortInclusiveOforExpression{}} (\exists{SortInclusiveOforExpression{}} (X0:SortInclusiveOforExpression{}, \exists{SortInclusiveOforExpression{}} (X1:SortExclusiveOforExpression{}, Lbl'UndsPipeUndsUnds'C-SYNTAX'Unds'InclusiveOforExpression'Unds'InclusiveOforExpression'Unds'ExclusiveOforExpression{}(X0:SortInclusiveOforExpression{}, X1:SortExclusiveOforExpression{}))), \or{SortInclusiveOforExpression{}} (\exists{SortInclusiveOforExpression{}} (Val:SortPostfixExpression{}, inj{SortPostfixExpression{}, SortInclusiveOforExpression{}} (Val:SortPostfixExpression{})), \or{SortInclusiveOforExpression{}} (\exists{SortInclusiveOforExpression{}} (Val:SortRelationalExpression{}, inj{SortRelationalExpression{}, SortInclusiveOforExpression{}} (Val:SortRelationalExpression{})), \or{SortInclusiveOforExpression{}} (\exists{SortInclusiveOforExpression{}} (Val:SortEqualityExpression{}, inj{SortEqualityExpression{}, SortInclusiveOforExpression{}} (Val:SortEqualityExpression{})), \or{SortInclusiveOforExpression{}} (\exists{SortInclusiveOforExpression{}} (Val:SortAndExpression{}, inj{SortAndExpression{}, SortInclusiveOforExpression{}} (Val:SortAndExpression{})), \or{SortInclusiveOforExpression{}} (\exists{SortInclusiveOforExpression{}} (Val:SortString{}, inj{SortString{}, SortInclusiveOforExpression{}} (Val:SortString{})), \or{SortInclusiveOforExpression{}} (\exists{SortInclusiveOforExpression{}} (Val:SortPrimaryExpression{}, inj{SortPrimaryExpression{}, SortInclusiveOforExpression{}} (Val:SortPrimaryExpression{})), \or{SortInclusiveOforExpression{}} (\exists{SortInclusiveOforExpression{}} (Val:SortUnaryExpression{}, inj{SortUnaryExpression{}, SortInclusiveOforExpression{}} (Val:SortUnaryExpression{})), \or{SortInclusiveOforExpression{}} (\exists{SortInclusiveOforExpression{}} (Val:SortId{}, inj{SortId{}, SortInclusiveOforExpression{}} (Val:SortId{})), \or{SortInclusiveOforExpression{}} (\exists{SortInclusiveOforExpression{}} (Val:SortConstant{}, inj{SortConstant{}, SortInclusiveOforExpression{}} (Val:SortConstant{})), \or{SortInclusiveOforExpression{}} (\exists{SortInclusiveOforExpression{}} (Val:SortMultiplicativeExpression{}, inj{SortMultiplicativeExpression{}, SortInclusiveOforExpression{}} (Val:SortMultiplicativeExpression{})), \or{SortInclusiveOforExpression{}} (\exists{SortInclusiveOforExpression{}} (Val:SortInt{}, inj{SortInt{}, SortInclusiveOforExpression{}} (Val:SortInt{})), \or{SortInclusiveOforExpression{}} (\exists{SortInclusiveOforExpression{}} (Val:SortFloat{}, inj{SortFloat{}, SortInclusiveOforExpression{}} (Val:SortFloat{})), \or{SortInclusiveOforExpression{}} (\exists{SortInclusiveOforExpression{}} (Val:SortCastExpression{}, inj{SortCastExpression{}, SortInclusiveOforExpression{}} (Val:SortCastExpression{})), \or{SortInclusiveOforExpression{}} (\exists{SortInclusiveOforExpression{}} (Val:SortExclusiveOforExpression{}, inj{SortExclusiveOforExpression{}, SortInclusiveOforExpression{}} (Val:SortExclusiveOforExpression{})), \or{SortInclusiveOforExpression{}} (\exists{SortInclusiveOforExpression{}} (Val:SortAdditiveExpression{}, inj{SortAdditiveExpression{}, SortInclusiveOforExpression{}} (Val:SortAdditiveExpression{})), \or{SortInclusiveOforExpression{}} (\exists{SortInclusiveOforExpression{}} (Val:SortEnumerationConstant{}, inj{SortEnumerationConstant{}, SortInclusiveOforExpression{}} (Val:SortEnumerationConstant{})), \or{SortInclusiveOforExpression{}} (\exists{SortInclusiveOforExpression{}} (Val:SortShiftExpression{}, inj{SortShiftExpression{}, SortInclusiveOforExpression{}} (Val:SortShiftExpression{})), \bottom{SortInclusiveOforExpression{}}())))))))))))))))))) [constructor{}()] // no junk
  axiom{} \or{SortListDeclaration{}} (Lbl'Stop'List'LBraQuotUndsUndsUnds'C-SYNTAX'Unds'ListDeclaration'Unds'Declaration'Unds'ListDeclaration'QuotRBraUnds'ListDeclaration{}(), \or{SortListDeclaration{}} (\exists{SortListDeclaration{}} (X0:SortDeclaration{}, \exists{SortListDeclaration{}} (X1:SortListDeclaration{}, Lbl'UndsUndsUnds'C-SYNTAX'Unds'ListDeclaration'Unds'Declaration'Unds'ListDeclaration{}(X0:SortDeclaration{}, X1:SortListDeclaration{}))), \bottom{SortListDeclaration{}}())) [constructor{}()] // no junk
  axiom{} \or{SortConditionalExpression{}} (\exists{SortConditionalExpression{}} (X0:SortLogicalOforExpression{}, \exists{SortConditionalExpression{}} (X1:SortExpression{}, \exists{SortConditionalExpression{}} (X2:SortConditionalExpression{}, Lbl'UndsQuesUndsColnUndsUnds'C-SYNTAX'Unds'ConditionalExpression'Unds'LogicalOforExpression'Unds'Expression'Unds'ConditionalExpression{}(X0:SortLogicalOforExpression{}, X1:SortExpression{}, X2:SortConditionalExpression{})))), \or{SortConditionalExpression{}} (\exists{SortConditionalExpression{}} (Val:SortPostfixExpression{}, inj{SortPostfixExpression{}, SortConditionalExpression{}} (Val:SortPostfixExpression{})), \or{SortConditionalExpression{}} (\exists{SortConditionalExpression{}} (Val:SortRelationalExpression{}, inj{SortRelationalExpression{}, SortConditionalExpression{}} (Val:SortRelationalExpression{})), \or{SortConditionalExpression{}} (\exists{SortConditionalExpression{}} (Val:SortEqualityExpression{}, inj{SortEqualityExpression{}, SortConditionalExpression{}} (Val:SortEqualityExpression{})), \or{SortConditionalExpression{}} (\exists{SortConditionalExpression{}} (Val:SortAndExpression{}, inj{SortAndExpression{}, SortConditionalExpression{}} (Val:SortAndExpression{})), \or{SortConditionalExpression{}} (\exists{SortConditionalExpression{}} (Val:SortString{}, inj{SortString{}, SortConditionalExpression{}} (Val:SortString{})), \or{SortConditionalExpression{}} (\exists{SortConditionalExpression{}} (Val:SortPrimaryExpression{}, inj{SortPrimaryExpression{}, SortConditionalExpression{}} (Val:SortPrimaryExpression{})), \or{SortConditionalExpression{}} (\exists{SortConditionalExpression{}} (Val:SortUnaryExpression{}, inj{SortUnaryExpression{}, SortConditionalExpression{}} (Val:SortUnaryExpression{})), \or{SortConditionalExpression{}} (\exists{SortConditionalExpression{}} (Val:SortId{}, inj{SortId{}, SortConditionalExpression{}} (Val:SortId{})), \or{SortConditionalExpression{}} (\exists{SortConditionalExpression{}} (Val:SortLogicalOfandExpression{}, inj{SortLogicalOfandExpression{}, SortConditionalExpression{}} (Val:SortLogicalOfandExpression{})), \or{SortConditionalExpression{}} (\exists{SortConditionalExpression{}} (Val:SortConstant{}, inj{SortConstant{}, SortConditionalExpression{}} (Val:SortConstant{})), \or{SortConditionalExpression{}} (\exists{SortConditionalExpression{}} (Val:SortMultiplicativeExpression{}, inj{SortMultiplicativeExpression{}, SortConditionalExpression{}} (Val:SortMultiplicativeExpression{})), \or{SortConditionalExpression{}} (\exists{SortConditionalExpression{}} (Val:SortInt{}, inj{SortInt{}, SortConditionalExpression{}} (Val:SortInt{})), \or{SortConditionalExpression{}} (\exists{SortConditionalExpression{}} (Val:SortFloat{}, inj{SortFloat{}, SortConditionalExpression{}} (Val:SortFloat{})), \or{SortConditionalExpression{}} (\exists{SortConditionalExpression{}} (Val:SortLogicalOforExpression{}, inj{SortLogicalOforExpression{}, SortConditionalExpression{}} (Val:SortLogicalOforExpression{})), \or{SortConditionalExpression{}} (\exists{SortConditionalExpression{}} (Val:SortCastExpression{}, inj{SortCastExpression{}, SortConditionalExpression{}} (Val:SortCastExpression{})), \or{SortConditionalExpression{}} (\exists{SortConditionalExpression{}} (Val:SortExclusiveOforExpression{}, inj{SortExclusiveOforExpression{}, SortConditionalExpression{}} (Val:SortExclusiveOforExpression{})), \or{SortConditionalExpression{}} (\exists{SortConditionalExpression{}} (Val:SortAdditiveExpression{}, inj{SortAdditiveExpression{}, SortConditionalExpression{}} (Val:SortAdditiveExpression{})), \or{SortConditionalExpression{}} (\exists{SortConditionalExpression{}} (Val:SortInclusiveOforExpression{}, inj{SortInclusiveOforExpression{}, SortConditionalExpression{}} (Val:SortInclusiveOforExpression{})), \or{SortConditionalExpression{}} (\exists{SortConditionalExpression{}} (Val:SortEnumerationConstant{}, inj{SortEnumerationConstant{}, SortConditionalExpression{}} (Val:SortEnumerationConstant{})), \or{SortConditionalExpression{}} (\exists{SortConditionalExpression{}} (Val:SortShiftExpression{}, inj{SortShiftExpression{}, SortConditionalExpression{}} (Val:SortShiftExpression{})), \bottom{SortConditionalExpression{}}()))))))))))))))))))))) [constructor{}()] // no junk
  axiom{} \or{SortListAssignmentExpression{}} (Lbl'Stop'List'LBraQuotUndsCommUndsUnds'C-SYNTAX'Unds'ListAssignmentExpression'Unds'AssignmentExpression'Unds'ListAssignmentExpression'QuotRBraUnds'ListAssignmentExpression{}(), \or{SortListAssignmentExpression{}} (\exists{SortListAssignmentExpression{}} (X0:SortAssignmentExpression{}, \exists{SortListAssignmentExpression{}} (X1:SortListAssignmentExpression{}, Lbl'UndsCommUndsUnds'C-SYNTAX'Unds'ListAssignmentExpression'Unds'AssignmentExpression'Unds'ListAssignmentExpression{}(X0:SortAssignmentExpression{}, X1:SortListAssignmentExpression{}))), \bottom{SortListAssignmentExpression{}}())) [constructor{}()] // no junk
  axiom{} \or{SortIOString{}} (\exists{SortIOString{}} (Val:SortString{}, inj{SortString{}, SortIOString{}} (Val:SortString{})), \or{SortIOString{}} (\exists{SortIOString{}} (Val:SortIOError{}, inj{SortIOError{}, SortIOString{}} (Val:SortIOError{})), \bottom{SortIOString{}}())) [constructor{}()] // no junk
  axiom{} \or{SortExternalDeclaration{}} (\exists{SortExternalDeclaration{}} (Val:SortDeclaration{}, inj{SortDeclaration{}, SortExternalDeclaration{}} (Val:SortDeclaration{})), \or{SortExternalDeclaration{}} (\exists{SortExternalDeclaration{}} (Val:SortFunctionDefinition{}, inj{SortFunctionDefinition{}, SortExternalDeclaration{}} (Val:SortFunctionDefinition{})), \bottom{SortExternalDeclaration{}}())) [constructor{}()] // no junk
  axiom{} \or{SortFunctionDefinition{}} (\exists{SortFunctionDefinition{}} (X0:SortListDeclarationSpecifier{}, \exists{SortFunctionDefinition{}} (X1:SortDeclarator{}, \exists{SortFunctionDefinition{}} (X2:SortListDeclaration{}, \exists{SortFunctionDefinition{}} (X3:SortCompoundStatement{}, Lbl'UndsUndsUndsUndsUnds'C-SYNTAX'Unds'FunctionDefinition'Unds'ListDeclarationSpecifier'Unds'Declarator'Unds'ListDeclaration'Unds'CompoundStatement{}(X0:SortListDeclarationSpecifier{}, X1:SortDeclarator{}, X2:SortListDeclaration{}, X3:SortCompoundStatement{}))))), \bottom{SortFunctionDefinition{}}()) [constructor{}()] // no junk
  axiom{} \or{SortGeneratedTopCellFragment{}} (\exists{SortGeneratedTopCellFragment{}} (X0:SortTCellOpt{}, \exists{SortGeneratedTopCellFragment{}} (X1:SortGeneratedCounterCellOpt{}, Lbl'-LT-'generatedTop'-GT-'-fragment{}(X0:SortTCellOpt{}, X1:SortGeneratedCounterCellOpt{}))), \bottom{SortGeneratedTopCellFragment{}}()) [constructor{}()] // no junk
  axiom{} \or{SortStructDeclarator{}} (\exists{SortStructDeclarator{}} (X0:SortConstantExpression{}, Lbl'ColnUndsUnds'C-SYNTAX'Unds'StructDeclarator'Unds'ConstantExpression{}(X0:SortConstantExpression{})), \or{SortStructDeclarator{}} (\exists{SortStructDeclarator{}} (X0:SortDeclarator{}, \exists{SortStructDeclarator{}} (X1:SortConstantExpression{}, Lbl'UndsColnUndsUnds'C-SYNTAX'Unds'StructDeclarator'Unds'Declarator'Unds'ConstantExpression{}(X0:SortDeclarator{}, X1:SortConstantExpression{}))), \or{SortStructDeclarator{}} (\exists{SortStructDeclarator{}} (Val:SortDeclarator{}, inj{SortDeclarator{}, SortStructDeclarator{}} (Val:SortDeclarator{})), \or{SortStructDeclarator{}} (\exists{SortStructDeclarator{}} (Val:SortId{}, inj{SortId{}, SortStructDeclarator{}} (Val:SortId{})), \or{SortStructDeclarator{}} (\exists{SortStructDeclarator{}} (Val:SortDirectDeclarator{}, inj{SortDirectDeclarator{}, SortStructDeclarator{}} (Val:SortDirectDeclarator{})), \bottom{SortStructDeclarator{}}()))))) [constructor{}()] // no junk
  axiom{} \or{SortIOError{}} (Lbl'Hash'E2BIG{}(), \or{SortIOError{}} (Lbl'Hash'EACCES{}(), \or{SortIOError{}} (Lbl'Hash'EADDRINUSE{}(), \or{SortIOError{}} (Lbl'Hash'EADDRNOTAVAIL{}(), \or{SortIOError{}} (Lbl'Hash'EAFNOSUPPORT{}(), \or{SortIOError{}} (Lbl'Hash'EAGAIN{}(), \or{SortIOError{}} (Lbl'Hash'EALREADY{}(), \or{SortIOError{}} (Lbl'Hash'EBADF{}(), \or{SortIOError{}} (Lbl'Hash'EBUSY{}(), \or{SortIOError{}} (Lbl'Hash'ECHILD{}(), \or{SortIOError{}} (Lbl'Hash'ECONNABORTED{}(), \or{SortIOError{}} (Lbl'Hash'ECONNREFUSED{}(), \or{SortIOError{}} (Lbl'Hash'ECONNRESET{}(), \or{SortIOError{}} (Lbl'Hash'EDEADLK{}(), \or{SortIOError{}} (Lbl'Hash'EDESTADDRREQ{}(), \or{SortIOError{}} (Lbl'Hash'EDOM{}(), \or{SortIOError{}} (Lbl'Hash'EEXIST{}(), \or{SortIOError{}} (Lbl'Hash'EFAULT{}(), \or{SortIOError{}} (Lbl'Hash'EFBIG{}(), \or{SortIOError{}} (Lbl'Hash'EHOSTDOWN{}(), \or{SortIOError{}} (Lbl'Hash'EHOSTUNREACH{}(), \or{SortIOError{}} (Lbl'Hash'EINPROGRESS{}(), \or{SortIOError{}} (Lbl'Hash'EINTR{}(), \or{SortIOError{}} (Lbl'Hash'EINVAL{}(), \or{SortIOError{}} (Lbl'Hash'EIO{}(), \or{SortIOError{}} (Lbl'Hash'EISCONN{}(), \or{SortIOError{}} (Lbl'Hash'EISDIR{}(), \or{SortIOError{}} (Lbl'Hash'ELOOP{}(), \or{SortIOError{}} (Lbl'Hash'EMFILE{}(), \or{SortIOError{}} (Lbl'Hash'EMLINK{}(), \or{SortIOError{}} (Lbl'Hash'EMSGSIZE{}(), \or{SortIOError{}} (Lbl'Hash'ENAMETOOLONG{}(), \or{SortIOError{}} (Lbl'Hash'ENETDOWN{}(), \or{SortIOError{}} (Lbl'Hash'ENETRESET{}(), \or{SortIOError{}} (Lbl'Hash'ENETUNREACH{}(), \or{SortIOError{}} (Lbl'Hash'ENFILE{}(), \or{SortIOError{}} (Lbl'Hash'ENOBUFS{}(), \or{SortIOError{}} (Lbl'Hash'ENODEV{}(), \or{SortIOError{}} (Lbl'Hash'ENOENT{}(), \or{SortIOError{}} (Lbl'Hash'ENOEXEC{}(), \or{SortIOError{}} (Lbl'Hash'ENOLCK{}(), \or{SortIOError{}} (Lbl'Hash'ENOMEM{}(), \or{SortIOError{}} (Lbl'Hash'ENOPROTOOPT{}(), \or{SortIOError{}} (Lbl'Hash'ENOSPC{}(), \or{SortIOError{}} (Lbl'Hash'ENOSYS{}(), \or{SortIOError{}} (Lbl'Hash'ENOTCONN{}(), \or{SortIOError{}} (Lbl'Hash'ENOTDIR{}(), \or{SortIOError{}} (Lbl'Hash'ENOTEMPTY{}(), \or{SortIOError{}} (Lbl'Hash'ENOTSOCK{}(), \or{SortIOError{}} (Lbl'Hash'ENOTTY{}(), \or{SortIOError{}} (Lbl'Hash'ENXIO{}(), \or{SortIOError{}} (Lbl'Hash'EOF{}(), \or{SortIOError{}} (Lbl'Hash'EOPNOTSUPP{}(), \or{SortIOError{}} (Lbl'Hash'EOVERFLOW{}(), \or{SortIOError{}} (Lbl'Hash'EPERM{}(), \or{SortIOError{}} (Lbl'Hash'EPFNOSUPPORT{}(), \or{SortIOError{}} (Lbl'Hash'EPIPE{}(), \or{SortIOError{}} (Lbl'Hash'EPROTONOSUPPORT{}(), \or{SortIOError{}} (Lbl'Hash'EPROTOTYPE{}(), \or{SortIOError{}} (Lbl'Hash'ERANGE{}(), \or{SortIOError{}} (Lbl'Hash'EROFS{}(), \or{SortIOError{}} (Lbl'Hash'ESHUTDOWN{}(), \or{SortIOError{}} (Lbl'Hash'ESOCKTNOSUPPORT{}(), \or{SortIOError{}} (Lbl'Hash'ESPIPE{}(), \or{SortIOError{}} (Lbl'Hash'ESRCH{}(), \or{SortIOError{}} (Lbl'Hash'ETIMEDOUT{}(), \or{SortIOError{}} (Lbl'Hash'ETOOMANYREFS{}(), \or{SortIOError{}} (Lbl'Hash'EWOULDBLOCK{}(), \or{SortIOError{}} (Lbl'Hash'EXDEV{}(), \or{SortIOError{}} (\exists{SortIOError{}} (X0:SortInt{}, Lbl'Hash'unknownIOError{}(X0:SortInt{})), \bottom{SortIOError{}}())))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) [constructor{}()] // no junk
  axiom{} \or{SortEnumerationConstant{}} (\exists{SortEnumerationConstant{}} (Val:SortId{}, inj{SortId{}, SortEnumerationConstant{}} (Val:SortId{})), \bottom{SortEnumerationConstant{}}()) [constructor{}()] // no junk
  axiom{} \or{SortOslCellOpt{}} (LblnoOslCell{}(), \or{SortOslCellOpt{}} (\exists{SortOslCellOpt{}} (Val:SortOslCell{}, inj{SortOslCell{}, SortOslCellOpt{}} (Val:SortOslCell{})), \bottom{SortOslCellOpt{}}())) [constructor{}()] // no junk
  axiom{} \or{SortShiftExpression{}} (\exists{SortShiftExpression{}} (X0:SortShiftExpression{}, \exists{SortShiftExpression{}} (X1:SortAdditiveExpression{}, Lbl'Unds-LT--LT-UndsUnds'C-SYNTAX'Unds'ShiftExpression'Unds'ShiftExpression'Unds'AdditiveExpression{}(X0:SortShiftExpression{}, X1:SortAdditiveExpression{}))), \or{SortShiftExpression{}} (\exists{SortShiftExpression{}} (X0:SortShiftExpression{}, \exists{SortShiftExpression{}} (X1:SortAdditiveExpression{}, Lbl'Unds-GT--GT-UndsUnds'C-SYNTAX'Unds'ShiftExpression'Unds'ShiftExpression'Unds'AdditiveExpression{}(X0:SortShiftExpression{}, X1:SortAdditiveExpression{}))), \or{SortShiftExpression{}} (\exists{SortShiftExpression{}} (Val:SortPostfixExpression{}, inj{SortPostfixExpression{}, SortShiftExpression{}} (Val:SortPostfixExpression{})), \or{SortShiftExpression{}} (\exists{SortShiftExpression{}} (Val:SortString{}, inj{SortString{}, SortShiftExpression{}} (Val:SortString{})), \or{SortShiftExpression{}} (\exists{SortShiftExpression{}} (Val:SortPrimaryExpression{}, inj{SortPrimaryExpression{}, SortShiftExpression{}} (Val:SortPrimaryExpression{})), \or{SortShiftExpression{}} (\exists{SortShiftExpression{}} (Val:SortUnaryExpression{}, inj{SortUnaryExpression{}, SortShiftExpression{}} (Val:SortUnaryExpression{})), \or{SortShiftExpression{}} (\exists{SortShiftExpression{}} (Val:SortId{}, inj{SortId{}, SortShiftExpression{}} (Val:SortId{})), \or{SortShiftExpression{}} (\exists{SortShiftExpression{}} (Val:SortConstant{}, inj{SortConstant{}, SortShiftExpression{}} (Val:SortConstant{})), \or{SortShiftExpression{}} (\exists{SortShiftExpression{}} (Val:SortMultiplicativeExpression{}, inj{SortMultiplicativeExpression{}, SortShiftExpression{}} (Val:SortMultiplicativeExpression{})), \or{SortShiftExpression{}} (\exists{SortShiftExpression{}} (Val:SortInt{}, inj{SortInt{}, SortShiftExpression{}} (Val:SortInt{})), \or{SortShiftExpression{}} (\exists{SortShiftExpression{}} (Val:SortFloat{}, inj{SortFloat{}, SortShiftExpression{}} (Val:SortFloat{})), \or{SortShiftExpression{}} (\exists{SortShiftExpression{}} (Val:SortCastExpression{}, inj{SortCastExpression{}, SortShiftExpression{}} (Val:SortCastExpression{})), \or{SortShiftExpression{}} (\exists{SortShiftExpression{}} (Val:SortAdditiveExpression{}, inj{SortAdditiveExpression{}, SortShiftExpression{}} (Val:SortAdditiveExpression{})), \or{SortShiftExpression{}} (\exists{SortShiftExpression{}} (Val:SortEnumerationConstant{}, inj{SortEnumerationConstant{}, SortShiftExpression{}} (Val:SortEnumerationConstant{})), \bottom{SortShiftExpression{}}())))))))))))))) [constructor{}()] // no junk

// rules
// rule `#if_#then_#else_#fi_K-EQUAL-SYNTAX_Sort_Bool_Sort_Sort`{K}(C,B1,_0)=>B1 requires C ensures #token("true","Bool") [UNIQUE_ID(2b32069ac3f589174502fa507ebc88fab7c902854c0a9baa8ab09beb551232e2), contentStartColumn(8), contentStartLine(2054), org.kframework.attributes.Location(Location(2054,8,2054,59)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody "requires" Bool [klabel(#ruleRequires), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \equals{SortBool{},R}(
        VarC:SortBool{},
        \dv{SortBool{}}("true")),
      \and{R} (
          \in{SortBool{}, R} (
            X0:SortBool{},
            VarC:SortBool{}
          ),\and{R} (
          \in{SortK{}, R} (
            X1:SortK{},
            VarB1:SortK{}
          ),\and{R} (
          \in{SortK{}, R} (
            X2:SortK{},
            Var'Unds'0:SortK{}
          ),
          \top{R} ()
        )))),
    \and{R} (
      \equals{SortK{},R} (
        Lbl'Hash'if'UndsHash'then'UndsHash'else'UndsHash'fi'Unds'K-EQUAL-SYNTAX'Unds'Sort'Unds'Bool'Unds'Sort'Unds'Sort{SortK{}}(X0:SortBool{},X1:SortK{},X2:SortK{}),
        VarB1:SortK{}),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody \"requires\" Bool [klabel(#ruleRequires), symbol]"), contentStartLine{}("2054"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2054,8,2054,59)"), UNIQUE'Unds'ID{}("2b32069ac3f589174502fa507ebc88fab7c902854c0a9baa8ab09beb551232e2")]

// rule `#if_#then_#else_#fi_K-EQUAL-SYNTAX_Sort_Bool_Sort_Sort`{K}(C,_0,B2)=>B2 requires `notBool_`(C) ensures #token("true","Bool") [UNIQUE_ID(651bff3fa53d464ac7dd7aa77e1ef6071e14c959eb6df97baa325e2ad300daaa), contentStartColumn(8), contentStartLine(2055), org.kframework.attributes.Location(Location(2055,8,2055,67)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody "requires" Bool [klabel(#ruleRequires), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \equals{SortBool{},R}(
        LblnotBool'Unds'{}(VarC:SortBool{}),
        \dv{SortBool{}}("true")),
      \and{R} (
          \in{SortBool{}, R} (
            X0:SortBool{},
            VarC:SortBool{}
          ),\and{R} (
          \in{SortK{}, R} (
            X1:SortK{},
            Var'Unds'0:SortK{}
          ),\and{R} (
          \in{SortK{}, R} (
            X2:SortK{},
            VarB2:SortK{}
          ),
          \top{R} ()
        )))),
    \and{R} (
      \equals{SortK{},R} (
        Lbl'Hash'if'UndsHash'then'UndsHash'else'UndsHash'fi'Unds'K-EQUAL-SYNTAX'Unds'Sort'Unds'Bool'Unds'Sort'Unds'Sort{SortK{}}(X0:SortBool{},X1:SortK{},X2:SortK{}),
        VarB2:SortK{}),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody \"requires\" Bool [klabel(#ruleRequires), symbol]"), contentStartLine{}("2055"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2055,8,2055,67)"), UNIQUE'Unds'ID{}("651bff3fa53d464ac7dd7aa77e1ef6071e14c959eb6df97baa325e2ad300daaa")]

// rule `#open(_)_K-IO_IOInt_String`(S)=>`#open(_,_)_K-IO_IOInt_String_String`(S,#token("\"r+\"","String")) requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(7ad2779cd54b9009119458217cae5138026cc4ff244e54c28e64db21100f63d9), contentStartColumn(8), contentStartLine(2236), org.kframework.attributes.Location(Location(2236,8,2236,48)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortString{}, R} (
            X0:SortString{},
            VarS:SortString{}
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortIOInt{},R} (
        Lbl'Hash'open'LParUndsRParUnds'K-IO'Unds'IOInt'Unds'String{}(X0:SortString{}),
        Lbl'Hash'open'LParUndsCommUndsRParUnds'K-IO'Unds'IOInt'Unds'String'Unds'String{}(VarS:SortString{},\dv{SortString{}}("r+"))),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("2236"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2236,8,2236,48)"), UNIQUE'Unds'ID{}("7ad2779cd54b9009119458217cae5138026cc4ff244e54c28e64db21100f63d9")]

// rule `#stderr_K-IO_Int`(.KList)=>#token("2","Int") requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(75e0a8082acda4cf1e29caa6aaafb7f9a421e16421a41f2006943d6fab17a162), contentStartColumn(8), contentStartLine(2333), org.kframework.attributes.Location(Location(2333,8,2333,20)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      
          \top{R} ()
        ),
    \and{R} (
      \equals{SortInt{},R} (
        Lbl'Hash'stderr'Unds'K-IO'Unds'Int{}(),
        \dv{SortInt{}}("2")),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("2333"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2333,8,2333,20)"), UNIQUE'Unds'ID{}("75e0a8082acda4cf1e29caa6aaafb7f9a421e16421a41f2006943d6fab17a162")]

// rule `#stdin_K-IO_Int`(.KList)=>#token("0","Int") requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(c7ffdc9908c28a954521816d680f4e5ec44a679c7231a8dd09d4700f50b6d8c3), contentStartColumn(8), contentStartLine(2331), org.kframework.attributes.Location(Location(2331,8,2331,19)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      
          \top{R} ()
        ),
    \and{R} (
      \equals{SortInt{},R} (
        Lbl'Hash'stdin'Unds'K-IO'Unds'Int{}(),
        \dv{SortInt{}}("0")),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("2331"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2331,8,2331,19)"), UNIQUE'Unds'ID{}("c7ffdc9908c28a954521816d680f4e5ec44a679c7231a8dd09d4700f50b6d8c3")]

// rule `#stdout_K-IO_Int`(.KList)=>#token("1","Int") requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(4ad4f379ff9db687ff9dfd1b15052edbcd3342a2ed262ecdd38c769e177a592c), contentStartColumn(8), contentStartLine(2332), org.kframework.attributes.Location(Location(2332,8,2332,20)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      
          \top{R} ()
        ),
    \and{R} (
      \equals{SortInt{},R} (
        Lbl'Hash'stdout'Unds'K-IO'Unds'Int{}(),
        \dv{SortInt{}}("1")),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("2332"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2332,8,2332,20)"), UNIQUE'Unds'ID{}("4ad4f379ff9db687ff9dfd1b15052edbcd3342a2ed262ecdd38c769e177a592c")]

// rule `Bool2String(_)_STRING-COMMON_String_Bool`(#token("false","Bool"))=>#token("\"false\"","String") requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(cca4780e4e7660055f781b9643f3125234a0f4f08ba76cacf8e5a18fe7fc999f), contentStartColumn(8), contentStartLine(1450), org.kframework.attributes.Location(Location(1450,8,1450,37)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortBool{}, R} (
            X0:SortBool{},
            \dv{SortBool{}}("false")
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortString{},R} (
        LblBool2String'LParUndsRParUnds'STRING-COMMON'Unds'String'Unds'Bool{}(X0:SortBool{}),
        \dv{SortString{}}("false")),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("1450"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1450,8,1450,37)"), UNIQUE'Unds'ID{}("cca4780e4e7660055f781b9643f3125234a0f4f08ba76cacf8e5a18fe7fc999f")]

// rule `Bool2String(_)_STRING-COMMON_String_Bool`(#token("true","Bool"))=>#token("\"true\"","String") requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(365df37345a5a44ac061f8741369c7bd74a49f0f6e7b716be0374806dd1add3d), contentStartColumn(8), contentStartLine(1449), org.kframework.attributes.Location(Location(1449,8,1449,36)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortBool{}, R} (
            X0:SortBool{},
            \dv{SortBool{}}("true")
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortString{},R} (
        LblBool2String'LParUndsRParUnds'STRING-COMMON'Unds'String'Unds'Bool{}(X0:SortBool{}),
        \dv{SortString{}}("true")),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("1449"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1449,8,1449,36)"), UNIQUE'Unds'ID{}("365df37345a5a44ac061f8741369c7bd74a49f0f6e7b716be0374806dd1add3d")]

// rule `String2Bool(_)_STRING-COMMON_Bool_String`(#token("\"false\"","String"))=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(b73b5c8e0ae45020f2b9b8170d366691fee01a63763b79653a2075703ec4e835), contentStartColumn(8), contentStartLine(1456), org.kframework.attributes.Location(Location(1456,8,1456,37)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortString{}, R} (
            X0:SortString{},
            \dv{SortString{}}("false")
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblString2Bool'LParUndsRParUnds'STRING-COMMON'Unds'Bool'Unds'String{}(X0:SortString{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("1456"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1456,8,1456,37)"), UNIQUE'Unds'ID{}("b73b5c8e0ae45020f2b9b8170d366691fee01a63763b79653a2075703ec4e835")]

// rule `String2Bool(_)_STRING-COMMON_Bool_String`(#token("\"true\"","String"))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(27a5d1d7872d61f82556a4e44bda13846dde7dc2d9c54304d7858de9a8b9d6b8), contentStartColumn(8), contentStartLine(1455), org.kframework.attributes.Location(Location(1455,8,1455,36)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortString{}, R} (
            X0:SortString{},
            \dv{SortString{}}("true")
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblString2Bool'LParUndsRParUnds'STRING-COMMON'Unds'Bool'Unds'String{}(X0:SortString{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("1455"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1455,8,1455,36)"), UNIQUE'Unds'ID{}("27a5d1d7872d61f82556a4e44bda13846dde7dc2d9c54304d7858de9a8b9d6b8")]

// rule `_<=String__STRING-COMMON_Bool_String_String`(S1,S2)=>`notBool_`(`_<String__STRING-COMMON_Bool_String_String`(S2,S1)) requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(9e50fb4dcba1212ee863c170298cb8b555f39fb3b4bcb649f3d1d8e321accc80), contentStartColumn(8), contentStartLine(1549), org.kframework.attributes.Location(Location(1549,8,1549,63)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortString{}, R} (
            X0:SortString{},
            VarS1:SortString{}
          ),\and{R} (
          \in{SortString{}, R} (
            X1:SortString{},
            VarS2:SortString{}
          ),
          \top{R} ()
        ))),
    \and{R} (
      \equals{SortBool{},R} (
        Lbl'Unds-LT-Eqls'String'UndsUnds'STRING-COMMON'Unds'Bool'Unds'String'Unds'String{}(X0:SortString{},X1:SortString{}),
        LblnotBool'Unds'{}(Lbl'Unds-LT-'String'UndsUnds'STRING-COMMON'Unds'Bool'Unds'String'Unds'String{}(VarS2:SortString{},VarS1:SortString{}))),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("1549"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1549,8,1549,63)"), UNIQUE'Unds'ID{}("9e50fb4dcba1212ee863c170298cb8b555f39fb3b4bcb649f3d1d8e321accc80")]

// rule `_=/=Bool_`(B1,B2)=>`notBool_`(`_==Bool_`(B1,B2)) requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(31fe72efcfddcd8588a11d9d10c1b1a9f96ae3da46b647d4cb9d1e8b1bd1654f), contentStartColumn(8), contentStartLine(868), org.kframework.attributes.Location(Location(868,8,868,57)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortBool{}, R} (
            X0:SortBool{},
            VarB1:SortBool{}
          ),\and{R} (
          \in{SortBool{}, R} (
            X1:SortBool{},
            VarB2:SortBool{}
          ),
          \top{R} ()
        ))),
    \and{R} (
      \equals{SortBool{},R} (
        Lbl'UndsEqlsSlshEqls'Bool'Unds'{}(X0:SortBool{},X1:SortBool{}),
        LblnotBool'Unds'{}(Lbl'UndsEqlsEqls'Bool'Unds'{}(VarB1:SortBool{},VarB2:SortBool{}))),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("868"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(868,8,868,57)"), UNIQUE'Unds'ID{}("31fe72efcfddcd8588a11d9d10c1b1a9f96ae3da46b647d4cb9d1e8b1bd1654f")]

// rule `_=/=Int_`(I1,I2)=>`notBool_`(`_==Int_`(I1,I2)) requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(4de6e05b11cdbed7ef5cb4c952127924661af4744c1e495370e1c8a962ba7be3), contentStartColumn(8), contentStartLine(1116), org.kframework.attributes.Location(Location(1116,8,1116,53)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortInt{}, R} (
            X0:SortInt{},
            VarI1:SortInt{}
          ),\and{R} (
          \in{SortInt{}, R} (
            X1:SortInt{},
            VarI2:SortInt{}
          ),
          \top{R} ()
        ))),
    \and{R} (
      \equals{SortBool{},R} (
        Lbl'UndsEqlsSlshEqls'Int'Unds'{}(X0:SortInt{},X1:SortInt{}),
        LblnotBool'Unds'{}(Lbl'UndsEqlsEqls'Int'Unds'{}(VarI1:SortInt{},VarI2:SortInt{}))),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("1116"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1116,8,1116,53)"), UNIQUE'Unds'ID{}("4de6e05b11cdbed7ef5cb4c952127924661af4744c1e495370e1c8a962ba7be3")]

// rule `_=/=K_`(K1,K2)=>`notBool_`(`_==K_`(K1,K2)) requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(bccaba7335e4cd77501a0667f2f7b3eb4a2105d5f60d804915dd4b1b08902c0c), contentStartColumn(8), contentStartLine(2052), org.kframework.attributes.Location(Location(2052,8,2052,45)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK1:SortK{}
          ),\and{R} (
          \in{SortK{}, R} (
            X1:SortK{},
            VarK2:SortK{}
          ),
          \top{R} ()
        ))),
    \and{R} (
      \equals{SortBool{},R} (
        Lbl'UndsEqlsSlshEqls'K'Unds'{}(X0:SortK{},X1:SortK{}),
        LblnotBool'Unds'{}(Lbl'UndsEqlsEqls'K'Unds'{}(VarK1:SortK{},VarK2:SortK{}))),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("2052"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2052,8,2052,45)"), UNIQUE'Unds'ID{}("bccaba7335e4cd77501a0667f2f7b3eb4a2105d5f60d804915dd4b1b08902c0c")]

// rule `_=/=String__STRING-COMMON_Bool_String_String`(S1,S2)=>`notBool_`(`_==String__STRING-COMMON_Bool_String_String`(S1,S2)) requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(f390a9b650f3de0e3a93773a46e65aae3decdeb2a10906058f204f031681c9b7), contentStartColumn(8), contentStartLine(1529), org.kframework.attributes.Location(Location(1529,8,1529,65)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortString{}, R} (
            X0:SortString{},
            VarS1:SortString{}
          ),\and{R} (
          \in{SortString{}, R} (
            X1:SortString{},
            VarS2:SortString{}
          ),
          \top{R} ()
        ))),
    \and{R} (
      \equals{SortBool{},R} (
        Lbl'UndsEqlsSlshEqls'String'UndsUnds'STRING-COMMON'Unds'Bool'Unds'String'Unds'String{}(X0:SortString{},X1:SortString{}),
        LblnotBool'Unds'{}(Lbl'UndsEqlsEqls'String'UndsUnds'STRING-COMMON'Unds'Bool'Unds'String'Unds'String{}(VarS1:SortString{},VarS2:SortString{}))),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("1529"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1529,8,1529,65)"), UNIQUE'Unds'ID{}("f390a9b650f3de0e3a93773a46e65aae3decdeb2a10906058f204f031681c9b7")]

// rule `_==K_`(inj{Int,KItem}(I1),inj{Int,KItem}(I2))=>`_==Int_`(I1,I2) requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(8bf41fa14e6cef57ebcd77d165461911b0f45874319eafd20a311466ff77ac6f), contentStartColumn(8), contentStartLine(1090), org.kframework.attributes.Location(Location(1090,8,1090,40)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortInt{}, SortKItem{}}(VarI1:SortInt{}),dotk{}())
          ),\and{R} (
          \in{SortK{}, R} (
            X1:SortK{},
            kseq{}(inj{SortInt{}, SortKItem{}}(VarI2:SortInt{}),dotk{}())
          ),
          \top{R} ()
        ))),
    \and{R} (
      \equals{SortBool{},R} (
        Lbl'UndsEqlsEqls'K'Unds'{}(X0:SortK{},X1:SortK{}),
        Lbl'UndsEqlsEqls'Int'Unds'{}(VarI1:SortInt{},VarI2:SortInt{})),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("1090"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1090,8,1090,40)"), UNIQUE'Unds'ID{}("8bf41fa14e6cef57ebcd77d165461911b0f45874319eafd20a311466ff77ac6f")]

// rule `_==K_`(inj{Bool,KItem}(K1),inj{Bool,KItem}(K2))=>`_==Bool_`(K1,K2) requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(51ca403f7048793055685a9e3a051e86807f14b2d4901ae81d0b4eedff7b1d77), contentStartColumn(8), contentStartLine(2034), org.kframework.attributes.Location(Location(2034,8,2034,43)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortBool{}, SortKItem{}}(VarK1:SortBool{}),dotk{}())
          ),\and{R} (
          \in{SortK{}, R} (
            X1:SortK{},
            kseq{}(inj{SortBool{}, SortKItem{}}(VarK2:SortBool{}),dotk{}())
          ),
          \top{R} ()
        ))),
    \and{R} (
      \equals{SortBool{},R} (
        Lbl'UndsEqlsEqls'K'Unds'{}(X0:SortK{},X1:SortK{}),
        Lbl'UndsEqlsEqls'Bool'Unds'{}(VarK1:SortBool{},VarK2:SortBool{})),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("2034"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(2034,8,2034,43)"), UNIQUE'Unds'ID{}("51ca403f7048793055685a9e3a051e86807f14b2d4901ae81d0b4eedff7b1d77")]

// rule `_==K_`(inj{String,KItem}(S1),inj{String,KItem}(S2))=>`_==String__STRING-COMMON_Bool_String_String`(S1,S2) requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(512288fc69c52cbd01cf38881d419b391f66a3d428beddb746e0012a9f880325), contentStartColumn(8), contentStartLine(1591), org.kframework.attributes.Location(Location(1591,8,1591,49)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortString{}, SortKItem{}}(VarS1:SortString{}),dotk{}())
          ),\and{R} (
          \in{SortK{}, R} (
            X1:SortK{},
            kseq{}(inj{SortString{}, SortKItem{}}(VarS2:SortString{}),dotk{}())
          ),
          \top{R} ()
        ))),
    \and{R} (
      \equals{SortBool{},R} (
        Lbl'UndsEqlsEqls'K'Unds'{}(X0:SortK{},X1:SortK{}),
        Lbl'UndsEqlsEqls'String'UndsUnds'STRING-COMMON'Unds'Bool'Unds'String'Unds'String{}(VarS1:SortString{},VarS2:SortString{})),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("1591"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1591,8,1591,49)"), UNIQUE'Unds'ID{}("512288fc69c52cbd01cf38881d419b391f66a3d428beddb746e0012a9f880325")]

// rule `_>=String__STRING-COMMON_Bool_String_String`(S1,S2)=>`notBool_`(`_<String__STRING-COMMON_Bool_String_String`(S1,S2)) requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(b376ffb0925555ed27696d73fc8fe43306e2005e4cf6ad819e860958992f9f17), contentStartColumn(8), contentStartLine(1551), org.kframework.attributes.Location(Location(1551,8,1551,63)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortString{}, R} (
            X0:SortString{},
            VarS1:SortString{}
          ),\and{R} (
          \in{SortString{}, R} (
            X1:SortString{},
            VarS2:SortString{}
          ),
          \top{R} ()
        ))),
    \and{R} (
      \equals{SortBool{},R} (
        Lbl'Unds-GT-Eqls'String'UndsUnds'STRING-COMMON'Unds'Bool'Unds'String'Unds'String{}(X0:SortString{},X1:SortString{}),
        LblnotBool'Unds'{}(Lbl'Unds-LT-'String'UndsUnds'STRING-COMMON'Unds'Bool'Unds'String'Unds'String{}(VarS1:SortString{},VarS2:SortString{}))),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("1551"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1551,8,1551,63)"), UNIQUE'Unds'ID{}("b376ffb0925555ed27696d73fc8fe43306e2005e4cf6ad819e860958992f9f17")]

// rule `_>String__STRING-COMMON_Bool_String_String`(S1,S2)=>`_<String__STRING-COMMON_Bool_String_String`(S2,S1) requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(8e5353c0a58491f8613ad7a35d0833206c342df0c91773e42485e52f4dad0cd0), contentStartColumn(8), contentStartLine(1550), org.kframework.attributes.Location(Location(1550,8,1550,52)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortString{}, R} (
            X0:SortString{},
            VarS1:SortString{}
          ),\and{R} (
          \in{SortString{}, R} (
            X1:SortString{},
            VarS2:SortString{}
          ),
          \top{R} ()
        ))),
    \and{R} (
      \equals{SortBool{},R} (
        Lbl'Unds-GT-'String'UndsUnds'STRING-COMMON'Unds'Bool'Unds'String'Unds'String{}(X0:SortString{},X1:SortString{}),
        Lbl'Unds-LT-'String'UndsUnds'STRING-COMMON'Unds'Bool'Unds'String'Unds'String{}(VarS2:SortString{},VarS1:SortString{})),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("1550"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1550,8,1550,52)"), UNIQUE'Unds'ID{}("8e5353c0a58491f8613ad7a35d0833206c342df0c91773e42485e52f4dad0cd0")]

// rule `_andBool_`(#token("false","Bool") #as _1,_0)=>_1 requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(61fbef33b3611f1cc2aaf3b5e8ddec4a0f434c557278c38461c65c8722743497), contentStartColumn(8), contentStartLine(841), org.kframework.attributes.Location(Location(841,8,841,37)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortBool{}, R} (
            X0:SortBool{},
            \and{SortBool{}}(\dv{SortBool{}}("false"),Var'Unds'1:SortBool{})
          ),\and{R} (
          \in{SortBool{}, R} (
            X1:SortBool{},
            Var'Unds'0:SortBool{}
          ),
          \top{R} ()
        ))),
    \and{R} (
      \equals{SortBool{},R} (
        Lbl'Unds'andBool'Unds'{}(X0:SortBool{},X1:SortBool{}),
        Var'Unds'1:SortBool{}),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("841"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(841,8,841,37)"), UNIQUE'Unds'ID{}("61fbef33b3611f1cc2aaf3b5e8ddec4a0f434c557278c38461c65c8722743497")]

// rule `_andBool_`(B,#token("true","Bool"))=>B requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(e8d4ca75a690151f99f8904b068db555782f5599b11230a9d0b97a71afb6fc98), contentStartColumn(8), contentStartLine(840), org.kframework.attributes.Location(Location(840,8,840,37)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortBool{}, R} (
            X0:SortBool{},
            VarB:SortBool{}
          ),\and{R} (
          \in{SortBool{}, R} (
            X1:SortBool{},
            \dv{SortBool{}}("true")
          ),
          \top{R} ()
        ))),
    \and{R} (
      \equals{SortBool{},R} (
        Lbl'Unds'andBool'Unds'{}(X0:SortBool{},X1:SortBool{}),
        VarB:SortBool{}),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("840"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(840,8,840,37)"), UNIQUE'Unds'ID{}("e8d4ca75a690151f99f8904b068db555782f5599b11230a9d0b97a71afb6fc98")]

// rule `_andBool_`(_0,#token("false","Bool") #as _1)=>_1 requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(9c183fae7de06f560180386d14d29c609cadf0c98266ce2adbecb50100a1daca), contentStartColumn(8), contentStartLine(842), org.kframework.attributes.Location(Location(842,8,842,37)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortBool{}, R} (
            X0:SortBool{},
            Var'Unds'0:SortBool{}
          ),\and{R} (
          \in{SortBool{}, R} (
            X1:SortBool{},
            \and{SortBool{}}(\dv{SortBool{}}("false"),Var'Unds'1:SortBool{})
          ),
          \top{R} ()
        ))),
    \and{R} (
      \equals{SortBool{},R} (
        Lbl'Unds'andBool'Unds'{}(X0:SortBool{},X1:SortBool{}),
        Var'Unds'1:SortBool{}),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("842"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(842,8,842,37)"), UNIQUE'Unds'ID{}("9c183fae7de06f560180386d14d29c609cadf0c98266ce2adbecb50100a1daca")]

// rule `_andBool_`(#token("true","Bool"),B)=>B requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(5b9db8dba12010819161cc42dadccd0adf0100a47c21f884ae66c0a3d5483a1f), contentStartColumn(8), contentStartLine(839), org.kframework.attributes.Location(Location(839,8,839,37)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortBool{}, R} (
            X0:SortBool{},
            \dv{SortBool{}}("true")
          ),\and{R} (
          \in{SortBool{}, R} (
            X1:SortBool{},
            VarB:SortBool{}
          ),
          \top{R} ()
        ))),
    \and{R} (
      \equals{SortBool{},R} (
        Lbl'Unds'andBool'Unds'{}(X0:SortBool{},X1:SortBool{}),
        VarB:SortBool{}),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("839"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(839,8,839,37)"), UNIQUE'Unds'ID{}("5b9db8dba12010819161cc42dadccd0adf0100a47c21f884ae66c0a3d5483a1f")]

// rule `_andThenBool_`(#token("false","Bool") #as _1,_0)=>_1 requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(5b729746be7bf2183d9eff138d97078a7c9489def6d8b2e1495c41ce3954997d), contentStartColumn(8), contentStartLine(846), org.kframework.attributes.Location(Location(846,8,846,36)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortBool{}, R} (
            X0:SortBool{},
            \and{SortBool{}}(\dv{SortBool{}}("false"),Var'Unds'1:SortBool{})
          ),\and{R} (
          \in{SortBool{}, R} (
            X1:SortBool{},
            Var'Unds'0:SortBool{}
          ),
          \top{R} ()
        ))),
    \and{R} (
      \equals{SortBool{},R} (
        Lbl'Unds'andThenBool'Unds'{}(X0:SortBool{},X1:SortBool{}),
        Var'Unds'1:SortBool{}),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("846"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(846,8,846,36)"), UNIQUE'Unds'ID{}("5b729746be7bf2183d9eff138d97078a7c9489def6d8b2e1495c41ce3954997d")]

// rule `_andThenBool_`(K,#token("true","Bool"))=>K requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(82ac30b094be9b12206773d87b60274e929a41ca595f4674be1d37eeff873d7c), contentStartColumn(8), contentStartLine(845), org.kframework.attributes.Location(Location(845,8,845,37)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortBool{}, R} (
            X0:SortBool{},
            VarK:SortBool{}
          ),\and{R} (
          \in{SortBool{}, R} (
            X1:SortBool{},
            \dv{SortBool{}}("true")
          ),
          \top{R} ()
        ))),
    \and{R} (
      \equals{SortBool{},R} (
        Lbl'Unds'andThenBool'Unds'{}(X0:SortBool{},X1:SortBool{}),
        VarK:SortBool{}),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("845"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(845,8,845,37)"), UNIQUE'Unds'ID{}("82ac30b094be9b12206773d87b60274e929a41ca595f4674be1d37eeff873d7c")]

// rule `_andThenBool_`(_0,#token("false","Bool") #as _1)=>_1 requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(0508592878b546cbc6eeda6ec7b322584eea5c6d6eea3f72be8418fe4f7149b2), contentStartColumn(8), contentStartLine(847), org.kframework.attributes.Location(Location(847,8,847,36)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortBool{}, R} (
            X0:SortBool{},
            Var'Unds'0:SortBool{}
          ),\and{R} (
          \in{SortBool{}, R} (
            X1:SortBool{},
            \and{SortBool{}}(\dv{SortBool{}}("false"),Var'Unds'1:SortBool{})
          ),
          \top{R} ()
        ))),
    \and{R} (
      \equals{SortBool{},R} (
        Lbl'Unds'andThenBool'Unds'{}(X0:SortBool{},X1:SortBool{}),
        Var'Unds'1:SortBool{}),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("847"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(847,8,847,36)"), UNIQUE'Unds'ID{}("0508592878b546cbc6eeda6ec7b322584eea5c6d6eea3f72be8418fe4f7149b2")]

// rule `_andThenBool_`(#token("true","Bool"),K)=>K requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(78a3191cbbdec57b0f411f41291076c8124bb0d9b6b57905674b2c6858d78689), contentStartColumn(8), contentStartLine(844), org.kframework.attributes.Location(Location(844,8,844,37)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortBool{}, R} (
            X0:SortBool{},
            \dv{SortBool{}}("true")
          ),\and{R} (
          \in{SortBool{}, R} (
            X1:SortBool{},
            VarK:SortBool{}
          ),
          \top{R} ()
        ))),
    \and{R} (
      \equals{SortBool{},R} (
        Lbl'Unds'andThenBool'Unds'{}(X0:SortBool{},X1:SortBool{}),
        VarK:SortBool{}),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("844"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(844,8,844,37)"), UNIQUE'Unds'ID{}("78a3191cbbdec57b0f411f41291076c8124bb0d9b6b57905674b2c6858d78689")]

// rule `_divInt_`(I1,I2)=>`_/Int_`(`_-Int_`(I1,`_modInt_`(I1,I2)),I2) requires `_=/=Int_`(I2,#token("0","Int")) ensures #token("true","Bool") [UNIQUE_ID(83dcf9bc8c69f131715bc7a92d06c99b9a2b5f4c4fdafb69e6fdb2f1822712d4), contentStartColumn(8), contentStartLine(1105), org.kframework.attributes.Location(Location(1105,8,1106,23)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody "requires" Bool [klabel(#ruleRequires), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \equals{SortBool{},R}(
        Lbl'UndsEqlsSlshEqls'Int'Unds'{}(VarI2:SortInt{},\dv{SortInt{}}("0")),
        \dv{SortBool{}}("true")),
      \and{R} (
          \in{SortInt{}, R} (
            X0:SortInt{},
            VarI1:SortInt{}
          ),\and{R} (
          \in{SortInt{}, R} (
            X1:SortInt{},
            VarI2:SortInt{}
          ),
          \top{R} ()
        ))),
    \and{R} (
      \equals{SortInt{},R} (
        Lbl'Unds'divInt'Unds'{}(X0:SortInt{},X1:SortInt{}),
        Lbl'UndsSlsh'Int'Unds'{}(Lbl'Unds'-Int'Unds'{}(VarI1:SortInt{},Lbl'Unds'modInt'Unds'{}(VarI1:SortInt{},VarI2:SortInt{})),VarI2:SortInt{})),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody \"requires\" Bool [klabel(#ruleRequires), symbol]"), contentStartLine{}("1105"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1105,8,1106,23)"), UNIQUE'Unds'ID{}("83dcf9bc8c69f131715bc7a92d06c99b9a2b5f4c4fdafb69e6fdb2f1822712d4")]

// rule `_dividesInt__INT-COMMON_Bool_Int_Int`(I1,I2)=>`_==Int_`(`_%Int_`(I2,I1),#token("0","Int")) requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(fd8facae0061fe5bc5c406f7ad2ed5d8d21960bf1118c9b240451253064dadb5), contentStartColumn(8), contentStartLine(1117), org.kframework.attributes.Location(Location(1117,8,1117,58)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortInt{}, R} (
            X0:SortInt{},
            VarI1:SortInt{}
          ),\and{R} (
          \in{SortInt{}, R} (
            X1:SortInt{},
            VarI2:SortInt{}
          ),
          \top{R} ()
        ))),
    \and{R} (
      \equals{SortBool{},R} (
        Lbl'Unds'dividesInt'UndsUnds'INT-COMMON'Unds'Bool'Unds'Int'Unds'Int{}(X0:SortInt{},X1:SortInt{}),
        Lbl'UndsEqlsEqls'Int'Unds'{}(Lbl'UndsPerc'Int'Unds'{}(VarI2:SortInt{},VarI1:SortInt{}),\dv{SortInt{}}("0"))),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("1117"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1117,8,1117,58)"), UNIQUE'Unds'ID{}("fd8facae0061fe5bc5c406f7ad2ed5d8d21960bf1118c9b240451253064dadb5")]

// rule `_impliesBool_`(B,#token("false","Bool"))=>`notBool_`(B) requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(022c562a21d72cedfb795607d2249b8ad14b66399b720b3b2f4a05a1da08df96), contentStartColumn(8), contentStartLine(866), org.kframework.attributes.Location(Location(866,8,866,45)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortBool{}, R} (
            X0:SortBool{},
            VarB:SortBool{}
          ),\and{R} (
          \in{SortBool{}, R} (
            X1:SortBool{},
            \dv{SortBool{}}("false")
          ),
          \top{R} ()
        ))),
    \and{R} (
      \equals{SortBool{},R} (
        Lbl'Unds'impliesBool'Unds'{}(X0:SortBool{},X1:SortBool{}),
        LblnotBool'Unds'{}(VarB:SortBool{})),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("866"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(866,8,866,45)"), UNIQUE'Unds'ID{}("022c562a21d72cedfb795607d2249b8ad14b66399b720b3b2f4a05a1da08df96")]

// rule `_impliesBool_`(_0,#token("true","Bool"))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(99ba64afc26a739953df142ccd4b486bba68107fce8c9aa356d40afa7a988712), contentStartColumn(8), contentStartLine(865), org.kframework.attributes.Location(Location(865,8,865,39)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortBool{}, R} (
            X0:SortBool{},
            Var'Unds'0:SortBool{}
          ),\and{R} (
          \in{SortBool{}, R} (
            X1:SortBool{},
            \dv{SortBool{}}("true")
          ),
          \top{R} ()
        ))),
    \and{R} (
      \equals{SortBool{},R} (
        Lbl'Unds'impliesBool'Unds'{}(X0:SortBool{},X1:SortBool{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("865"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(865,8,865,39)"), UNIQUE'Unds'ID{}("99ba64afc26a739953df142ccd4b486bba68107fce8c9aa356d40afa7a988712")]

// rule `_impliesBool_`(#token("false","Bool"),_0)=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(55bb5c83c9563c712537b95401c0a5c88255fd7cdbd18b2d4358c54aee80660e), contentStartColumn(8), contentStartLine(864), org.kframework.attributes.Location(Location(864,8,864,40)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortBool{}, R} (
            X0:SortBool{},
            \dv{SortBool{}}("false")
          ),\and{R} (
          \in{SortBool{}, R} (
            X1:SortBool{},
            Var'Unds'0:SortBool{}
          ),
          \top{R} ()
        ))),
    \and{R} (
      \equals{SortBool{},R} (
        Lbl'Unds'impliesBool'Unds'{}(X0:SortBool{},X1:SortBool{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("864"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(864,8,864,40)"), UNIQUE'Unds'ID{}("55bb5c83c9563c712537b95401c0a5c88255fd7cdbd18b2d4358c54aee80660e")]

// rule `_impliesBool_`(#token("true","Bool"),B)=>B requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(da818c43c21c5fb2cced7e02a74b6b4191d323de2967a671b961ad28550f3c7d), contentStartColumn(8), contentStartLine(863), org.kframework.attributes.Location(Location(863,8,863,36)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortBool{}, R} (
            X0:SortBool{},
            \dv{SortBool{}}("true")
          ),\and{R} (
          \in{SortBool{}, R} (
            X1:SortBool{},
            VarB:SortBool{}
          ),
          \top{R} ()
        ))),
    \and{R} (
      \equals{SortBool{},R} (
        Lbl'Unds'impliesBool'Unds'{}(X0:SortBool{},X1:SortBool{}),
        VarB:SortBool{}),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("863"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(863,8,863,36)"), UNIQUE'Unds'ID{}("da818c43c21c5fb2cced7e02a74b6b4191d323de2967a671b961ad28550f3c7d")]

// rule `_modInt_`(I1,I2)=>`_%Int_`(`_+Int_`(`_%Int_`(I1,`absInt(_)_INT-COMMON_Int_Int`(I2)),`absInt(_)_INT-COMMON_Int_Int`(I2)),`absInt(_)_INT-COMMON_Int_Int`(I2)) requires `_=/=Int_`(I2,#token("0","Int")) ensures #token("true","Bool") [UNIQUE_ID(adfacb58b0678a49f66186954229939a953c9849d5b08edc8f887c0d7514b2c6), concrete, contentStartColumn(5), contentStartLine(1108), org.kframework.attributes.Location(Location(1108,5,1111,23)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody "requires" Bool [klabel(#ruleRequires), symbol]), simplification]
  axiom{R} \implies{R} (
    \equals{SortBool{},R}(
        Lbl'UndsEqlsSlshEqls'Int'Unds'{}(VarI2:SortInt{},\dv{SortInt{}}("0")),
        \dv{SortBool{}}("true")),
    \and{R} (
      \equals{SortInt{},R} (
        Lbl'Unds'modInt'Unds'{}(VarI1:SortInt{},VarI2:SortInt{}),
        Lbl'UndsPerc'Int'Unds'{}(Lbl'UndsPlus'Int'Unds'{}(Lbl'UndsPerc'Int'Unds'{}(VarI1:SortInt{},LblabsInt'LParUndsRParUnds'INT-COMMON'Unds'Int'Unds'Int{}(VarI2:SortInt{})),LblabsInt'LParUndsRParUnds'INT-COMMON'Unds'Int'Unds'Int{}(VarI2:SortInt{})),LblabsInt'LParUndsRParUnds'INT-COMMON'Unds'Int'Unds'Int{}(VarI2:SortInt{}))),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody \"requires\" Bool [klabel(#ruleRequires), symbol]"), concrete{}(), contentStartLine{}("1108"), contentStartColumn{}("5"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1108,5,1111,23)"), simplification{}(), UNIQUE'Unds'ID{}("adfacb58b0678a49f66186954229939a953c9849d5b08edc8f887c0d7514b2c6")]

// rule `_orBool_`(B,#token("false","Bool"))=>B requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(d7245713da157cf997438091f92bb78eb51a6cefa568bb0d30560ce08d647f26), contentStartColumn(8), contentStartLine(856), org.kframework.attributes.Location(Location(856,8,856,32)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortBool{}, R} (
            X0:SortBool{},
            VarB:SortBool{}
          ),\and{R} (
          \in{SortBool{}, R} (
            X1:SortBool{},
            \dv{SortBool{}}("false")
          ),
          \top{R} ()
        ))),
    \and{R} (
      \equals{SortBool{},R} (
        Lbl'Unds'orBool'Unds'{}(X0:SortBool{},X1:SortBool{}),
        VarB:SortBool{}),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("856"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(856,8,856,32)"), UNIQUE'Unds'ID{}("d7245713da157cf997438091f92bb78eb51a6cefa568bb0d30560ce08d647f26")]

// rule `_orBool_`(_0,#token("true","Bool"))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(47860d52c18a441b229449cd89d5464256137dc32deb5551effbac0482c883f3), contentStartColumn(8), contentStartLine(854), org.kframework.attributes.Location(Location(854,8,854,34)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortBool{}, R} (
            X0:SortBool{},
            Var'Unds'0:SortBool{}
          ),\and{R} (
          \in{SortBool{}, R} (
            X1:SortBool{},
            \dv{SortBool{}}("true")
          ),
          \top{R} ()
        ))),
    \and{R} (
      \equals{SortBool{},R} (
        Lbl'Unds'orBool'Unds'{}(X0:SortBool{},X1:SortBool{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("854"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(854,8,854,34)"), UNIQUE'Unds'ID{}("47860d52c18a441b229449cd89d5464256137dc32deb5551effbac0482c883f3")]

// rule `_orBool_`(#token("false","Bool"),B)=>B requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(991a3290bc7b6dca75d676a72a848ec6b2bd2827fb0e9626252aa1507394ca1b), contentStartColumn(8), contentStartLine(855), org.kframework.attributes.Location(Location(855,8,855,32)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortBool{}, R} (
            X0:SortBool{},
            \dv{SortBool{}}("false")
          ),\and{R} (
          \in{SortBool{}, R} (
            X1:SortBool{},
            VarB:SortBool{}
          ),
          \top{R} ()
        ))),
    \and{R} (
      \equals{SortBool{},R} (
        Lbl'Unds'orBool'Unds'{}(X0:SortBool{},X1:SortBool{}),
        VarB:SortBool{}),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("855"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(855,8,855,32)"), UNIQUE'Unds'ID{}("991a3290bc7b6dca75d676a72a848ec6b2bd2827fb0e9626252aa1507394ca1b")]

// rule `_orBool_`(#token("true","Bool"),_0)=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(71744528cdad83bc729990d3af3b544d27b09630b2615ca707dd2fc6ec93e7c2), contentStartColumn(8), contentStartLine(853), org.kframework.attributes.Location(Location(853,8,853,34)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortBool{}, R} (
            X0:SortBool{},
            \dv{SortBool{}}("true")
          ),\and{R} (
          \in{SortBool{}, R} (
            X1:SortBool{},
            Var'Unds'0:SortBool{}
          ),
          \top{R} ()
        ))),
    \and{R} (
      \equals{SortBool{},R} (
        Lbl'Unds'orBool'Unds'{}(X0:SortBool{},X1:SortBool{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("853"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(853,8,853,34)"), UNIQUE'Unds'ID{}("71744528cdad83bc729990d3af3b544d27b09630b2615ca707dd2fc6ec93e7c2")]

// rule `_orElseBool_`(K,#token("false","Bool"))=>K requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(684b0444a1f711d49ff1502423a3346fb26958697423db488b05d25081fc0480), contentStartColumn(8), contentStartLine(861), org.kframework.attributes.Location(Location(861,8,861,37)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortBool{}, R} (
            X0:SortBool{},
            VarK:SortBool{}
          ),\and{R} (
          \in{SortBool{}, R} (
            X1:SortBool{},
            \dv{SortBool{}}("false")
          ),
          \top{R} ()
        ))),
    \and{R} (
      \equals{SortBool{},R} (
        Lbl'Unds'orElseBool'Unds'{}(X0:SortBool{},X1:SortBool{}),
        VarK:SortBool{}),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("861"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(861,8,861,37)"), UNIQUE'Unds'ID{}("684b0444a1f711d49ff1502423a3346fb26958697423db488b05d25081fc0480")]

// rule `_orElseBool_`(_0,#token("true","Bool"))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(c9eccff94ecf6e810c600d4536bf1701485c13c3456c6b98c0cdab0fe7c5af14), contentStartColumn(8), contentStartLine(859), org.kframework.attributes.Location(Location(859,8,859,33)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortBool{}, R} (
            X0:SortBool{},
            Var'Unds'0:SortBool{}
          ),\and{R} (
          \in{SortBool{}, R} (
            X1:SortBool{},
            \dv{SortBool{}}("true")
          ),
          \top{R} ()
        ))),
    \and{R} (
      \equals{SortBool{},R} (
        Lbl'Unds'orElseBool'Unds'{}(X0:SortBool{},X1:SortBool{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("859"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(859,8,859,33)"), UNIQUE'Unds'ID{}("c9eccff94ecf6e810c600d4536bf1701485c13c3456c6b98c0cdab0fe7c5af14")]

// rule `_orElseBool_`(#token("false","Bool"),K)=>K requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(eb8c85dac19a5951f694b65269c2b17c80d6d126d6a367958e4a5d736a880ecf), contentStartColumn(8), contentStartLine(860), org.kframework.attributes.Location(Location(860,8,860,37)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortBool{}, R} (
            X0:SortBool{},
            \dv{SortBool{}}("false")
          ),\and{R} (
          \in{SortBool{}, R} (
            X1:SortBool{},
            VarK:SortBool{}
          ),
          \top{R} ()
        ))),
    \and{R} (
      \equals{SortBool{},R} (
        Lbl'Unds'orElseBool'Unds'{}(X0:SortBool{},X1:SortBool{}),
        VarK:SortBool{}),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("860"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(860,8,860,37)"), UNIQUE'Unds'ID{}("eb8c85dac19a5951f694b65269c2b17c80d6d126d6a367958e4a5d736a880ecf")]

// rule `_orElseBool_`(#token("true","Bool"),_0)=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(354bd0860c7f38b59e285c935fd2ea553ebddbabb4973342ad25f0dac6ea7bf6), contentStartColumn(8), contentStartLine(858), org.kframework.attributes.Location(Location(858,8,858,33)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortBool{}, R} (
            X0:SortBool{},
            \dv{SortBool{}}("true")
          ),\and{R} (
          \in{SortBool{}, R} (
            X1:SortBool{},
            Var'Unds'0:SortBool{}
          ),
          \top{R} ()
        ))),
    \and{R} (
      \equals{SortBool{},R} (
        Lbl'Unds'orElseBool'Unds'{}(X0:SortBool{},X1:SortBool{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("858"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(858,8,858,33)"), UNIQUE'Unds'ID{}("354bd0860c7f38b59e285c935fd2ea553ebddbabb4973342ad25f0dac6ea7bf6")]

// rule `_xorBool_`(B,B)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(9a6d91cd75cd777b0d4db536b3e4b20578e74fe650e644b55294da95fd2dba7f), contentStartColumn(8), contentStartLine(851), org.kframework.attributes.Location(Location(851,8,851,38)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortBool{}, R} (
            X0:SortBool{},
            VarB:SortBool{}
          ),\and{R} (
          \in{SortBool{}, R} (
            X1:SortBool{},
            VarB:SortBool{}
          ),
          \top{R} ()
        ))),
    \and{R} (
      \equals{SortBool{},R} (
        Lbl'Unds'xorBool'Unds'{}(X0:SortBool{},X1:SortBool{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("851"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(851,8,851,38)"), UNIQUE'Unds'ID{}("9a6d91cd75cd777b0d4db536b3e4b20578e74fe650e644b55294da95fd2dba7f")]

// rule `_xorBool_`(B,#token("false","Bool"))=>B requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(7a2851f9d4ea4bd3f35070ee029fc3bdca36e361f7ee54addeff9d10ddeb7c75), contentStartColumn(8), contentStartLine(850), org.kframework.attributes.Location(Location(850,8,850,38)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortBool{}, R} (
            X0:SortBool{},
            VarB:SortBool{}
          ),\and{R} (
          \in{SortBool{}, R} (
            X1:SortBool{},
            \dv{SortBool{}}("false")
          ),
          \top{R} ()
        ))),
    \and{R} (
      \equals{SortBool{},R} (
        Lbl'Unds'xorBool'Unds'{}(X0:SortBool{},X1:SortBool{}),
        VarB:SortBool{}),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("850"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(850,8,850,38)"), UNIQUE'Unds'ID{}("7a2851f9d4ea4bd3f35070ee029fc3bdca36e361f7ee54addeff9d10ddeb7c75")]

// rule `_xorBool_`(#token("false","Bool"),B)=>B requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(73513655c09a595907ab9d26d67e27f01d14a3435743b77000c02d10f35c05bf), contentStartColumn(8), contentStartLine(849), org.kframework.attributes.Location(Location(849,8,849,38)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortBool{}, R} (
            X0:SortBool{},
            \dv{SortBool{}}("false")
          ),\and{R} (
          \in{SortBool{}, R} (
            X1:SortBool{},
            VarB:SortBool{}
          ),
          \top{R} ()
        ))),
    \and{R} (
      \equals{SortBool{},R} (
        Lbl'Unds'xorBool'Unds'{}(X0:SortBool{},X1:SortBool{}),
        VarB:SortBool{}),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("849"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(849,8,849,38)"), UNIQUE'Unds'ID{}("73513655c09a595907ab9d26d67e27f01d14a3435743b77000c02d10f35c05bf")]

// rule `_|Set__SET_Set_Set_Set`(S1,S2)=>`_Set_`(S1,`Set:difference`(S2,S1)) requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(e9a710d8d1ca5c799420161879cbbff926de45a5bddd820d646f51d43eb67e62), contentStartColumn(8), contentStartLine(555), org.kframework.attributes.Location(Location(555,8,555,45)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortSet{}, R} (
            X0:SortSet{},
            VarS1:SortSet{}
          ),\and{R} (
          \in{SortSet{}, R} (
            X1:SortSet{},
            VarS2:SortSet{}
          ),
          \top{R} ()
        ))),
    \and{R} (
      \equals{SortSet{},R} (
        Lbl'UndsPipe'Set'UndsUnds'SET'Unds'Set'Unds'Set'Unds'Set{}(X0:SortSet{},X1:SortSet{}),
        Lbl'Unds'Set'Unds'{}(VarS1:SortSet{},LblSet'Coln'difference{}(VarS2:SortSet{},VarS1:SortSet{}))),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("555"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(555,8,555,45)"), UNIQUE'Unds'ID{}("e9a710d8d1ca5c799420161879cbbff926de45a5bddd820d646f51d43eb67e62")]

// rule `bitRangeInt(_,_,_)_INT-COMMON_Int_Int_Int_Int`(I,IDX,LEN)=>`_modInt_`(`_>>Int_`(I,IDX),`_<<Int_`(#token("1","Int"),LEN)) requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(147fc15c2ec6c36de1a9c0cad6212b8acd8b224f21c0aeabd36726e9c8a06119), contentStartColumn(8), contentStartLine(1101), org.kframework.attributes.Location(Location(1101,8,1101,85)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortInt{}, R} (
            X0:SortInt{},
            VarI:SortInt{}
          ),\and{R} (
          \in{SortInt{}, R} (
            X1:SortInt{},
            VarIDX:SortInt{}
          ),\and{R} (
          \in{SortInt{}, R} (
            X2:SortInt{},
            VarLEN:SortInt{}
          ),
          \top{R} ()
        )))),
    \and{R} (
      \equals{SortInt{},R} (
        LblbitRangeInt'LParUndsCommUndsCommUndsRParUnds'INT-COMMON'Unds'Int'Unds'Int'Unds'Int'Unds'Int{}(X0:SortInt{},X1:SortInt{},X2:SortInt{}),
        Lbl'Unds'modInt'Unds'{}(Lbl'Unds-GT--GT-'Int'Unds'{}(VarI:SortInt{},VarIDX:SortInt{}),Lbl'Unds-LT--LT-'Int'Unds'{}(\dv{SortInt{}}("1"),VarLEN:SortInt{}))),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("1101"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1101,8,1101,85)"), UNIQUE'Unds'ID{}("147fc15c2ec6c36de1a9c0cad6212b8acd8b224f21c0aeabd36726e9c8a06119")]

// rule `countAllOccurrences(_,_)_STRING-COMMON_Int_String_String`(Source,ToCount)=>`_+Int_`(#token("1","Int"),`countAllOccurrences(_,_)_STRING-COMMON_Int_String_String`(`substrString(_,_,_)_STRING-COMMON_String_String_Int_Int`(Source,`_+Int_`(`findString(_,_,_)_STRING-COMMON_Int_String_String_Int`(Source,ToCount,#token("0","Int")),`lengthString(_)_STRING-COMMON_Int_String`(ToCount)),`lengthString(_)_STRING-COMMON_Int_String`(Source)),ToCount)) requires `_>=Int_`(`findString(_,_,_)_STRING-COMMON_Int_String_String_Int`(Source,ToCount,#token("0","Int")),#token("0","Int")) ensures #token("true","Bool") [UNIQUE_ID(628cff029a6d79e4c99999c0309f91ab8cb12f0ba549bb3faa850f96304c970e), contentStartColumn(8), contentStartLine(1560), org.kframework.attributes.Location(Location(1560,8,1561,60)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody "requires" Bool [klabel(#ruleRequires), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \equals{SortBool{},R}(
        Lbl'Unds-GT-Eqls'Int'Unds'{}(LblfindString'LParUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'Int'Unds'String'Unds'String'Unds'Int{}(VarSource:SortString{},VarToCount:SortString{},\dv{SortInt{}}("0")),\dv{SortInt{}}("0")),
        \dv{SortBool{}}("true")),
      \and{R} (
          \in{SortString{}, R} (
            X0:SortString{},
            VarSource:SortString{}
          ),\and{R} (
          \in{SortString{}, R} (
            X1:SortString{},
            VarToCount:SortString{}
          ),
          \top{R} ()
        ))),
    \and{R} (
      \equals{SortInt{},R} (
        LblcountAllOccurrences'LParUndsCommUndsRParUnds'STRING-COMMON'Unds'Int'Unds'String'Unds'String{}(X0:SortString{},X1:SortString{}),
        Lbl'UndsPlus'Int'Unds'{}(\dv{SortInt{}}("1"),LblcountAllOccurrences'LParUndsCommUndsRParUnds'STRING-COMMON'Unds'Int'Unds'String'Unds'String{}(LblsubstrString'LParUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'String'Unds'String'Unds'Int'Unds'Int{}(VarSource:SortString{},Lbl'UndsPlus'Int'Unds'{}(LblfindString'LParUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'Int'Unds'String'Unds'String'Unds'Int{}(VarSource:SortString{},VarToCount:SortString{},\dv{SortInt{}}("0")),LbllengthString'LParUndsRParUnds'STRING-COMMON'Unds'Int'Unds'String{}(VarToCount:SortString{})),LbllengthString'LParUndsRParUnds'STRING-COMMON'Unds'Int'Unds'String{}(VarSource:SortString{})),VarToCount:SortString{}))),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody \"requires\" Bool [klabel(#ruleRequires), symbol]"), contentStartLine{}("1560"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1560,8,1561,60)"), UNIQUE'Unds'ID{}("628cff029a6d79e4c99999c0309f91ab8cb12f0ba549bb3faa850f96304c970e")]

// rule `countAllOccurrences(_,_)_STRING-COMMON_Int_String_String`(Source,ToCount)=>#token("0","Int") requires `_<Int_`(`findString(_,_,_)_STRING-COMMON_Int_String_String_Int`(Source,ToCount,#token("0","Int")),#token("0","Int")) ensures #token("true","Bool") [UNIQUE_ID(1c726cd81629c2e5f411539a7f9b4d297e8600e5d71a5d235d287e3001f3ec84), contentStartColumn(8), contentStartLine(1558), org.kframework.attributes.Location(Location(1558,8,1559,59)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody "requires" Bool [klabel(#ruleRequires), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \equals{SortBool{},R}(
        Lbl'Unds-LT-'Int'Unds'{}(LblfindString'LParUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'Int'Unds'String'Unds'String'Unds'Int{}(VarSource:SortString{},VarToCount:SortString{},\dv{SortInt{}}("0")),\dv{SortInt{}}("0")),
        \dv{SortBool{}}("true")),
      \and{R} (
          \in{SortString{}, R} (
            X0:SortString{},
            VarSource:SortString{}
          ),\and{R} (
          \in{SortString{}, R} (
            X1:SortString{},
            VarToCount:SortString{}
          ),
          \top{R} ()
        ))),
    \and{R} (
      \equals{SortInt{},R} (
        LblcountAllOccurrences'LParUndsCommUndsRParUnds'STRING-COMMON'Unds'Int'Unds'String'Unds'String{}(X0:SortString{},X1:SortString{}),
        \dv{SortInt{}}("0")),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody \"requires\" Bool [klabel(#ruleRequires), symbol]"), contentStartLine{}("1558"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1558,8,1559,59)"), UNIQUE'Unds'ID{}("1c726cd81629c2e5f411539a7f9b4d297e8600e5d71a5d235d287e3001f3ec84")]

// rule `findChar(_,_,_)_STRING-COMMON_Int_String_String_Int`(S1,S2,I)=>`#if_#then_#else_#fi_K-EQUAL-SYNTAX_Sort_Bool_Sort_Sort`{Int}(`_==Int_`(`findString(_,_,_)_STRING-COMMON_Int_String_String_Int`(S1,`substrString(_,_,_)_STRING-COMMON_String_String_Int_Int`(S2,#token("0","Int"),#token("1","Int")),I),#token("-1","Int")),`findChar(_,_,_)_STRING-COMMON_Int_String_String_Int`(S1,`substrString(_,_,_)_STRING-COMMON_String_String_Int_Int`(S2,#token("1","Int"),`lengthString(_)_STRING-COMMON_Int_String`(S2)),I),`#if_#then_#else_#fi_K-EQUAL-SYNTAX_Sort_Bool_Sort_Sort`{Int}(`_==Int_`(`findChar(_,_,_)_STRING-COMMON_Int_String_String_Int`(S1,`substrString(_,_,_)_STRING-COMMON_String_String_Int_Int`(S2,#token("1","Int"),`lengthString(_)_STRING-COMMON_Int_String`(S2)),I),#token("-1","Int")),`findString(_,_,_)_STRING-COMMON_Int_String_String_Int`(S1,`substrString(_,_,_)_STRING-COMMON_String_String_Int_Int`(S2,#token("0","Int"),#token("1","Int")),I),`minInt(_,_)_INT-COMMON_Int_Int_Int`(`findString(_,_,_)_STRING-COMMON_Int_String_String_Int`(S1,`substrString(_,_,_)_STRING-COMMON_String_String_Int_Int`(S2,#token("0","Int"),#token("1","Int")),I),`findChar(_,_,_)_STRING-COMMON_Int_String_String_Int`(S1,`substrString(_,_,_)_STRING-COMMON_String_String_Int_Int`(S2,#token("1","Int"),`lengthString(_)_STRING-COMMON_Int_String`(S2)),I)))) requires `_=/=String__STRING-COMMON_Bool_String_String`(S2,#token("\"\"","String")) ensures #token("true","Bool") [UNIQUE_ID(9a3b7d1924363894c859ceb6bcec34fb944f01a5e0c90679d41b8430990b7295), contentStartColumn(8), contentStartLine(1553), org.kframework.attributes.Location(Location(1553,8,1553,431)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody "requires" Bool [klabel(#ruleRequires), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \equals{SortBool{},R}(
        Lbl'UndsEqlsSlshEqls'String'UndsUnds'STRING-COMMON'Unds'Bool'Unds'String'Unds'String{}(VarS2:SortString{},\dv{SortString{}}("")),
        \dv{SortBool{}}("true")),
      \and{R} (
          \in{SortString{}, R} (
            X0:SortString{},
            VarS1:SortString{}
          ),\and{R} (
          \in{SortString{}, R} (
            X1:SortString{},
            VarS2:SortString{}
          ),\and{R} (
          \in{SortInt{}, R} (
            X2:SortInt{},
            VarI:SortInt{}
          ),
          \top{R} ()
        )))),
    \and{R} (
      \equals{SortInt{},R} (
        LblfindChar'LParUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'Int'Unds'String'Unds'String'Unds'Int{}(X0:SortString{},X1:SortString{},X2:SortInt{}),
        Lbl'Hash'if'UndsHash'then'UndsHash'else'UndsHash'fi'Unds'K-EQUAL-SYNTAX'Unds'Sort'Unds'Bool'Unds'Sort'Unds'Sort{SortInt{}}(Lbl'UndsEqlsEqls'Int'Unds'{}(LblfindString'LParUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'Int'Unds'String'Unds'String'Unds'Int{}(VarS1:SortString{},LblsubstrString'LParUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'String'Unds'String'Unds'Int'Unds'Int{}(VarS2:SortString{},\dv{SortInt{}}("0"),\dv{SortInt{}}("1")),VarI:SortInt{}),\dv{SortInt{}}("-1")),LblfindChar'LParUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'Int'Unds'String'Unds'String'Unds'Int{}(VarS1:SortString{},LblsubstrString'LParUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'String'Unds'String'Unds'Int'Unds'Int{}(VarS2:SortString{},\dv{SortInt{}}("1"),LbllengthString'LParUndsRParUnds'STRING-COMMON'Unds'Int'Unds'String{}(VarS2:SortString{})),VarI:SortInt{}),Lbl'Hash'if'UndsHash'then'UndsHash'else'UndsHash'fi'Unds'K-EQUAL-SYNTAX'Unds'Sort'Unds'Bool'Unds'Sort'Unds'Sort{SortInt{}}(Lbl'UndsEqlsEqls'Int'Unds'{}(LblfindChar'LParUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'Int'Unds'String'Unds'String'Unds'Int{}(VarS1:SortString{},LblsubstrString'LParUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'String'Unds'String'Unds'Int'Unds'Int{}(VarS2:SortString{},\dv{SortInt{}}("1"),LbllengthString'LParUndsRParUnds'STRING-COMMON'Unds'Int'Unds'String{}(VarS2:SortString{})),VarI:SortInt{}),\dv{SortInt{}}("-1")),LblfindString'LParUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'Int'Unds'String'Unds'String'Unds'Int{}(VarS1:SortString{},LblsubstrString'LParUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'String'Unds'String'Unds'Int'Unds'Int{}(VarS2:SortString{},\dv{SortInt{}}("0"),\dv{SortInt{}}("1")),VarI:SortInt{}),LblminInt'LParUndsCommUndsRParUnds'INT-COMMON'Unds'Int'Unds'Int'Unds'Int{}(LblfindString'LParUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'Int'Unds'String'Unds'String'Unds'Int{}(VarS1:SortString{},LblsubstrString'LParUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'String'Unds'String'Unds'Int'Unds'Int{}(VarS2:SortString{},\dv{SortInt{}}("0"),\dv{SortInt{}}("1")),VarI:SortInt{}),LblfindChar'LParUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'Int'Unds'String'Unds'String'Unds'Int{}(VarS1:SortString{},LblsubstrString'LParUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'String'Unds'String'Unds'Int'Unds'Int{}(VarS2:SortString{},\dv{SortInt{}}("1"),LbllengthString'LParUndsRParUnds'STRING-COMMON'Unds'Int'Unds'String{}(VarS2:SortString{})),VarI:SortInt{}))))),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody \"requires\" Bool [klabel(#ruleRequires), symbol]"), contentStartLine{}("1553"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1553,8,1553,431)"), UNIQUE'Unds'ID{}("9a3b7d1924363894c859ceb6bcec34fb944f01a5e0c90679d41b8430990b7295")]

// rule `findChar(_,_,_)_STRING-COMMON_Int_String_String_Int`(_0,#token("\"\"","String"),_1)=>#token("-1","Int") requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(5a6cf981f0ec2494854cd3e517b0cf645a1c9762c92a14849adfca9a6a553117), contentStartColumn(8), contentStartLine(1554), org.kframework.attributes.Location(Location(1554,8,1554,32)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortString{}, R} (
            X0:SortString{},
            Var'Unds'0:SortString{}
          ),\and{R} (
          \in{SortString{}, R} (
            X1:SortString{},
            \dv{SortString{}}("")
          ),\and{R} (
          \in{SortInt{}, R} (
            X2:SortInt{},
            Var'Unds'1:SortInt{}
          ),
          \top{R} ()
        )))),
    \and{R} (
      \equals{SortInt{},R} (
        LblfindChar'LParUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'Int'Unds'String'Unds'String'Unds'Int{}(X0:SortString{},X1:SortString{},X2:SortInt{}),
        \dv{SortInt{}}("-1")),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("1554"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1554,8,1554,32)"), UNIQUE'Unds'ID{}("5a6cf981f0ec2494854cd3e517b0cf645a1c9762c92a14849adfca9a6a553117")]

// rule `freshId(_)_ID-COMMON_Id_Int`(I)=>`String2Id(_)_ID-COMMON_Id_String`(`_+String__STRING-COMMON_String_String_String`(#token("\"_\"","String"),`Int2String(_)_STRING-COMMON_String_Int`(I))) requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(3965c8e65257ebae926d601fa8ac672d34e4c211d73ba594c571c6bc5960f3de), contentStartColumn(8), contentStartLine(1991), org.kframework.attributes.Location(Location(1991,8,1991,62)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortInt{}, R} (
            X0:SortInt{},
            VarI:SortInt{}
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortId{},R} (
        LblfreshId'LParUndsRParUnds'ID-COMMON'Unds'Id'Unds'Int{}(X0:SortInt{}),
        LblString2Id'LParUndsRParUnds'ID-COMMON'Unds'Id'Unds'String{}(Lbl'UndsPlus'String'UndsUnds'STRING-COMMON'Unds'String'Unds'String'Unds'String{}(\dv{SortString{}}("_"),LblInt2String'LParUndsRParUnds'STRING-COMMON'Unds'String'Unds'Int{}(VarI:SortInt{})))),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("1991"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1991,8,1991,62)"), UNIQUE'Unds'ID{}("3965c8e65257ebae926d601fa8ac672d34e4c211d73ba594c571c6bc5960f3de")]

// rule `freshInt(_)_INT_Int_Int`(I)=>I requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(cf2cb8f038b4bdc4edb1334a3b8ced9cd296a7af43f0a1916e082a4e1aefa08b), contentStartColumn(8), contentStartLine(1120), org.kframework.attributes.Location(Location(1120,8,1120,28)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortInt{}, R} (
            X0:SortInt{},
            VarI:SortInt{}
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortInt{},R} (
        LblfreshInt'LParUndsRParUnds'INT'Unds'Int'Unds'Int{}(X0:SortInt{}),
        VarI:SortInt{}),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("1120"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1120,8,1120,28)"), UNIQUE'Unds'ID{}("cf2cb8f038b4bdc4edb1334a3b8ced9cd296a7af43f0a1916e082a4e1aefa08b")]

// rule getGeneratedCounterCell(`<generatedTop>`(_DotVar0,Cell))=>Cell requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortGeneratedTopCell{}, R} (
            X0:SortGeneratedTopCell{},
            Lbl'-LT-'generatedTop'-GT-'{}(Var'Unds'DotVar0:SortTCell{},VarCell:SortGeneratedCounterCell{})
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortGeneratedCounterCell{},R} (
        LblgetGeneratedCounterCell{}(X0:SortGeneratedTopCell{}),
        VarCell:SortGeneratedCounterCell{}),
      \top{R}()))
  []

// rule initGeneratedCounterCell(.KList)=>`<generatedCounter>`(#token("0","Int")) requires #token("true","Bool") ensures #token("true","Bool") [initializer]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      
          \top{R} ()
        ),
    \and{R} (
      \equals{SortGeneratedCounterCell{},R} (
        LblinitGeneratedCounterCell{}(),
        Lbl'-LT-'generatedCounter'-GT-'{}(\dv{SortInt{}}("0"))),
      \top{R}()))
  [initializer{}()]

// rule initGeneratedTopCell(Init)=>`<generatedTop>`(initTCell(Init),initGeneratedCounterCell(.KList)) requires #token("true","Bool") ensures #token("true","Bool") [initializer]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortMap{}, R} (
            X0:SortMap{},
            VarInit:SortMap{}
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortGeneratedTopCell{},R} (
        LblinitGeneratedTopCell{}(X0:SortMap{}),
        Lbl'-LT-'generatedTop'-GT-'{}(LblinitTCell{}(VarInit:SortMap{}),LblinitGeneratedCounterCell{}())),
      \top{R}()))
  [initializer{}()]

// rule initKCell(Init)=>`<k>`(inj{TranslationUnit,KItem}(`project:TranslationUnit`(`Map:lookup`(Init,inj{KConfigVar,KItem}(#token("$PGM","KConfigVar")))))) requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(842b0b336fa2c8aa7481d363821d5d62720b8e1539e4fa1807d12d905a2e9c39), initializer]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortMap{}, R} (
            X0:SortMap{},
            VarInit:SortMap{}
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortKCell{},R} (
        LblinitKCell{}(X0:SortMap{}),
        Lbl'-LT-'k'-GT-'{}(kseq{}(inj{SortTranslationUnit{}, SortKItem{}}(Lblproject'Coln'TranslationUnit{}(kseq{}(LblMap'Coln'lookup{}(VarInit:SortMap{},inj{SortKConfigVar{}, SortKItem{}}(\dv{SortKConfigVar{}}("$PGM"))),dotk{}()))),dotk{}()))),
      \top{R}()))
  [initializer{}(), UNIQUE'Unds'ID{}("842b0b336fa2c8aa7481d363821d5d62720b8e1539e4fa1807d12d905a2e9c39")]

// rule initOslCell(.KList)=>`<osl>`(.K) requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(1311d8babbe79a26cdb1cff685b721797666795149ff562a5104b17b94fe64c1), initializer]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      
          \top{R} ()
        ),
    \and{R} (
      \equals{SortOslCell{},R} (
        LblinitOslCell{}(),
        Lbl'-LT-'osl'-GT-'{}(dotk{}())),
      \top{R}()))
  [initializer{}(), UNIQUE'Unds'ID{}("1311d8babbe79a26cdb1cff685b721797666795149ff562a5104b17b94fe64c1")]

// rule initTCell(Init)=>`<T>`(initKCell(Init),initOslCell(.KList)) requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(42fd3ceef559518cae6cb3bc717b3f7f2bb2ff115b0d4423f0ff8823c3fd7edc), initializer]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortMap{}, R} (
            X0:SortMap{},
            VarInit:SortMap{}
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortTCell{},R} (
        LblinitTCell{}(X0:SortMap{}),
        Lbl'-LT-'T'-GT-'{}(LblinitKCell{}(VarInit:SortMap{}),LblinitOslCell{}())),
      \top{R}()))
  [initializer{}(), UNIQUE'Unds'ID{}("42fd3ceef559518cae6cb3bc717b3f7f2bb2ff115b0d4423f0ff8823c3fd7edc")]

// rule isAbstractDeclarator(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortAbstractDeclarator{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortAbstractDeclarator{}, SortKItem{}}(Var'Unds'1:SortAbstractDeclarator{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisAbstractDeclarator{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isAbstractDeclarator(inj{AbstractDeclarator,KItem}(AbstractDeclarator))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortAbstractDeclarator{}, SortKItem{}}(VarAbstractDeclarator:SortAbstractDeclarator{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisAbstractDeclarator{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isAdditiveExpression(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortAdditiveExpression{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortAdditiveExpression{}, SortKItem{}}(Var'Unds'1:SortAdditiveExpression{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisAdditiveExpression{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isAdditiveExpression(inj{AdditiveExpression,KItem}(AdditiveExpression))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortAdditiveExpression{}, SortKItem{}}(VarAdditiveExpression:SortAdditiveExpression{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisAdditiveExpression{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isAndExpression(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortAndExpression{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortAndExpression{}, SortKItem{}}(Var'Unds'1:SortAndExpression{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisAndExpression{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isAndExpression(inj{AndExpression,KItem}(AndExpression))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortAndExpression{}, SortKItem{}}(VarAndExpression:SortAndExpression{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisAndExpression{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isAssignmentExpression(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortAssignmentExpression{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortAssignmentExpression{}, SortKItem{}}(Var'Unds'1:SortAssignmentExpression{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisAssignmentExpression{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isAssignmentExpression(inj{AssignmentExpression,KItem}(AssignmentExpression))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortAssignmentExpression{}, SortKItem{}}(VarAssignmentExpression:SortAssignmentExpression{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisAssignmentExpression{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isAssignmentOperator(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'0:SortAssignmentOperator{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortAssignmentOperator{}, SortKItem{}}(Var'Unds'0:SortAssignmentOperator{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisAssignmentOperator{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isAssignmentOperator(inj{AssignmentOperator,KItem}(AssignmentOperator))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortAssignmentOperator{}, SortKItem{}}(VarAssignmentOperator:SortAssignmentOperator{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisAssignmentOperator{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isBool(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'0:SortBool{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortBool{}, SortKItem{}}(Var'Unds'0:SortBool{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisBool{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isBool(inj{Bool,KItem}(Bool))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortBool{}, SortKItem{}}(VarBool:SortBool{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisBool{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isCastExpression(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortCastExpression{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortCastExpression{}, SortKItem{}}(Var'Unds'1:SortCastExpression{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisCastExpression{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isCastExpression(inj{CastExpression,KItem}(CastExpression))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortCastExpression{}, SortKItem{}}(VarCastExpression:SortCastExpression{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisCastExpression{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isCompoundStatement(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortCompoundStatement{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortCompoundStatement{}, SortKItem{}}(Var'Unds'1:SortCompoundStatement{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisCompoundStatement{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isCompoundStatement(inj{CompoundStatement,KItem}(CompoundStatement))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortCompoundStatement{}, SortKItem{}}(VarCompoundStatement:SortCompoundStatement{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisCompoundStatement{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isConditionalExpression(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortConditionalExpression{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortConditionalExpression{}, SortKItem{}}(Var'Unds'1:SortConditionalExpression{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisConditionalExpression{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isConditionalExpression(inj{ConditionalExpression,KItem}(ConditionalExpression))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortConditionalExpression{}, SortKItem{}}(VarConditionalExpression:SortConditionalExpression{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisConditionalExpression{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isConstant(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortConstant{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortConstant{}, SortKItem{}}(Var'Unds'1:SortConstant{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisConstant{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isConstant(inj{Constant,KItem}(Constant))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortConstant{}, SortKItem{}}(VarConstant:SortConstant{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisConstant{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isConstantExpression(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'0:SortConstantExpression{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortConstantExpression{}, SortKItem{}}(Var'Unds'0:SortConstantExpression{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisConstantExpression{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isConstantExpression(inj{ConstantExpression,KItem}(ConstantExpression))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortConstantExpression{}, SortKItem{}}(VarConstantExpression:SortConstantExpression{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisConstantExpression{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isDeclaration(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortDeclaration{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortDeclaration{}, SortKItem{}}(Var'Unds'1:SortDeclaration{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisDeclaration{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isDeclaration(inj{Declaration,KItem}(Declaration))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortDeclaration{}, SortKItem{}}(VarDeclaration:SortDeclaration{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisDeclaration{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isDeclarationSpecifier(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortDeclarationSpecifier{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortDeclarationSpecifier{}, SortKItem{}}(Var'Unds'1:SortDeclarationSpecifier{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisDeclarationSpecifier{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isDeclarationSpecifier(inj{DeclarationSpecifier,KItem}(DeclarationSpecifier))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortDeclarationSpecifier{}, SortKItem{}}(VarDeclarationSpecifier:SortDeclarationSpecifier{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisDeclarationSpecifier{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isDeclarator(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortDeclarator{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortDeclarator{}, SortKItem{}}(Var'Unds'1:SortDeclarator{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisDeclarator{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isDeclarator(inj{Declarator,KItem}(Declarator))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortDeclarator{}, SortKItem{}}(VarDeclarator:SortDeclarator{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisDeclarator{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isDirectAbstractDeclarator(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortDirectAbstractDeclarator{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortDirectAbstractDeclarator{}, SortKItem{}}(Var'Unds'1:SortDirectAbstractDeclarator{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisDirectAbstractDeclarator{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isDirectAbstractDeclarator(inj{DirectAbstractDeclarator,KItem}(DirectAbstractDeclarator))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortDirectAbstractDeclarator{}, SortKItem{}}(VarDirectAbstractDeclarator:SortDirectAbstractDeclarator{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisDirectAbstractDeclarator{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isDirectDeclarator(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortDirectDeclarator{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortDirectDeclarator{}, SortKItem{}}(Var'Unds'1:SortDirectDeclarator{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisDirectDeclarator{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isDirectDeclarator(inj{DirectDeclarator,KItem}(DirectDeclarator))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortDirectDeclarator{}, SortKItem{}}(VarDirectDeclarator:SortDirectDeclarator{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisDirectDeclarator{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isEnumOfspecifier(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortEnumOfspecifier{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortEnumOfspecifier{}, SortKItem{}}(Var'Unds'1:SortEnumOfspecifier{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisEnumOfspecifier{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isEnumOfspecifier(inj{EnumOfspecifier,KItem}(EnumOfspecifier))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortEnumOfspecifier{}, SortKItem{}}(VarEnumOfspecifier:SortEnumOfspecifier{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisEnumOfspecifier{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isEnumerationConstant(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortEnumerationConstant{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortEnumerationConstant{}, SortKItem{}}(Var'Unds'1:SortEnumerationConstant{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisEnumerationConstant{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isEnumerationConstant(inj{EnumerationConstant,KItem}(EnumerationConstant))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortEnumerationConstant{}, SortKItem{}}(VarEnumerationConstant:SortEnumerationConstant{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisEnumerationConstant{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isEnumerator(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'0:SortEnumerator{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortEnumerator{}, SortKItem{}}(Var'Unds'0:SortEnumerator{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisEnumerator{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isEnumerator(inj{Enumerator,KItem}(Enumerator))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortEnumerator{}, SortKItem{}}(VarEnumerator:SortEnumerator{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisEnumerator{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isEnumeratorList(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortEnumeratorList{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortEnumeratorList{}, SortKItem{}}(Var'Unds'1:SortEnumeratorList{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisEnumeratorList{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isEnumeratorList(inj{EnumeratorList,KItem}(EnumeratorList))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortEnumeratorList{}, SortKItem{}}(VarEnumeratorList:SortEnumeratorList{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisEnumeratorList{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isEqualityExpression(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortEqualityExpression{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortEqualityExpression{}, SortKItem{}}(Var'Unds'1:SortEqualityExpression{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisEqualityExpression{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isEqualityExpression(inj{EqualityExpression,KItem}(EqualityExpression))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortEqualityExpression{}, SortKItem{}}(VarEqualityExpression:SortEqualityExpression{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisEqualityExpression{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isExclusiveOforExpression(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortExclusiveOforExpression{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortExclusiveOforExpression{}, SortKItem{}}(Var'Unds'1:SortExclusiveOforExpression{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisExclusiveOforExpression{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isExclusiveOforExpression(inj{ExclusiveOforExpression,KItem}(ExclusiveOforExpression))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortExclusiveOforExpression{}, SortKItem{}}(VarExclusiveOforExpression:SortExclusiveOforExpression{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisExclusiveOforExpression{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isExpression(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'0:SortExpression{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortExpression{}, SortKItem{}}(Var'Unds'0:SortExpression{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisExpression{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isExpression(inj{Expression,KItem}(Expression))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortExpression{}, SortKItem{}}(VarExpression:SortExpression{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisExpression{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isExpressionStatement(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'0:SortExpressionStatement{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortExpressionStatement{}, SortKItem{}}(Var'Unds'0:SortExpressionStatement{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisExpressionStatement{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isExpressionStatement(inj{ExpressionStatement,KItem}(ExpressionStatement))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortExpressionStatement{}, SortKItem{}}(VarExpressionStatement:SortExpressionStatement{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisExpressionStatement{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isExternalDeclaration(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'0:SortExternalDeclaration{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortExternalDeclaration{}, SortKItem{}}(Var'Unds'0:SortExternalDeclaration{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisExternalDeclaration{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isExternalDeclaration(inj{ExternalDeclaration,KItem}(ExternalDeclaration))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortExternalDeclaration{}, SortKItem{}}(VarExternalDeclaration:SortExternalDeclaration{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisExternalDeclaration{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isFloat(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortFloat{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortFloat{}, SortKItem{}}(Var'Unds'1:SortFloat{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisFloat{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isFloat(inj{Float,KItem}(Float))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortFloat{}, SortKItem{}}(VarFloat:SortFloat{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisFloat{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isFunctionDefinition(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'0:SortFunctionDefinition{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortFunctionDefinition{}, SortKItem{}}(Var'Unds'0:SortFunctionDefinition{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisFunctionDefinition{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isFunctionDefinition(inj{FunctionDefinition,KItem}(FunctionDefinition))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortFunctionDefinition{}, SortKItem{}}(VarFunctionDefinition:SortFunctionDefinition{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisFunctionDefinition{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isGeneratedCounterCell(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'0:SortGeneratedCounterCell{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortGeneratedCounterCell{}, SortKItem{}}(Var'Unds'0:SortGeneratedCounterCell{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisGeneratedCounterCell{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isGeneratedCounterCell(inj{GeneratedCounterCell,KItem}(GeneratedCounterCell))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortGeneratedCounterCell{}, SortKItem{}}(VarGeneratedCounterCell:SortGeneratedCounterCell{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisGeneratedCounterCell{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isGeneratedCounterCellOpt(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'0:SortGeneratedCounterCellOpt{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortGeneratedCounterCellOpt{}, SortKItem{}}(Var'Unds'0:SortGeneratedCounterCellOpt{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisGeneratedCounterCellOpt{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isGeneratedCounterCellOpt(inj{GeneratedCounterCellOpt,KItem}(GeneratedCounterCellOpt))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortGeneratedCounterCellOpt{}, SortKItem{}}(VarGeneratedCounterCellOpt:SortGeneratedCounterCellOpt{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisGeneratedCounterCellOpt{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isGeneratedTopCell(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortGeneratedTopCell{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortGeneratedTopCell{}, SortKItem{}}(Var'Unds'1:SortGeneratedTopCell{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisGeneratedTopCell{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isGeneratedTopCell(inj{GeneratedTopCell,KItem}(GeneratedTopCell))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortGeneratedTopCell{}, SortKItem{}}(VarGeneratedTopCell:SortGeneratedTopCell{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisGeneratedTopCell{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isGeneratedTopCellFragment(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'0:SortGeneratedTopCellFragment{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortGeneratedTopCellFragment{}, SortKItem{}}(Var'Unds'0:SortGeneratedTopCellFragment{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisGeneratedTopCellFragment{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isGeneratedTopCellFragment(inj{GeneratedTopCellFragment,KItem}(GeneratedTopCellFragment))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortGeneratedTopCellFragment{}, SortKItem{}}(VarGeneratedTopCellFragment:SortGeneratedTopCellFragment{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisGeneratedTopCellFragment{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isIOError(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortIOError{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortIOError{}, SortKItem{}}(Var'Unds'1:SortIOError{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisIOError{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isIOError(inj{IOError,KItem}(IOError))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortIOError{}, SortKItem{}}(VarIOError:SortIOError{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisIOError{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isIOFile(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortIOFile{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortIOFile{}, SortKItem{}}(Var'Unds'1:SortIOFile{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisIOFile{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isIOFile(inj{IOFile,KItem}(IOFile))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortIOFile{}, SortKItem{}}(VarIOFile:SortIOFile{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisIOFile{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isIOInt(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortIOInt{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortIOInt{}, SortKItem{}}(Var'Unds'1:SortIOInt{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisIOInt{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isIOInt(inj{IOInt,KItem}(IOInt))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortIOInt{}, SortKItem{}}(VarIOInt:SortIOInt{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisIOInt{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isIOString(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortIOString{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortIOString{}, SortKItem{}}(Var'Unds'1:SortIOString{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisIOString{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isIOString(inj{IOString,KItem}(IOString))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortIOString{}, SortKItem{}}(VarIOString:SortIOString{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisIOString{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isId(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortId{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortId{}, SortKItem{}}(Var'Unds'1:SortId{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisId{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isId(inj{Id,KItem}(Id))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortId{}, SortKItem{}}(VarId:SortId{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisId{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isIds(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortIds{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortIds{}, SortKItem{}}(Var'Unds'1:SortIds{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisIds{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isIds(inj{Ids,KItem}(Ids))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortIds{}, SortKItem{}}(VarIds:SortIds{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisIds{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isInclusiveOforExpression(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortInclusiveOforExpression{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortInclusiveOforExpression{}, SortKItem{}}(Var'Unds'1:SortInclusiveOforExpression{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisInclusiveOforExpression{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isInclusiveOforExpression(inj{InclusiveOforExpression,KItem}(InclusiveOforExpression))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortInclusiveOforExpression{}, SortKItem{}}(VarInclusiveOforExpression:SortInclusiveOforExpression{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisInclusiveOforExpression{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isInitdeclarator(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'0:SortInitdeclarator{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortInitdeclarator{}, SortKItem{}}(Var'Unds'0:SortInitdeclarator{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisInitdeclarator{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isInitdeclarator(inj{Initdeclarator,KItem}(Initdeclarator))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortInitdeclarator{}, SortKItem{}}(VarInitdeclarator:SortInitdeclarator{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisInitdeclarator{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isInitializer(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'0:SortInitializer{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortInitializer{}, SortKItem{}}(Var'Unds'0:SortInitializer{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisInitializer{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isInitializer(inj{Initializer,KItem}(Initializer))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortInitializer{}, SortKItem{}}(VarInitializer:SortInitializer{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisInitializer{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isInitializerList(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortInitializerList{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortInitializerList{}, SortKItem{}}(Var'Unds'1:SortInitializerList{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisInitializerList{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isInitializerList(inj{InitializerList,KItem}(InitializerList))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortInitializerList{}, SortKItem{}}(VarInitializerList:SortInitializerList{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisInitializerList{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isInt(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'0:SortInt{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortInt{}, SortKItem{}}(Var'Unds'0:SortInt{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisInt{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isInt(inj{Int,KItem}(Int))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortInt{}, SortKItem{}}(VarInt:SortInt{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisInt{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isIterationStatement(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortIterationStatement{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortIterationStatement{}, SortKItem{}}(Var'Unds'1:SortIterationStatement{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisIterationStatement{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isIterationStatement(inj{IterationStatement,KItem}(IterationStatement))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortIterationStatement{}, SortKItem{}}(VarIterationStatement:SortIterationStatement{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisIterationStatement{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isJumpStatement(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortJumpStatement{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortJumpStatement{}, SortKItem{}}(Var'Unds'1:SortJumpStatement{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisJumpStatement{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isJumpStatement(inj{JumpStatement,KItem}(JumpStatement))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortJumpStatement{}, SortKItem{}}(VarJumpStatement:SortJumpStatement{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisJumpStatement{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isK(K)=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisK{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isKCell(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortKCell{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortKCell{}, SortKItem{}}(Var'Unds'1:SortKCell{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisKCell{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isKCell(inj{KCell,KItem}(KCell))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortKCell{}, SortKItem{}}(VarKCell:SortKCell{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisKCell{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isKCellOpt(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortKCellOpt{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortKCellOpt{}, SortKItem{}}(Var'Unds'1:SortKCellOpt{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisKCellOpt{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isKCellOpt(inj{KCellOpt,KItem}(KCellOpt))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortKCellOpt{}, SortKItem{}}(VarKCellOpt:SortKCellOpt{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisKCellOpt{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isKConfigVar(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortKConfigVar{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortKConfigVar{}, SortKItem{}}(Var'Unds'1:SortKConfigVar{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisKConfigVar{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isKConfigVar(inj{KConfigVar,KItem}(KConfigVar))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortKConfigVar{}, SortKItem{}}(VarKConfigVar:SortKConfigVar{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisKConfigVar{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isKItem(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'0:SortKItem{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(Var'Unds'0:SortKItem{},dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisKItem{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isKItem(KItem)=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(VarKItem:SortKItem{},dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisKItem{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isLabeledStatement(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortLabeledStatement{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortLabeledStatement{}, SortKItem{}}(Var'Unds'1:SortLabeledStatement{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisLabeledStatement{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isLabeledStatement(inj{LabeledStatement,KItem}(LabeledStatement))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortLabeledStatement{}, SortKItem{}}(VarLabeledStatement:SortLabeledStatement{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisLabeledStatement{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isList(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'0:SortList{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortList{}, SortKItem{}}(Var'Unds'0:SortList{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisList{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isList(inj{List,KItem}(List))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortList{}, SortKItem{}}(VarList:SortList{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisList{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isListAssignmentExpression(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortListAssignmentExpression{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortListAssignmentExpression{}, SortKItem{}}(Var'Unds'1:SortListAssignmentExpression{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisListAssignmentExpression{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isListAssignmentExpression(inj{ListAssignmentExpression,KItem}(ListAssignmentExpression))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortListAssignmentExpression{}, SortKItem{}}(VarListAssignmentExpression:SortListAssignmentExpression{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisListAssignmentExpression{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isListDeclaration(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'0:SortListDeclaration{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortListDeclaration{}, SortKItem{}}(Var'Unds'0:SortListDeclaration{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisListDeclaration{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isListDeclaration(inj{ListDeclaration,KItem}(ListDeclaration))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortListDeclaration{}, SortKItem{}}(VarListDeclaration:SortListDeclaration{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisListDeclaration{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isListDeclarationSpecifier(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortListDeclarationSpecifier{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortListDeclarationSpecifier{}, SortKItem{}}(Var'Unds'1:SortListDeclarationSpecifier{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisListDeclarationSpecifier{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isListDeclarationSpecifier(inj{ListDeclarationSpecifier,KItem}(ListDeclarationSpecifier))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortListDeclarationSpecifier{}, SortKItem{}}(VarListDeclarationSpecifier:SortListDeclarationSpecifier{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisListDeclarationSpecifier{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isListExternalDeclaration(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'0:SortListExternalDeclaration{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortListExternalDeclaration{}, SortKItem{}}(Var'Unds'0:SortListExternalDeclaration{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisListExternalDeclaration{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isListExternalDeclaration(inj{ListExternalDeclaration,KItem}(ListExternalDeclaration))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortListExternalDeclaration{}, SortKItem{}}(VarListExternalDeclaration:SortListExternalDeclaration{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisListExternalDeclaration{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isListInitDeclarator(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'0:SortListInitDeclarator{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortListInitDeclarator{}, SortKItem{}}(Var'Unds'0:SortListInitDeclarator{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisListInitDeclarator{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isListInitDeclarator(inj{ListInitDeclarator,KItem}(ListInitDeclarator))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortListInitDeclarator{}, SortKItem{}}(VarListInitDeclarator:SortListInitDeclarator{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisListInitDeclarator{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isListSpecifierQualifier(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortListSpecifierQualifier{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortListSpecifierQualifier{}, SortKItem{}}(Var'Unds'1:SortListSpecifierQualifier{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisListSpecifierQualifier{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isListSpecifierQualifier(inj{ListSpecifierQualifier,KItem}(ListSpecifierQualifier))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortListSpecifierQualifier{}, SortKItem{}}(VarListSpecifierQualifier:SortListSpecifierQualifier{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisListSpecifierQualifier{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isListStatement(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'0:SortListStatement{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortListStatement{}, SortKItem{}}(Var'Unds'0:SortListStatement{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisListStatement{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isListStatement(inj{ListStatement,KItem}(ListStatement))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortListStatement{}, SortKItem{}}(VarListStatement:SortListStatement{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisListStatement{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isListStructDeclaration(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'0:SortListStructDeclaration{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortListStructDeclaration{}, SortKItem{}}(Var'Unds'0:SortListStructDeclaration{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisListStructDeclaration{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isListStructDeclaration(inj{ListStructDeclaration,KItem}(ListStructDeclaration))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortListStructDeclaration{}, SortKItem{}}(VarListStructDeclaration:SortListStructDeclaration{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisListStructDeclaration{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isListTypeQualifier(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortListTypeQualifier{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortListTypeQualifier{}, SortKItem{}}(Var'Unds'1:SortListTypeQualifier{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisListTypeQualifier{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isListTypeQualifier(inj{ListTypeQualifier,KItem}(ListTypeQualifier))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortListTypeQualifier{}, SortKItem{}}(VarListTypeQualifier:SortListTypeQualifier{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisListTypeQualifier{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isLogicalOfandExpression(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortLogicalOfandExpression{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortLogicalOfandExpression{}, SortKItem{}}(Var'Unds'1:SortLogicalOfandExpression{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisLogicalOfandExpression{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isLogicalOfandExpression(inj{LogicalOfandExpression,KItem}(LogicalOfandExpression))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortLogicalOfandExpression{}, SortKItem{}}(VarLogicalOfandExpression:SortLogicalOfandExpression{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisLogicalOfandExpression{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isLogicalOforExpression(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortLogicalOforExpression{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortLogicalOforExpression{}, SortKItem{}}(Var'Unds'1:SortLogicalOforExpression{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisLogicalOforExpression{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isLogicalOforExpression(inj{LogicalOforExpression,KItem}(LogicalOforExpression))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortLogicalOforExpression{}, SortKItem{}}(VarLogicalOforExpression:SortLogicalOforExpression{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisLogicalOforExpression{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isMap(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortMap{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortMap{}, SortKItem{}}(Var'Unds'1:SortMap{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisMap{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isMap(inj{Map,KItem}(Map))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortMap{}, SortKItem{}}(VarMap:SortMap{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisMap{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isMultiplicativeExpression(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'0:SortMultiplicativeExpression{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortMultiplicativeExpression{}, SortKItem{}}(Var'Unds'0:SortMultiplicativeExpression{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisMultiplicativeExpression{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isMultiplicativeExpression(inj{MultiplicativeExpression,KItem}(MultiplicativeExpression))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortMultiplicativeExpression{}, SortKItem{}}(VarMultiplicativeExpression:SortMultiplicativeExpression{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisMultiplicativeExpression{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isOslCell(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'0:SortOslCell{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortOslCell{}, SortKItem{}}(Var'Unds'0:SortOslCell{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisOslCell{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isOslCell(inj{OslCell,KItem}(OslCell))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortOslCell{}, SortKItem{}}(VarOslCell:SortOslCell{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisOslCell{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isOslCellOpt(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortOslCellOpt{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortOslCellOpt{}, SortKItem{}}(Var'Unds'1:SortOslCellOpt{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisOslCellOpt{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isOslCellOpt(inj{OslCellOpt,KItem}(OslCellOpt))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortOslCellOpt{}, SortKItem{}}(VarOslCellOpt:SortOslCellOpt{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisOslCellOpt{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isParameterDeclaration(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'0:SortParameterDeclaration{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortParameterDeclaration{}, SortKItem{}}(Var'Unds'0:SortParameterDeclaration{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisParameterDeclaration{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isParameterDeclaration(inj{ParameterDeclaration,KItem}(ParameterDeclaration))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortParameterDeclaration{}, SortKItem{}}(VarParameterDeclaration:SortParameterDeclaration{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisParameterDeclaration{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isParameterList(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'0:SortParameterList{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortParameterList{}, SortKItem{}}(Var'Unds'0:SortParameterList{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisParameterList{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isParameterList(inj{ParameterList,KItem}(ParameterList))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortParameterList{}, SortKItem{}}(VarParameterList:SortParameterList{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisParameterList{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isParameterTypeList(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'0:SortParameterTypeList{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortParameterTypeList{}, SortKItem{}}(Var'Unds'0:SortParameterTypeList{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisParameterTypeList{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isParameterTypeList(inj{ParameterTypeList,KItem}(ParameterTypeList))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortParameterTypeList{}, SortKItem{}}(VarParameterTypeList:SortParameterTypeList{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisParameterTypeList{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isPointer(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortPointer{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortPointer{}, SortKItem{}}(Var'Unds'1:SortPointer{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisPointer{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isPointer(inj{Pointer,KItem}(Pointer))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortPointer{}, SortKItem{}}(VarPointer:SortPointer{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisPointer{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isPostfixExpression(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'0:SortPostfixExpression{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortPostfixExpression{}, SortKItem{}}(Var'Unds'0:SortPostfixExpression{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisPostfixExpression{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isPostfixExpression(inj{PostfixExpression,KItem}(PostfixExpression))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortPostfixExpression{}, SortKItem{}}(VarPostfixExpression:SortPostfixExpression{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisPostfixExpression{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isPrimaryExpression(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortPrimaryExpression{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortPrimaryExpression{}, SortKItem{}}(Var'Unds'1:SortPrimaryExpression{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisPrimaryExpression{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isPrimaryExpression(inj{PrimaryExpression,KItem}(PrimaryExpression))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortPrimaryExpression{}, SortKItem{}}(VarPrimaryExpression:SortPrimaryExpression{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisPrimaryExpression{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isRelationalExpression(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortRelationalExpression{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortRelationalExpression{}, SortKItem{}}(Var'Unds'1:SortRelationalExpression{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisRelationalExpression{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isRelationalExpression(inj{RelationalExpression,KItem}(RelationalExpression))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortRelationalExpression{}, SortKItem{}}(VarRelationalExpression:SortRelationalExpression{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisRelationalExpression{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isSelectionStatement(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'0:SortSelectionStatement{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortSelectionStatement{}, SortKItem{}}(Var'Unds'0:SortSelectionStatement{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisSelectionStatement{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isSelectionStatement(inj{SelectionStatement,KItem}(SelectionStatement))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortSelectionStatement{}, SortKItem{}}(VarSelectionStatement:SortSelectionStatement{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisSelectionStatement{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isSet(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortSet{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortSet{}, SortKItem{}}(Var'Unds'1:SortSet{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisSet{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isSet(inj{Set,KItem}(Set))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortSet{}, SortKItem{}}(VarSet:SortSet{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisSet{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isShiftExpression(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortShiftExpression{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortShiftExpression{}, SortKItem{}}(Var'Unds'1:SortShiftExpression{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisShiftExpression{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isShiftExpression(inj{ShiftExpression,KItem}(ShiftExpression))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortShiftExpression{}, SortKItem{}}(VarShiftExpression:SortShiftExpression{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisShiftExpression{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isSpecifierQualifier(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortSpecifierQualifier{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortSpecifierQualifier{}, SortKItem{}}(Var'Unds'1:SortSpecifierQualifier{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisSpecifierQualifier{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isSpecifierQualifier(inj{SpecifierQualifier,KItem}(SpecifierQualifier))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortSpecifierQualifier{}, SortKItem{}}(VarSpecifierQualifier:SortSpecifierQualifier{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisSpecifierQualifier{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isStatement(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortStatement{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortStatement{}, SortKItem{}}(Var'Unds'1:SortStatement{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisStatement{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isStatement(inj{Statement,KItem}(Statement))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortStatement{}, SortKItem{}}(VarStatement:SortStatement{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisStatement{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isStorageClassSpecifier(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortStorageClassSpecifier{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortStorageClassSpecifier{}, SortKItem{}}(Var'Unds'1:SortStorageClassSpecifier{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisStorageClassSpecifier{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isStorageClassSpecifier(inj{StorageClassSpecifier,KItem}(StorageClassSpecifier))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortStorageClassSpecifier{}, SortKItem{}}(VarStorageClassSpecifier:SortStorageClassSpecifier{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisStorageClassSpecifier{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isStream(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'0:SortStream{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortStream{}, SortKItem{}}(Var'Unds'0:SortStream{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisStream{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isStream(inj{Stream,KItem}(Stream))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortStream{}, SortKItem{}}(VarStream:SortStream{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisStream{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isString(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortString{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortString{}, SortKItem{}}(Var'Unds'1:SortString{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisString{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isString(inj{String,KItem}(String))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortString{}, SortKItem{}}(VarString:SortString{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisString{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isStructDeclaration(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'0:SortStructDeclaration{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortStructDeclaration{}, SortKItem{}}(Var'Unds'0:SortStructDeclaration{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisStructDeclaration{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isStructDeclaration(inj{StructDeclaration,KItem}(StructDeclaration))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortStructDeclaration{}, SortKItem{}}(VarStructDeclaration:SortStructDeclaration{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisStructDeclaration{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isStructDeclarator(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortStructDeclarator{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortStructDeclarator{}, SortKItem{}}(Var'Unds'1:SortStructDeclarator{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisStructDeclarator{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isStructDeclarator(inj{StructDeclarator,KItem}(StructDeclarator))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortStructDeclarator{}, SortKItem{}}(VarStructDeclarator:SortStructDeclarator{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisStructDeclarator{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isStructDeclaratorList(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'0:SortStructDeclaratorList{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortStructDeclaratorList{}, SortKItem{}}(Var'Unds'0:SortStructDeclaratorList{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisStructDeclaratorList{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isStructDeclaratorList(inj{StructDeclaratorList,KItem}(StructDeclaratorList))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortStructDeclaratorList{}, SortKItem{}}(VarStructDeclaratorList:SortStructDeclaratorList{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisStructDeclaratorList{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isStructOrFunionSpecifier(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'0:SortStructOrFunionSpecifier{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortStructOrFunionSpecifier{}, SortKItem{}}(Var'Unds'0:SortStructOrFunionSpecifier{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisStructOrFunionSpecifier{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isStructOrFunionSpecifier(inj{StructOrFunionSpecifier,KItem}(StructOrFunionSpecifier))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortStructOrFunionSpecifier{}, SortKItem{}}(VarStructOrFunionSpecifier:SortStructOrFunionSpecifier{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisStructOrFunionSpecifier{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isStructOrUnion(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortStructOrUnion{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortStructOrUnion{}, SortKItem{}}(Var'Unds'1:SortStructOrUnion{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisStructOrUnion{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isStructOrUnion(inj{StructOrUnion,KItem}(StructOrUnion))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortStructOrUnion{}, SortKItem{}}(VarStructOrUnion:SortStructOrUnion{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisStructOrUnion{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isTCell(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortTCell{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortTCell{}, SortKItem{}}(Var'Unds'1:SortTCell{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisTCell{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isTCell(inj{TCell,KItem}(TCell))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortTCell{}, SortKItem{}}(VarTCell:SortTCell{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisTCell{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isTCellFragment(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortTCellFragment{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortTCellFragment{}, SortKItem{}}(Var'Unds'1:SortTCellFragment{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisTCellFragment{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isTCellFragment(inj{TCellFragment,KItem}(TCellFragment))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortTCellFragment{}, SortKItem{}}(VarTCellFragment:SortTCellFragment{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisTCellFragment{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isTCellOpt(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'0:SortTCellOpt{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortTCellOpt{}, SortKItem{}}(Var'Unds'0:SortTCellOpt{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisTCellOpt{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isTCellOpt(inj{TCellOpt,KItem}(TCellOpt))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortTCellOpt{}, SortKItem{}}(VarTCellOpt:SortTCellOpt{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisTCellOpt{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isTranslationUnit(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortTranslationUnit{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortTranslationUnit{}, SortKItem{}}(Var'Unds'1:SortTranslationUnit{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisTranslationUnit{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isTranslationUnit(inj{TranslationUnit,KItem}(TranslationUnit))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortTranslationUnit{}, SortKItem{}}(VarTranslationUnit:SortTranslationUnit{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisTranslationUnit{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isTypeName(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortTypeName{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortTypeName{}, SortKItem{}}(Var'Unds'1:SortTypeName{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisTypeName{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isTypeName(inj{TypeName,KItem}(TypeName))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortTypeName{}, SortKItem{}}(VarTypeName:SortTypeName{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisTypeName{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isTypeQualifier(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortTypeQualifier{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortTypeQualifier{}, SortKItem{}}(Var'Unds'1:SortTypeQualifier{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisTypeQualifier{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isTypeQualifier(inj{TypeQualifier,KItem}(TypeQualifier))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortTypeQualifier{}, SortKItem{}}(VarTypeQualifier:SortTypeQualifier{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisTypeQualifier{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isTypeSpecifier(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortTypeSpecifier{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortTypeSpecifier{}, SortKItem{}}(Var'Unds'1:SortTypeSpecifier{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisTypeSpecifier{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isTypeSpecifier(inj{TypeSpecifier,KItem}(TypeSpecifier))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortTypeSpecifier{}, SortKItem{}}(VarTypeSpecifier:SortTypeSpecifier{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisTypeSpecifier{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isTypedefOfname(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortTypedefOfname{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortTypedefOfname{}, SortKItem{}}(Var'Unds'1:SortTypedefOfname{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisTypedefOfname{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isTypedefOfname(inj{TypedefOfname,KItem}(TypedefOfname))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortTypedefOfname{}, SortKItem{}}(VarTypedefOfname:SortTypedefOfname{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisTypedefOfname{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isUnaryExpression(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortUnaryExpression{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortUnaryExpression{}, SortKItem{}}(Var'Unds'1:SortUnaryExpression{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisUnaryExpression{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isUnaryExpression(inj{UnaryExpression,KItem}(UnaryExpression))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortUnaryExpression{}, SortKItem{}}(VarUnaryExpression:SortUnaryExpression{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisUnaryExpression{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule isUnaryOperator(K)=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [owise]
  axiom{R} \implies{R} (
    \and{R} (
      \not{R} (
        \or{R} (
          \exists{R} (Var'Unds'1:SortUnaryOperator{},
            \and{R} (
              \top{R}(),
              \and{R} (
                \in{SortK{}, R} (
                  X0:SortK{},
                  kseq{}(inj{SortUnaryOperator{}, SortKItem{}}(Var'Unds'1:SortUnaryOperator{}),dotk{}())
                ),
                \top{R} ()
              )
          )),
          \bottom{R}()
        )
      ),
      \and{R}(
        \top{R}(),
        \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )
    )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisUnaryOperator{}(X0:SortK{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [owise{}()]

// rule isUnaryOperator(inj{UnaryOperator,KItem}(UnaryOperator))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortUnaryOperator{}, SortKItem{}}(VarUnaryOperator:SortUnaryOperator{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblisUnaryOperator{}(X0:SortK{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  []

// rule `minInt(_,_)_INT-COMMON_Int_Int_Int`(I1,I2)=>I1 requires `_<=Int_`(I1,I2) ensures #token("true","Bool") [UNIQUE_ID(fb09b6acc4366cb77203e07c4efe8a9cf304e1bac9fb0664deea05d3eb9a80c6), contentStartColumn(8), contentStartLine(1113), org.kframework.attributes.Location(Location(1113,8,1113,57)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody "requires" Bool [klabel(#ruleRequires), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \equals{SortBool{},R}(
        Lbl'Unds-LT-Eqls'Int'Unds'{}(VarI1:SortInt{},VarI2:SortInt{}),
        \dv{SortBool{}}("true")),
      \and{R} (
          \in{SortInt{}, R} (
            X0:SortInt{},
            VarI1:SortInt{}
          ),\and{R} (
          \in{SortInt{}, R} (
            X1:SortInt{},
            VarI2:SortInt{}
          ),
          \top{R} ()
        ))),
    \and{R} (
      \equals{SortInt{},R} (
        LblminInt'LParUndsCommUndsRParUnds'INT-COMMON'Unds'Int'Unds'Int'Unds'Int{}(X0:SortInt{},X1:SortInt{}),
        VarI1:SortInt{}),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody \"requires\" Bool [klabel(#ruleRequires), symbol]"), contentStartLine{}("1113"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1113,8,1113,57)"), UNIQUE'Unds'ID{}("fb09b6acc4366cb77203e07c4efe8a9cf304e1bac9fb0664deea05d3eb9a80c6")]

// rule `minInt(_,_)_INT-COMMON_Int_Int_Int`(I1,I2)=>I2 requires `_>=Int_`(I1,I2) ensures #token("true","Bool") [UNIQUE_ID(e1effeabf96bb3a3beffd5b679ad5df95c4f8bbf42872b0793331e52a8470fb3), contentStartColumn(8), contentStartLine(1114), org.kframework.attributes.Location(Location(1114,8,1114,57)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody "requires" Bool [klabel(#ruleRequires), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \equals{SortBool{},R}(
        Lbl'Unds-GT-Eqls'Int'Unds'{}(VarI1:SortInt{},VarI2:SortInt{}),
        \dv{SortBool{}}("true")),
      \and{R} (
          \in{SortInt{}, R} (
            X0:SortInt{},
            VarI1:SortInt{}
          ),\and{R} (
          \in{SortInt{}, R} (
            X1:SortInt{},
            VarI2:SortInt{}
          ),
          \top{R} ()
        ))),
    \and{R} (
      \equals{SortInt{},R} (
        LblminInt'LParUndsCommUndsRParUnds'INT-COMMON'Unds'Int'Unds'Int'Unds'Int{}(X0:SortInt{},X1:SortInt{}),
        VarI2:SortInt{}),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody \"requires\" Bool [klabel(#ruleRequires), symbol]"), contentStartLine{}("1114"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1114,8,1114,57)"), UNIQUE'Unds'ID{}("e1effeabf96bb3a3beffd5b679ad5df95c4f8bbf42872b0793331e52a8470fb3")]

// rule `notBool_`(#token("false","Bool"))=>#token("true","Bool") requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(17ebc68421572b8ebe609c068fb49cbb6cbbe3246e2142257ad8befdda38f415), contentStartColumn(8), contentStartLine(837), org.kframework.attributes.Location(Location(837,8,837,29)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortBool{}, R} (
            X0:SortBool{},
            \dv{SortBool{}}("false")
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblnotBool'Unds'{}(X0:SortBool{}),
        \dv{SortBool{}}("true")),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("837"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(837,8,837,29)"), UNIQUE'Unds'ID{}("17ebc68421572b8ebe609c068fb49cbb6cbbe3246e2142257ad8befdda38f415")]

// rule `notBool_`(#token("true","Bool"))=>#token("false","Bool") requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(53fc758ece1ff16581673016dfacc556cc30fcf6b3c35b586f001d76a1f9336c), contentStartColumn(8), contentStartLine(836), org.kframework.attributes.Location(Location(836,8,836,29)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortBool{}, R} (
            X0:SortBool{},
            \dv{SortBool{}}("true")
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        LblnotBool'Unds'{}(X0:SortBool{}),
        \dv{SortBool{}}("false")),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("836"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(836,8,836,29)"), UNIQUE'Unds'ID{}("53fc758ece1ff16581673016dfacc556cc30fcf6b3c35b586f001d76a1f9336c")]

// rule `project:#tempFile:fd`(#tempFile(K0,K1))=>K1 requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortIOFile{}, R} (
            X0:SortIOFile{},
            Lbl'Hash'tempFile{}(VarK0:SortString{},VarK1:SortInt{})
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortInt{},R} (
        Lblproject'ColnHash'tempFile'Coln'fd{}(X0:SortIOFile{}),
        VarK1:SortInt{}),
      \top{R}()))
  []

// rule `project:#tempFile:path`(#tempFile(K0,K1))=>K0 requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortIOFile{}, R} (
            X0:SortIOFile{},
            Lbl'Hash'tempFile{}(VarK0:SortString{},VarK1:SortInt{})
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortString{},R} (
        Lblproject'ColnHash'tempFile'Coln'path{}(X0:SortIOFile{}),
        VarK0:SortString{}),
      \top{R}()))
  []

// rule `project:#unknownIOError:errno`(#unknownIOError(K0))=>K0 requires #token("true","Bool") ensures #token("true","Bool") 
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortIOError{}, R} (
            X0:SortIOError{},
            Lbl'Hash'unknownIOError{}(VarK0:SortInt{})
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortInt{},R} (
        Lblproject'ColnHash'unknownIOError'Coln'errno{}(X0:SortIOError{}),
        VarK0:SortInt{}),
      \top{R}()))
  []

// rule `project:AbstractDeclarator`(inj{AbstractDeclarator,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortAbstractDeclarator{}, SortKItem{}}(VarK:SortAbstractDeclarator{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortAbstractDeclarator{},R} (
        Lblproject'Coln'AbstractDeclarator{}(X0:SortK{}),
        VarK:SortAbstractDeclarator{}),
      \top{R}()))
  [projection{}()]

// rule `project:AdditiveExpression`(inj{AdditiveExpression,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortAdditiveExpression{}, SortKItem{}}(VarK:SortAdditiveExpression{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortAdditiveExpression{},R} (
        Lblproject'Coln'AdditiveExpression{}(X0:SortK{}),
        VarK:SortAdditiveExpression{}),
      \top{R}()))
  [projection{}()]

// rule `project:AndExpression`(inj{AndExpression,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortAndExpression{}, SortKItem{}}(VarK:SortAndExpression{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortAndExpression{},R} (
        Lblproject'Coln'AndExpression{}(X0:SortK{}),
        VarK:SortAndExpression{}),
      \top{R}()))
  [projection{}()]

// rule `project:AssignmentExpression`(inj{AssignmentExpression,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortAssignmentExpression{}, SortKItem{}}(VarK:SortAssignmentExpression{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortAssignmentExpression{},R} (
        Lblproject'Coln'AssignmentExpression{}(X0:SortK{}),
        VarK:SortAssignmentExpression{}),
      \top{R}()))
  [projection{}()]

// rule `project:AssignmentOperator`(inj{AssignmentOperator,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortAssignmentOperator{}, SortKItem{}}(VarK:SortAssignmentOperator{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortAssignmentOperator{},R} (
        Lblproject'Coln'AssignmentOperator{}(X0:SortK{}),
        VarK:SortAssignmentOperator{}),
      \top{R}()))
  [projection{}()]

// rule `project:Bool`(inj{Bool,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortBool{}, SortKItem{}}(VarK:SortBool{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortBool{},R} (
        Lblproject'Coln'Bool{}(X0:SortK{}),
        VarK:SortBool{}),
      \top{R}()))
  [projection{}()]

// rule `project:CastExpression`(inj{CastExpression,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortCastExpression{}, SortKItem{}}(VarK:SortCastExpression{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortCastExpression{},R} (
        Lblproject'Coln'CastExpression{}(X0:SortK{}),
        VarK:SortCastExpression{}),
      \top{R}()))
  [projection{}()]

// rule `project:CompoundStatement`(inj{CompoundStatement,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortCompoundStatement{}, SortKItem{}}(VarK:SortCompoundStatement{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortCompoundStatement{},R} (
        Lblproject'Coln'CompoundStatement{}(X0:SortK{}),
        VarK:SortCompoundStatement{}),
      \top{R}()))
  [projection{}()]

// rule `project:ConditionalExpression`(inj{ConditionalExpression,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortConditionalExpression{}, SortKItem{}}(VarK:SortConditionalExpression{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortConditionalExpression{},R} (
        Lblproject'Coln'ConditionalExpression{}(X0:SortK{}),
        VarK:SortConditionalExpression{}),
      \top{R}()))
  [projection{}()]

// rule `project:Constant`(inj{Constant,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortConstant{}, SortKItem{}}(VarK:SortConstant{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortConstant{},R} (
        Lblproject'Coln'Constant{}(X0:SortK{}),
        VarK:SortConstant{}),
      \top{R}()))
  [projection{}()]

// rule `project:ConstantExpression`(inj{ConstantExpression,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortConstantExpression{}, SortKItem{}}(VarK:SortConstantExpression{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortConstantExpression{},R} (
        Lblproject'Coln'ConstantExpression{}(X0:SortK{}),
        VarK:SortConstantExpression{}),
      \top{R}()))
  [projection{}()]

// rule `project:Declaration`(inj{Declaration,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortDeclaration{}, SortKItem{}}(VarK:SortDeclaration{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortDeclaration{},R} (
        Lblproject'Coln'Declaration{}(X0:SortK{}),
        VarK:SortDeclaration{}),
      \top{R}()))
  [projection{}()]

// rule `project:DeclarationSpecifier`(inj{DeclarationSpecifier,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortDeclarationSpecifier{}, SortKItem{}}(VarK:SortDeclarationSpecifier{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortDeclarationSpecifier{},R} (
        Lblproject'Coln'DeclarationSpecifier{}(X0:SortK{}),
        VarK:SortDeclarationSpecifier{}),
      \top{R}()))
  [projection{}()]

// rule `project:Declarator`(inj{Declarator,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortDeclarator{}, SortKItem{}}(VarK:SortDeclarator{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortDeclarator{},R} (
        Lblproject'Coln'Declarator{}(X0:SortK{}),
        VarK:SortDeclarator{}),
      \top{R}()))
  [projection{}()]

// rule `project:DirectAbstractDeclarator`(inj{DirectAbstractDeclarator,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortDirectAbstractDeclarator{}, SortKItem{}}(VarK:SortDirectAbstractDeclarator{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortDirectAbstractDeclarator{},R} (
        Lblproject'Coln'DirectAbstractDeclarator{}(X0:SortK{}),
        VarK:SortDirectAbstractDeclarator{}),
      \top{R}()))
  [projection{}()]

// rule `project:DirectDeclarator`(inj{DirectDeclarator,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortDirectDeclarator{}, SortKItem{}}(VarK:SortDirectDeclarator{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortDirectDeclarator{},R} (
        Lblproject'Coln'DirectDeclarator{}(X0:SortK{}),
        VarK:SortDirectDeclarator{}),
      \top{R}()))
  [projection{}()]

// rule `project:EnumOfspecifier`(inj{EnumOfspecifier,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortEnumOfspecifier{}, SortKItem{}}(VarK:SortEnumOfspecifier{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortEnumOfspecifier{},R} (
        Lblproject'Coln'EnumOfspecifier{}(X0:SortK{}),
        VarK:SortEnumOfspecifier{}),
      \top{R}()))
  [projection{}()]

// rule `project:EnumerationConstant`(inj{EnumerationConstant,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortEnumerationConstant{}, SortKItem{}}(VarK:SortEnumerationConstant{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortEnumerationConstant{},R} (
        Lblproject'Coln'EnumerationConstant{}(X0:SortK{}),
        VarK:SortEnumerationConstant{}),
      \top{R}()))
  [projection{}()]

// rule `project:Enumerator`(inj{Enumerator,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortEnumerator{}, SortKItem{}}(VarK:SortEnumerator{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortEnumerator{},R} (
        Lblproject'Coln'Enumerator{}(X0:SortK{}),
        VarK:SortEnumerator{}),
      \top{R}()))
  [projection{}()]

// rule `project:EnumeratorList`(inj{EnumeratorList,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortEnumeratorList{}, SortKItem{}}(VarK:SortEnumeratorList{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortEnumeratorList{},R} (
        Lblproject'Coln'EnumeratorList{}(X0:SortK{}),
        VarK:SortEnumeratorList{}),
      \top{R}()))
  [projection{}()]

// rule `project:EqualityExpression`(inj{EqualityExpression,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortEqualityExpression{}, SortKItem{}}(VarK:SortEqualityExpression{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortEqualityExpression{},R} (
        Lblproject'Coln'EqualityExpression{}(X0:SortK{}),
        VarK:SortEqualityExpression{}),
      \top{R}()))
  [projection{}()]

// rule `project:ExclusiveOforExpression`(inj{ExclusiveOforExpression,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortExclusiveOforExpression{}, SortKItem{}}(VarK:SortExclusiveOforExpression{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortExclusiveOforExpression{},R} (
        Lblproject'Coln'ExclusiveOforExpression{}(X0:SortK{}),
        VarK:SortExclusiveOforExpression{}),
      \top{R}()))
  [projection{}()]

// rule `project:Expression`(inj{Expression,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortExpression{}, SortKItem{}}(VarK:SortExpression{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortExpression{},R} (
        Lblproject'Coln'Expression{}(X0:SortK{}),
        VarK:SortExpression{}),
      \top{R}()))
  [projection{}()]

// rule `project:ExpressionStatement`(inj{ExpressionStatement,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortExpressionStatement{}, SortKItem{}}(VarK:SortExpressionStatement{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortExpressionStatement{},R} (
        Lblproject'Coln'ExpressionStatement{}(X0:SortK{}),
        VarK:SortExpressionStatement{}),
      \top{R}()))
  [projection{}()]

// rule `project:ExternalDeclaration`(inj{ExternalDeclaration,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortExternalDeclaration{}, SortKItem{}}(VarK:SortExternalDeclaration{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortExternalDeclaration{},R} (
        Lblproject'Coln'ExternalDeclaration{}(X0:SortK{}),
        VarK:SortExternalDeclaration{}),
      \top{R}()))
  [projection{}()]

// rule `project:Float`(inj{Float,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortFloat{}, SortKItem{}}(VarK:SortFloat{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortFloat{},R} (
        Lblproject'Coln'Float{}(X0:SortK{}),
        VarK:SortFloat{}),
      \top{R}()))
  [projection{}()]

// rule `project:FunctionDefinition`(inj{FunctionDefinition,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortFunctionDefinition{}, SortKItem{}}(VarK:SortFunctionDefinition{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortFunctionDefinition{},R} (
        Lblproject'Coln'FunctionDefinition{}(X0:SortK{}),
        VarK:SortFunctionDefinition{}),
      \top{R}()))
  [projection{}()]

// rule `project:GeneratedCounterCell`(inj{GeneratedCounterCell,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortGeneratedCounterCell{}, SortKItem{}}(VarK:SortGeneratedCounterCell{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortGeneratedCounterCell{},R} (
        Lblproject'Coln'GeneratedCounterCell{}(X0:SortK{}),
        VarK:SortGeneratedCounterCell{}),
      \top{R}()))
  [projection{}()]

// rule `project:GeneratedCounterCellOpt`(inj{GeneratedCounterCellOpt,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortGeneratedCounterCellOpt{}, SortKItem{}}(VarK:SortGeneratedCounterCellOpt{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortGeneratedCounterCellOpt{},R} (
        Lblproject'Coln'GeneratedCounterCellOpt{}(X0:SortK{}),
        VarK:SortGeneratedCounterCellOpt{}),
      \top{R}()))
  [projection{}()]

// rule `project:GeneratedTopCell`(inj{GeneratedTopCell,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortGeneratedTopCell{}, SortKItem{}}(VarK:SortGeneratedTopCell{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortGeneratedTopCell{},R} (
        Lblproject'Coln'GeneratedTopCell{}(X0:SortK{}),
        VarK:SortGeneratedTopCell{}),
      \top{R}()))
  [projection{}()]

// rule `project:GeneratedTopCellFragment`(inj{GeneratedTopCellFragment,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortGeneratedTopCellFragment{}, SortKItem{}}(VarK:SortGeneratedTopCellFragment{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortGeneratedTopCellFragment{},R} (
        Lblproject'Coln'GeneratedTopCellFragment{}(X0:SortK{}),
        VarK:SortGeneratedTopCellFragment{}),
      \top{R}()))
  [projection{}()]

// rule `project:IOError`(inj{IOError,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortIOError{}, SortKItem{}}(VarK:SortIOError{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortIOError{},R} (
        Lblproject'Coln'IOError{}(X0:SortK{}),
        VarK:SortIOError{}),
      \top{R}()))
  [projection{}()]

// rule `project:IOFile`(inj{IOFile,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortIOFile{}, SortKItem{}}(VarK:SortIOFile{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortIOFile{},R} (
        Lblproject'Coln'IOFile{}(X0:SortK{}),
        VarK:SortIOFile{}),
      \top{R}()))
  [projection{}()]

// rule `project:IOInt`(inj{IOInt,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortIOInt{}, SortKItem{}}(VarK:SortIOInt{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortIOInt{},R} (
        Lblproject'Coln'IOInt{}(X0:SortK{}),
        VarK:SortIOInt{}),
      \top{R}()))
  [projection{}()]

// rule `project:IOString`(inj{IOString,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortIOString{}, SortKItem{}}(VarK:SortIOString{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortIOString{},R} (
        Lblproject'Coln'IOString{}(X0:SortK{}),
        VarK:SortIOString{}),
      \top{R}()))
  [projection{}()]

// rule `project:Id`(inj{Id,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortId{}, SortKItem{}}(VarK:SortId{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortId{},R} (
        Lblproject'Coln'Id{}(X0:SortK{}),
        VarK:SortId{}),
      \top{R}()))
  [projection{}()]

// rule `project:Ids`(inj{Ids,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortIds{}, SortKItem{}}(VarK:SortIds{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortIds{},R} (
        Lblproject'Coln'Ids{}(X0:SortK{}),
        VarK:SortIds{}),
      \top{R}()))
  [projection{}()]

// rule `project:InclusiveOforExpression`(inj{InclusiveOforExpression,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortInclusiveOforExpression{}, SortKItem{}}(VarK:SortInclusiveOforExpression{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortInclusiveOforExpression{},R} (
        Lblproject'Coln'InclusiveOforExpression{}(X0:SortK{}),
        VarK:SortInclusiveOforExpression{}),
      \top{R}()))
  [projection{}()]

// rule `project:Initdeclarator`(inj{Initdeclarator,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortInitdeclarator{}, SortKItem{}}(VarK:SortInitdeclarator{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortInitdeclarator{},R} (
        Lblproject'Coln'Initdeclarator{}(X0:SortK{}),
        VarK:SortInitdeclarator{}),
      \top{R}()))
  [projection{}()]

// rule `project:Initializer`(inj{Initializer,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortInitializer{}, SortKItem{}}(VarK:SortInitializer{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortInitializer{},R} (
        Lblproject'Coln'Initializer{}(X0:SortK{}),
        VarK:SortInitializer{}),
      \top{R}()))
  [projection{}()]

// rule `project:InitializerList`(inj{InitializerList,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortInitializerList{}, SortKItem{}}(VarK:SortInitializerList{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortInitializerList{},R} (
        Lblproject'Coln'InitializerList{}(X0:SortK{}),
        VarK:SortInitializerList{}),
      \top{R}()))
  [projection{}()]

// rule `project:Int`(inj{Int,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortInt{}, SortKItem{}}(VarK:SortInt{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortInt{},R} (
        Lblproject'Coln'Int{}(X0:SortK{}),
        VarK:SortInt{}),
      \top{R}()))
  [projection{}()]

// rule `project:IterationStatement`(inj{IterationStatement,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortIterationStatement{}, SortKItem{}}(VarK:SortIterationStatement{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortIterationStatement{},R} (
        Lblproject'Coln'IterationStatement{}(X0:SortK{}),
        VarK:SortIterationStatement{}),
      \top{R}()))
  [projection{}()]

// rule `project:JumpStatement`(inj{JumpStatement,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortJumpStatement{}, SortKItem{}}(VarK:SortJumpStatement{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortJumpStatement{},R} (
        Lblproject'Coln'JumpStatement{}(X0:SortK{}),
        VarK:SortJumpStatement{}),
      \top{R}()))
  [projection{}()]

// rule `project:K`(K)=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            VarK:SortK{}
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortK{},R} (
        Lblproject'Coln'K{}(X0:SortK{}),
        VarK:SortK{}),
      \top{R}()))
  [projection{}()]

// rule `project:KCell`(inj{KCell,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortKCell{}, SortKItem{}}(VarK:SortKCell{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortKCell{},R} (
        Lblproject'Coln'KCell{}(X0:SortK{}),
        VarK:SortKCell{}),
      \top{R}()))
  [projection{}()]

// rule `project:KCellOpt`(inj{KCellOpt,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortKCellOpt{}, SortKItem{}}(VarK:SortKCellOpt{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortKCellOpt{},R} (
        Lblproject'Coln'KCellOpt{}(X0:SortK{}),
        VarK:SortKCellOpt{}),
      \top{R}()))
  [projection{}()]

// rule `project:KItem`(K)=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(VarK:SortKItem{},dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortKItem{},R} (
        Lblproject'Coln'KItem{}(X0:SortK{}),
        VarK:SortKItem{}),
      \top{R}()))
  [projection{}()]

// rule `project:LabeledStatement`(inj{LabeledStatement,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortLabeledStatement{}, SortKItem{}}(VarK:SortLabeledStatement{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortLabeledStatement{},R} (
        Lblproject'Coln'LabeledStatement{}(X0:SortK{}),
        VarK:SortLabeledStatement{}),
      \top{R}()))
  [projection{}()]

// rule `project:List`(inj{List,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortList{}, SortKItem{}}(VarK:SortList{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortList{},R} (
        Lblproject'Coln'List{}(X0:SortK{}),
        VarK:SortList{}),
      \top{R}()))
  [projection{}()]

// rule `project:ListAssignmentExpression`(inj{ListAssignmentExpression,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortListAssignmentExpression{}, SortKItem{}}(VarK:SortListAssignmentExpression{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortListAssignmentExpression{},R} (
        Lblproject'Coln'ListAssignmentExpression{}(X0:SortK{}),
        VarK:SortListAssignmentExpression{}),
      \top{R}()))
  [projection{}()]

// rule `project:ListDeclaration`(inj{ListDeclaration,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortListDeclaration{}, SortKItem{}}(VarK:SortListDeclaration{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortListDeclaration{},R} (
        Lblproject'Coln'ListDeclaration{}(X0:SortK{}),
        VarK:SortListDeclaration{}),
      \top{R}()))
  [projection{}()]

// rule `project:ListDeclarationSpecifier`(inj{ListDeclarationSpecifier,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortListDeclarationSpecifier{}, SortKItem{}}(VarK:SortListDeclarationSpecifier{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortListDeclarationSpecifier{},R} (
        Lblproject'Coln'ListDeclarationSpecifier{}(X0:SortK{}),
        VarK:SortListDeclarationSpecifier{}),
      \top{R}()))
  [projection{}()]

// rule `project:ListExternalDeclaration`(inj{ListExternalDeclaration,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortListExternalDeclaration{}, SortKItem{}}(VarK:SortListExternalDeclaration{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortListExternalDeclaration{},R} (
        Lblproject'Coln'ListExternalDeclaration{}(X0:SortK{}),
        VarK:SortListExternalDeclaration{}),
      \top{R}()))
  [projection{}()]

// rule `project:ListInitDeclarator`(inj{ListInitDeclarator,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortListInitDeclarator{}, SortKItem{}}(VarK:SortListInitDeclarator{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortListInitDeclarator{},R} (
        Lblproject'Coln'ListInitDeclarator{}(X0:SortK{}),
        VarK:SortListInitDeclarator{}),
      \top{R}()))
  [projection{}()]

// rule `project:ListSpecifierQualifier`(inj{ListSpecifierQualifier,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortListSpecifierQualifier{}, SortKItem{}}(VarK:SortListSpecifierQualifier{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortListSpecifierQualifier{},R} (
        Lblproject'Coln'ListSpecifierQualifier{}(X0:SortK{}),
        VarK:SortListSpecifierQualifier{}),
      \top{R}()))
  [projection{}()]

// rule `project:ListStatement`(inj{ListStatement,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortListStatement{}, SortKItem{}}(VarK:SortListStatement{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortListStatement{},R} (
        Lblproject'Coln'ListStatement{}(X0:SortK{}),
        VarK:SortListStatement{}),
      \top{R}()))
  [projection{}()]

// rule `project:ListStructDeclaration`(inj{ListStructDeclaration,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortListStructDeclaration{}, SortKItem{}}(VarK:SortListStructDeclaration{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortListStructDeclaration{},R} (
        Lblproject'Coln'ListStructDeclaration{}(X0:SortK{}),
        VarK:SortListStructDeclaration{}),
      \top{R}()))
  [projection{}()]

// rule `project:ListTypeQualifier`(inj{ListTypeQualifier,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortListTypeQualifier{}, SortKItem{}}(VarK:SortListTypeQualifier{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortListTypeQualifier{},R} (
        Lblproject'Coln'ListTypeQualifier{}(X0:SortK{}),
        VarK:SortListTypeQualifier{}),
      \top{R}()))
  [projection{}()]

// rule `project:LogicalOfandExpression`(inj{LogicalOfandExpression,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortLogicalOfandExpression{}, SortKItem{}}(VarK:SortLogicalOfandExpression{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortLogicalOfandExpression{},R} (
        Lblproject'Coln'LogicalOfandExpression{}(X0:SortK{}),
        VarK:SortLogicalOfandExpression{}),
      \top{R}()))
  [projection{}()]

// rule `project:LogicalOforExpression`(inj{LogicalOforExpression,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortLogicalOforExpression{}, SortKItem{}}(VarK:SortLogicalOforExpression{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortLogicalOforExpression{},R} (
        Lblproject'Coln'LogicalOforExpression{}(X0:SortK{}),
        VarK:SortLogicalOforExpression{}),
      \top{R}()))
  [projection{}()]

// rule `project:Map`(inj{Map,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortMap{}, SortKItem{}}(VarK:SortMap{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortMap{},R} (
        Lblproject'Coln'Map{}(X0:SortK{}),
        VarK:SortMap{}),
      \top{R}()))
  [projection{}()]

// rule `project:MultiplicativeExpression`(inj{MultiplicativeExpression,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortMultiplicativeExpression{}, SortKItem{}}(VarK:SortMultiplicativeExpression{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortMultiplicativeExpression{},R} (
        Lblproject'Coln'MultiplicativeExpression{}(X0:SortK{}),
        VarK:SortMultiplicativeExpression{}),
      \top{R}()))
  [projection{}()]

// rule `project:OslCell`(inj{OslCell,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortOslCell{}, SortKItem{}}(VarK:SortOslCell{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortOslCell{},R} (
        Lblproject'Coln'OslCell{}(X0:SortK{}),
        VarK:SortOslCell{}),
      \top{R}()))
  [projection{}()]

// rule `project:OslCellOpt`(inj{OslCellOpt,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortOslCellOpt{}, SortKItem{}}(VarK:SortOslCellOpt{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortOslCellOpt{},R} (
        Lblproject'Coln'OslCellOpt{}(X0:SortK{}),
        VarK:SortOslCellOpt{}),
      \top{R}()))
  [projection{}()]

// rule `project:ParameterDeclaration`(inj{ParameterDeclaration,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortParameterDeclaration{}, SortKItem{}}(VarK:SortParameterDeclaration{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortParameterDeclaration{},R} (
        Lblproject'Coln'ParameterDeclaration{}(X0:SortK{}),
        VarK:SortParameterDeclaration{}),
      \top{R}()))
  [projection{}()]

// rule `project:ParameterList`(inj{ParameterList,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortParameterList{}, SortKItem{}}(VarK:SortParameterList{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortParameterList{},R} (
        Lblproject'Coln'ParameterList{}(X0:SortK{}),
        VarK:SortParameterList{}),
      \top{R}()))
  [projection{}()]

// rule `project:ParameterTypeList`(inj{ParameterTypeList,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortParameterTypeList{}, SortKItem{}}(VarK:SortParameterTypeList{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortParameterTypeList{},R} (
        Lblproject'Coln'ParameterTypeList{}(X0:SortK{}),
        VarK:SortParameterTypeList{}),
      \top{R}()))
  [projection{}()]

// rule `project:Pointer`(inj{Pointer,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortPointer{}, SortKItem{}}(VarK:SortPointer{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortPointer{},R} (
        Lblproject'Coln'Pointer{}(X0:SortK{}),
        VarK:SortPointer{}),
      \top{R}()))
  [projection{}()]

// rule `project:PostfixExpression`(inj{PostfixExpression,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortPostfixExpression{}, SortKItem{}}(VarK:SortPostfixExpression{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortPostfixExpression{},R} (
        Lblproject'Coln'PostfixExpression{}(X0:SortK{}),
        VarK:SortPostfixExpression{}),
      \top{R}()))
  [projection{}()]

// rule `project:PrimaryExpression`(inj{PrimaryExpression,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortPrimaryExpression{}, SortKItem{}}(VarK:SortPrimaryExpression{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortPrimaryExpression{},R} (
        Lblproject'Coln'PrimaryExpression{}(X0:SortK{}),
        VarK:SortPrimaryExpression{}),
      \top{R}()))
  [projection{}()]

// rule `project:RelationalExpression`(inj{RelationalExpression,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortRelationalExpression{}, SortKItem{}}(VarK:SortRelationalExpression{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortRelationalExpression{},R} (
        Lblproject'Coln'RelationalExpression{}(X0:SortK{}),
        VarK:SortRelationalExpression{}),
      \top{R}()))
  [projection{}()]

// rule `project:SelectionStatement`(inj{SelectionStatement,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortSelectionStatement{}, SortKItem{}}(VarK:SortSelectionStatement{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortSelectionStatement{},R} (
        Lblproject'Coln'SelectionStatement{}(X0:SortK{}),
        VarK:SortSelectionStatement{}),
      \top{R}()))
  [projection{}()]

// rule `project:Set`(inj{Set,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortSet{}, SortKItem{}}(VarK:SortSet{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortSet{},R} (
        Lblproject'Coln'Set{}(X0:SortK{}),
        VarK:SortSet{}),
      \top{R}()))
  [projection{}()]

// rule `project:ShiftExpression`(inj{ShiftExpression,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortShiftExpression{}, SortKItem{}}(VarK:SortShiftExpression{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortShiftExpression{},R} (
        Lblproject'Coln'ShiftExpression{}(X0:SortK{}),
        VarK:SortShiftExpression{}),
      \top{R}()))
  [projection{}()]

// rule `project:SpecifierQualifier`(inj{SpecifierQualifier,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortSpecifierQualifier{}, SortKItem{}}(VarK:SortSpecifierQualifier{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortSpecifierQualifier{},R} (
        Lblproject'Coln'SpecifierQualifier{}(X0:SortK{}),
        VarK:SortSpecifierQualifier{}),
      \top{R}()))
  [projection{}()]

// rule `project:Statement`(inj{Statement,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortStatement{}, SortKItem{}}(VarK:SortStatement{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortStatement{},R} (
        Lblproject'Coln'Statement{}(X0:SortK{}),
        VarK:SortStatement{}),
      \top{R}()))
  [projection{}()]

// rule `project:StorageClassSpecifier`(inj{StorageClassSpecifier,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortStorageClassSpecifier{}, SortKItem{}}(VarK:SortStorageClassSpecifier{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortStorageClassSpecifier{},R} (
        Lblproject'Coln'StorageClassSpecifier{}(X0:SortK{}),
        VarK:SortStorageClassSpecifier{}),
      \top{R}()))
  [projection{}()]

// rule `project:Stream`(inj{Stream,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortStream{}, SortKItem{}}(VarK:SortStream{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortStream{},R} (
        Lblproject'Coln'Stream{}(X0:SortK{}),
        VarK:SortStream{}),
      \top{R}()))
  [projection{}()]

// rule `project:String`(inj{String,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortString{}, SortKItem{}}(VarK:SortString{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortString{},R} (
        Lblproject'Coln'String{}(X0:SortK{}),
        VarK:SortString{}),
      \top{R}()))
  [projection{}()]

// rule `project:StructDeclaration`(inj{StructDeclaration,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortStructDeclaration{}, SortKItem{}}(VarK:SortStructDeclaration{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortStructDeclaration{},R} (
        Lblproject'Coln'StructDeclaration{}(X0:SortK{}),
        VarK:SortStructDeclaration{}),
      \top{R}()))
  [projection{}()]

// rule `project:StructDeclarator`(inj{StructDeclarator,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortStructDeclarator{}, SortKItem{}}(VarK:SortStructDeclarator{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortStructDeclarator{},R} (
        Lblproject'Coln'StructDeclarator{}(X0:SortK{}),
        VarK:SortStructDeclarator{}),
      \top{R}()))
  [projection{}()]

// rule `project:StructDeclaratorList`(inj{StructDeclaratorList,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortStructDeclaratorList{}, SortKItem{}}(VarK:SortStructDeclaratorList{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortStructDeclaratorList{},R} (
        Lblproject'Coln'StructDeclaratorList{}(X0:SortK{}),
        VarK:SortStructDeclaratorList{}),
      \top{R}()))
  [projection{}()]

// rule `project:StructOrFunionSpecifier`(inj{StructOrFunionSpecifier,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortStructOrFunionSpecifier{}, SortKItem{}}(VarK:SortStructOrFunionSpecifier{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortStructOrFunionSpecifier{},R} (
        Lblproject'Coln'StructOrFunionSpecifier{}(X0:SortK{}),
        VarK:SortStructOrFunionSpecifier{}),
      \top{R}()))
  [projection{}()]

// rule `project:StructOrUnion`(inj{StructOrUnion,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortStructOrUnion{}, SortKItem{}}(VarK:SortStructOrUnion{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortStructOrUnion{},R} (
        Lblproject'Coln'StructOrUnion{}(X0:SortK{}),
        VarK:SortStructOrUnion{}),
      \top{R}()))
  [projection{}()]

// rule `project:TCell`(inj{TCell,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortTCell{}, SortKItem{}}(VarK:SortTCell{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortTCell{},R} (
        Lblproject'Coln'TCell{}(X0:SortK{}),
        VarK:SortTCell{}),
      \top{R}()))
  [projection{}()]

// rule `project:TCellFragment`(inj{TCellFragment,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortTCellFragment{}, SortKItem{}}(VarK:SortTCellFragment{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortTCellFragment{},R} (
        Lblproject'Coln'TCellFragment{}(X0:SortK{}),
        VarK:SortTCellFragment{}),
      \top{R}()))
  [projection{}()]

// rule `project:TCellOpt`(inj{TCellOpt,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortTCellOpt{}, SortKItem{}}(VarK:SortTCellOpt{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortTCellOpt{},R} (
        Lblproject'Coln'TCellOpt{}(X0:SortK{}),
        VarK:SortTCellOpt{}),
      \top{R}()))
  [projection{}()]

// rule `project:TranslationUnit`(inj{TranslationUnit,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortTranslationUnit{}, SortKItem{}}(VarK:SortTranslationUnit{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortTranslationUnit{},R} (
        Lblproject'Coln'TranslationUnit{}(X0:SortK{}),
        VarK:SortTranslationUnit{}),
      \top{R}()))
  [projection{}()]

// rule `project:TypeName`(inj{TypeName,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortTypeName{}, SortKItem{}}(VarK:SortTypeName{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortTypeName{},R} (
        Lblproject'Coln'TypeName{}(X0:SortK{}),
        VarK:SortTypeName{}),
      \top{R}()))
  [projection{}()]

// rule `project:TypeQualifier`(inj{TypeQualifier,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortTypeQualifier{}, SortKItem{}}(VarK:SortTypeQualifier{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortTypeQualifier{},R} (
        Lblproject'Coln'TypeQualifier{}(X0:SortK{}),
        VarK:SortTypeQualifier{}),
      \top{R}()))
  [projection{}()]

// rule `project:TypeSpecifier`(inj{TypeSpecifier,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortTypeSpecifier{}, SortKItem{}}(VarK:SortTypeSpecifier{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortTypeSpecifier{},R} (
        Lblproject'Coln'TypeSpecifier{}(X0:SortK{}),
        VarK:SortTypeSpecifier{}),
      \top{R}()))
  [projection{}()]

// rule `project:TypedefOfname`(inj{TypedefOfname,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortTypedefOfname{}, SortKItem{}}(VarK:SortTypedefOfname{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortTypedefOfname{},R} (
        Lblproject'Coln'TypedefOfname{}(X0:SortK{}),
        VarK:SortTypedefOfname{}),
      \top{R}()))
  [projection{}()]

// rule `project:UnaryExpression`(inj{UnaryExpression,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortUnaryExpression{}, SortKItem{}}(VarK:SortUnaryExpression{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortUnaryExpression{},R} (
        Lblproject'Coln'UnaryExpression{}(X0:SortK{}),
        VarK:SortUnaryExpression{}),
      \top{R}()))
  [projection{}()]

// rule `project:UnaryOperator`(inj{UnaryOperator,KItem}(K))=>K requires #token("true","Bool") ensures #token("true","Bool") [projection]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortK{}, R} (
            X0:SortK{},
            kseq{}(inj{SortUnaryOperator{}, SortKItem{}}(VarK:SortUnaryOperator{}),dotk{}())
          ),
          \top{R} ()
        )),
    \and{R} (
      \equals{SortUnaryOperator{},R} (
        Lblproject'Coln'UnaryOperator{}(X0:SortK{}),
        VarK:SortUnaryOperator{}),
      \top{R}()))
  [projection{}()]

// rule `replace(_,_,_,_)_STRING-COMMON_String_String_String_String_Int`(Source,ToReplace,Replacement,Count)=>`_+String__STRING-COMMON_String_String_String`(`_+String__STRING-COMMON_String_String_String`(`substrString(_,_,_)_STRING-COMMON_String_String_Int_Int`(Source,#token("0","Int"),`findString(_,_,_)_STRING-COMMON_Int_String_String_Int`(Source,ToReplace,#token("0","Int"))),Replacement),`replace(_,_,_,_)_STRING-COMMON_String_String_String_String_Int`(`substrString(_,_,_)_STRING-COMMON_String_String_Int_Int`(Source,`_+Int_`(`findString(_,_,_)_STRING-COMMON_Int_String_String_Int`(Source,ToReplace,#token("0","Int")),`lengthString(_)_STRING-COMMON_Int_String`(ToReplace)),`lengthString(_)_STRING-COMMON_Int_String`(Source)),ToReplace,Replacement,`_-Int_`(Count,#token("1","Int")))) requires `_>Int_`(Count,#token("0","Int")) ensures #token("true","Bool") [UNIQUE_ID(311b80d2cb12d368f230eba968464e1fc926bd57e304059b282b82af4d9626d9), contentStartColumn(8), contentStartLine(1570), org.kframework.attributes.Location(Location(1570,8,1573,30)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody "requires" Bool [klabel(#ruleRequires), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \equals{SortBool{},R}(
        Lbl'Unds-GT-'Int'Unds'{}(VarCount:SortInt{},\dv{SortInt{}}("0")),
        \dv{SortBool{}}("true")),
      \and{R} (
          \in{SortString{}, R} (
            X0:SortString{},
            VarSource:SortString{}
          ),\and{R} (
          \in{SortString{}, R} (
            X1:SortString{},
            VarToReplace:SortString{}
          ),\and{R} (
          \in{SortString{}, R} (
            X2:SortString{},
            VarReplacement:SortString{}
          ),\and{R} (
          \in{SortInt{}, R} (
            X3:SortInt{},
            VarCount:SortInt{}
          ),
          \top{R} ()
        ))))),
    \and{R} (
      \equals{SortString{},R} (
        Lblreplace'LParUndsCommUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'String'Unds'String'Unds'String'Unds'String'Unds'Int{}(X0:SortString{},X1:SortString{},X2:SortString{},X3:SortInt{}),
        Lbl'UndsPlus'String'UndsUnds'STRING-COMMON'Unds'String'Unds'String'Unds'String{}(Lbl'UndsPlus'String'UndsUnds'STRING-COMMON'Unds'String'Unds'String'Unds'String{}(LblsubstrString'LParUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'String'Unds'String'Unds'Int'Unds'Int{}(VarSource:SortString{},\dv{SortInt{}}("0"),LblfindString'LParUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'Int'Unds'String'Unds'String'Unds'Int{}(VarSource:SortString{},VarToReplace:SortString{},\dv{SortInt{}}("0"))),VarReplacement:SortString{}),Lblreplace'LParUndsCommUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'String'Unds'String'Unds'String'Unds'String'Unds'Int{}(LblsubstrString'LParUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'String'Unds'String'Unds'Int'Unds'Int{}(VarSource:SortString{},Lbl'UndsPlus'Int'Unds'{}(LblfindString'LParUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'Int'Unds'String'Unds'String'Unds'Int{}(VarSource:SortString{},VarToReplace:SortString{},\dv{SortInt{}}("0")),LbllengthString'LParUndsRParUnds'STRING-COMMON'Unds'Int'Unds'String{}(VarToReplace:SortString{})),LbllengthString'LParUndsRParUnds'STRING-COMMON'Unds'Int'Unds'String{}(VarSource:SortString{})),VarToReplace:SortString{},VarReplacement:SortString{},Lbl'Unds'-Int'Unds'{}(VarCount:SortInt{},\dv{SortInt{}}("1"))))),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody \"requires\" Bool [klabel(#ruleRequires), symbol]"), contentStartLine{}("1570"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1570,8,1573,30)"), UNIQUE'Unds'ID{}("311b80d2cb12d368f230eba968464e1fc926bd57e304059b282b82af4d9626d9")]

// rule `replace(_,_,_,_)_STRING-COMMON_String_String_String_String_Int`(Source,_0,_1,#token("0","Int"))=>Source requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(4367434b0f61c404f7a2e926426bd23874dd547de689c5d15089967fbab2b3d5), contentStartColumn(8), contentStartLine(1574), org.kframework.attributes.Location(Location(1574,8,1574,49)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortString{}, R} (
            X0:SortString{},
            VarSource:SortString{}
          ),\and{R} (
          \in{SortString{}, R} (
            X1:SortString{},
            Var'Unds'0:SortString{}
          ),\and{R} (
          \in{SortString{}, R} (
            X2:SortString{},
            Var'Unds'1:SortString{}
          ),\and{R} (
          \in{SortInt{}, R} (
            X3:SortInt{},
            \dv{SortInt{}}("0")
          ),
          \top{R} ()
        ))))),
    \and{R} (
      \equals{SortString{},R} (
        Lblreplace'LParUndsCommUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'String'Unds'String'Unds'String'Unds'String'Unds'Int{}(X0:SortString{},X1:SortString{},X2:SortString{},X3:SortInt{}),
        VarSource:SortString{}),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("1574"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1574,8,1574,49)"), UNIQUE'Unds'ID{}("4367434b0f61c404f7a2e926426bd23874dd547de689c5d15089967fbab2b3d5")]

// rule `replaceAll(_,_,_)_STRING-COMMON_String_String_String_String`(Source,ToReplace,Replacement)=>`replace(_,_,_,_)_STRING-COMMON_String_String_String_String_Int`(Source,ToReplace,Replacement,`countAllOccurrences(_,_)_STRING-COMMON_Int_String_String`(Source,ToReplace)) requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(262167183c3ec2e214d12bac6e639d7ac1a9f973582e16eca6c1af1da7ecc0a5), contentStartColumn(8), contentStartLine(1575), org.kframework.attributes.Location(Location(1575,8,1575,154)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortString{}, R} (
            X0:SortString{},
            VarSource:SortString{}
          ),\and{R} (
          \in{SortString{}, R} (
            X1:SortString{},
            VarToReplace:SortString{}
          ),\and{R} (
          \in{SortString{}, R} (
            X2:SortString{},
            VarReplacement:SortString{}
          ),
          \top{R} ()
        )))),
    \and{R} (
      \equals{SortString{},R} (
        LblreplaceAll'LParUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'String'Unds'String'Unds'String'Unds'String{}(X0:SortString{},X1:SortString{},X2:SortString{}),
        Lblreplace'LParUndsCommUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'String'Unds'String'Unds'String'Unds'String'Unds'Int{}(VarSource:SortString{},VarToReplace:SortString{},VarReplacement:SortString{},LblcountAllOccurrences'LParUndsCommUndsRParUnds'STRING-COMMON'Unds'Int'Unds'String'Unds'String{}(VarSource:SortString{},VarToReplace:SortString{}))),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("1575"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1575,8,1575,154)"), UNIQUE'Unds'ID{}("262167183c3ec2e214d12bac6e639d7ac1a9f973582e16eca6c1af1da7ecc0a5")]

// rule `replaceFirst(_,_,_)_STRING-COMMON_String_String_String_String`(Source,ToReplace,Replacement)=>`_+String__STRING-COMMON_String_String_String`(`_+String__STRING-COMMON_String_String_String`(`substrString(_,_,_)_STRING-COMMON_String_String_Int_Int`(Source,#token("0","Int"),`findString(_,_,_)_STRING-COMMON_Int_String_String_Int`(Source,ToReplace,#token("0","Int"))),Replacement),`substrString(_,_,_)_STRING-COMMON_String_String_Int_Int`(Source,`_+Int_`(`findString(_,_,_)_STRING-COMMON_Int_String_String_Int`(Source,ToReplace,#token("0","Int")),`lengthString(_)_STRING-COMMON_Int_String`(ToReplace)),`lengthString(_)_STRING-COMMON_Int_String`(Source))) requires `_>=Int_`(`findString(_,_,_)_STRING-COMMON_Int_String_String_Int`(Source,ToReplace,#token("0","Int")),#token("0","Int")) ensures #token("true","Bool") [UNIQUE_ID(e290042e5b5b2f620c0ca1871e708c3713c62b63b283e317bb7568e13968fe0c), contentStartColumn(8), contentStartLine(1563), org.kframework.attributes.Location(Location(1563,8,1565,66)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody "requires" Bool [klabel(#ruleRequires), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \equals{SortBool{},R}(
        Lbl'Unds-GT-Eqls'Int'Unds'{}(LblfindString'LParUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'Int'Unds'String'Unds'String'Unds'Int{}(VarSource:SortString{},VarToReplace:SortString{},\dv{SortInt{}}("0")),\dv{SortInt{}}("0")),
        \dv{SortBool{}}("true")),
      \and{R} (
          \in{SortString{}, R} (
            X0:SortString{},
            VarSource:SortString{}
          ),\and{R} (
          \in{SortString{}, R} (
            X1:SortString{},
            VarToReplace:SortString{}
          ),\and{R} (
          \in{SortString{}, R} (
            X2:SortString{},
            VarReplacement:SortString{}
          ),
          \top{R} ()
        )))),
    \and{R} (
      \equals{SortString{},R} (
        LblreplaceFirst'LParUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'String'Unds'String'Unds'String'Unds'String{}(X0:SortString{},X1:SortString{},X2:SortString{}),
        Lbl'UndsPlus'String'UndsUnds'STRING-COMMON'Unds'String'Unds'String'Unds'String{}(Lbl'UndsPlus'String'UndsUnds'STRING-COMMON'Unds'String'Unds'String'Unds'String{}(LblsubstrString'LParUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'String'Unds'String'Unds'Int'Unds'Int{}(VarSource:SortString{},\dv{SortInt{}}("0"),LblfindString'LParUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'Int'Unds'String'Unds'String'Unds'Int{}(VarSource:SortString{},VarToReplace:SortString{},\dv{SortInt{}}("0"))),VarReplacement:SortString{}),LblsubstrString'LParUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'String'Unds'String'Unds'Int'Unds'Int{}(VarSource:SortString{},Lbl'UndsPlus'Int'Unds'{}(LblfindString'LParUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'Int'Unds'String'Unds'String'Unds'Int{}(VarSource:SortString{},VarToReplace:SortString{},\dv{SortInt{}}("0")),LbllengthString'LParUndsRParUnds'STRING-COMMON'Unds'Int'Unds'String{}(VarToReplace:SortString{})),LbllengthString'LParUndsRParUnds'STRING-COMMON'Unds'Int'Unds'String{}(VarSource:SortString{})))),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody \"requires\" Bool [klabel(#ruleRequires), symbol]"), contentStartLine{}("1563"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1563,8,1565,66)"), UNIQUE'Unds'ID{}("e290042e5b5b2f620c0ca1871e708c3713c62b63b283e317bb7568e13968fe0c")]

// rule `replaceFirst(_,_,_)_STRING-COMMON_String_String_String_String`(Source,ToReplace,_0)=>Source requires `_<Int_`(`findString(_,_,_)_STRING-COMMON_Int_String_String_Int`(Source,ToReplace,#token("0","Int")),#token("0","Int")) ensures #token("true","Bool") [UNIQUE_ID(8fbd1c8efb9988236eddc95fc2af4a3e74f6ec94d696ee47209543fd0826dd34), contentStartColumn(8), contentStartLine(1566), org.kframework.attributes.Location(Location(1566,8,1567,57)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody "requires" Bool [klabel(#ruleRequires), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \equals{SortBool{},R}(
        Lbl'Unds-LT-'Int'Unds'{}(LblfindString'LParUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'Int'Unds'String'Unds'String'Unds'Int{}(VarSource:SortString{},VarToReplace:SortString{},\dv{SortInt{}}("0")),\dv{SortInt{}}("0")),
        \dv{SortBool{}}("true")),
      \and{R} (
          \in{SortString{}, R} (
            X0:SortString{},
            VarSource:SortString{}
          ),\and{R} (
          \in{SortString{}, R} (
            X1:SortString{},
            VarToReplace:SortString{}
          ),\and{R} (
          \in{SortString{}, R} (
            X2:SortString{},
            Var'Unds'0:SortString{}
          ),
          \top{R} ()
        )))),
    \and{R} (
      \equals{SortString{},R} (
        LblreplaceFirst'LParUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'String'Unds'String'Unds'String'Unds'String{}(X0:SortString{},X1:SortString{},X2:SortString{}),
        VarSource:SortString{}),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody \"requires\" Bool [klabel(#ruleRequires), symbol]"), contentStartLine{}("1566"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1566,8,1567,57)"), UNIQUE'Unds'ID{}("8fbd1c8efb9988236eddc95fc2af4a3e74f6ec94d696ee47209543fd0826dd34")]

// rule `rfindChar(_,_,_)_STRING-COMMON_Int_String_String_Int`(S1,S2,I)=>`maxInt(_,_)_INT-COMMON_Int_Int_Int`(`rfindString(_,_,_)_STRING-COMMON_Int_String_String_Int`(S1,`substrString(_,_,_)_STRING-COMMON_String_String_Int_Int`(S2,#token("0","Int"),#token("1","Int")),I),`rfindChar(_,_,_)_STRING-COMMON_Int_String_String_Int`(S1,`substrString(_,_,_)_STRING-COMMON_String_String_Int_Int`(S2,#token("1","Int"),`lengthString(_)_STRING-COMMON_Int_String`(S2)),I)) requires `_=/=String__STRING-COMMON_Bool_String_String`(S2,#token("\"\"","String")) ensures #token("true","Bool") [UNIQUE_ID(b7f740050d72a847424b022a9c8217325aba8a154a42831aa3c7a3b0727f3205), contentStartColumn(8), contentStartLine(1555), org.kframework.attributes.Location(Location(1555,8,1555,182)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody "requires" Bool [klabel(#ruleRequires), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \equals{SortBool{},R}(
        Lbl'UndsEqlsSlshEqls'String'UndsUnds'STRING-COMMON'Unds'Bool'Unds'String'Unds'String{}(VarS2:SortString{},\dv{SortString{}}("")),
        \dv{SortBool{}}("true")),
      \and{R} (
          \in{SortString{}, R} (
            X0:SortString{},
            VarS1:SortString{}
          ),\and{R} (
          \in{SortString{}, R} (
            X1:SortString{},
            VarS2:SortString{}
          ),\and{R} (
          \in{SortInt{}, R} (
            X2:SortInt{},
            VarI:SortInt{}
          ),
          \top{R} ()
        )))),
    \and{R} (
      \equals{SortInt{},R} (
        LblrfindChar'LParUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'Int'Unds'String'Unds'String'Unds'Int{}(X0:SortString{},X1:SortString{},X2:SortInt{}),
        LblmaxInt'LParUndsCommUndsRParUnds'INT-COMMON'Unds'Int'Unds'Int'Unds'Int{}(LblrfindString'LParUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'Int'Unds'String'Unds'String'Unds'Int{}(VarS1:SortString{},LblsubstrString'LParUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'String'Unds'String'Unds'Int'Unds'Int{}(VarS2:SortString{},\dv{SortInt{}}("0"),\dv{SortInt{}}("1")),VarI:SortInt{}),LblrfindChar'LParUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'Int'Unds'String'Unds'String'Unds'Int{}(VarS1:SortString{},LblsubstrString'LParUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'String'Unds'String'Unds'Int'Unds'Int{}(VarS2:SortString{},\dv{SortInt{}}("1"),LbllengthString'LParUndsRParUnds'STRING-COMMON'Unds'Int'Unds'String{}(VarS2:SortString{})),VarI:SortInt{}))),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody \"requires\" Bool [klabel(#ruleRequires), symbol]"), contentStartLine{}("1555"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1555,8,1555,182)"), UNIQUE'Unds'ID{}("b7f740050d72a847424b022a9c8217325aba8a154a42831aa3c7a3b0727f3205")]

// rule `rfindChar(_,_,_)_STRING-COMMON_Int_String_String_Int`(_0,#token("\"\"","String"),_1)=>#token("-1","Int") requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(23b9fa88124c547d94aed32124d1ccd1069732b059f4c8b430ab4617979690f6), contentStartColumn(8), contentStartLine(1556), org.kframework.attributes.Location(Location(1556,8,1556,33)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortString{}, R} (
            X0:SortString{},
            Var'Unds'0:SortString{}
          ),\and{R} (
          \in{SortString{}, R} (
            X1:SortString{},
            \dv{SortString{}}("")
          ),\and{R} (
          \in{SortInt{}, R} (
            X2:SortInt{},
            Var'Unds'1:SortInt{}
          ),
          \top{R} ()
        )))),
    \and{R} (
      \equals{SortInt{},R} (
        LblrfindChar'LParUndsCommUndsCommUndsRParUnds'STRING-COMMON'Unds'Int'Unds'String'Unds'String'Unds'Int{}(X0:SortString{},X1:SortString{},X2:SortInt{}),
        \dv{SortInt{}}("-1")),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("1556"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1556,8,1556,33)"), UNIQUE'Unds'ID{}("23b9fa88124c547d94aed32124d1ccd1069732b059f4c8b430ab4617979690f6")]

// rule `signExtendBitRangeInt(_,_,_)_INT-COMMON_Int_Int_Int_Int`(I,IDX,LEN)=>`_-Int_`(`_modInt_`(`_+Int_`(`bitRangeInt(_,_,_)_INT-COMMON_Int_Int_Int_Int`(I,IDX,LEN),`_<<Int_`(#token("1","Int"),`_-Int_`(LEN,#token("1","Int")))),`_<<Int_`(#token("1","Int"),LEN)),`_<<Int_`(#token("1","Int"),`_-Int_`(LEN,#token("1","Int")))) requires #token("true","Bool") ensures #token("true","Bool") [UNIQUE_ID(3b67f4bf2235fc46fc94b1d10e936100ea3fc4f2dbaa4e4a77593e8385f5004f), contentStartColumn(8), contentStartLine(1103), org.kframework.attributes.Location(Location(1103,8,1103,164)), org.kframework.attributes.Source(Source(/usr/include/kframework/builtin/domains.md)), org.kframework.definition.Production(syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol])]
  axiom{R} \implies{R} (
    \and{R}(
      \top{R}(),
      \and{R} (
          \in{SortInt{}, R} (
            X0:SortInt{},
            VarI:SortInt{}
          ),\and{R} (
          \in{SortInt{}, R} (
            X1:SortInt{},
            VarIDX:SortInt{}
          ),\and{R} (
          \in{SortInt{}, R} (
            X2:SortInt{},
            VarLEN:SortInt{}
          ),
          \top{R} ()
        )))),
    \and{R} (
      \equals{SortInt{},R} (
        LblsignExtendBitRangeInt'LParUndsCommUndsCommUndsRParUnds'INT-COMMON'Unds'Int'Unds'Int'Unds'Int'Unds'Int{}(X0:SortInt{},X1:SortInt{},X2:SortInt{}),
        Lbl'Unds'-Int'Unds'{}(Lbl'Unds'modInt'Unds'{}(Lbl'UndsPlus'Int'Unds'{}(LblbitRangeInt'LParUndsCommUndsCommUndsRParUnds'INT-COMMON'Unds'Int'Unds'Int'Unds'Int'Unds'Int{}(VarI:SortInt{},VarIDX:SortInt{},VarLEN:SortInt{}),Lbl'Unds-LT--LT-'Int'Unds'{}(\dv{SortInt{}}("1"),Lbl'Unds'-Int'Unds'{}(VarLEN:SortInt{},\dv{SortInt{}}("1")))),Lbl'Unds-LT--LT-'Int'Unds'{}(\dv{SortInt{}}("1"),VarLEN:SortInt{})),Lbl'Unds-LT--LT-'Int'Unds'{}(\dv{SortInt{}}("1"),Lbl'Unds'-Int'Unds'{}(VarLEN:SortInt{},\dv{SortInt{}}("1"))))),
      \top{R}()))
  [org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/usr/include/kframework/builtin/domains.md)"), org'Stop'kframework'Stop'definition'Stop'Production{}("syntax #RuleContent ::= #RuleBody [klabel(#ruleNoConditions), symbol]"), contentStartLine{}("1103"), contentStartColumn{}("8"), org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(1103,8,1103,164)"), UNIQUE'Unds'ID{}("3b67f4bf2235fc46fc94b1d10e936100ea3fc4f2dbaa4e4a77593e8385f5004f")]


// priority groups
endmodule [org'Stop'kframework'Stop'attributes'Stop'Location{}("Location(3,1,14,9)"), org'Stop'kframework'Stop'attributes'Stop'Source{}("Source(/home/alessio/Project/osl/cfrontend/./c.k)")]
